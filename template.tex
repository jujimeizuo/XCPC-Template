
\documentclass[twoside]{article}
\usepackage[colorlinks,linkcolor=black]{hyperref}
\usepackage{xeCJK,xunicode}
\usepackage{fancyhdr}
\usepackage{amsmath,amsthm}
\usepackage{listings,xcolor}
\usepackage{geometry}
\usepackage{fontspec}
\setCJKmainfont[BoldFont=STYuanti-SC-Regular,ItalicFont=STYuanti-SC-Regular]{STYuanti-SC-Regular} 
\setCJKmonofont[BoldFont=STYuanti-SC-Regular]{STYuanti-SC-Regular} 
\setCJKsansfont{STYuanti-SC-Regular}
\setsansfont{Monaco}
\setmonofont[Mapping={}]{Monaco}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\lstset{
    language    = c++,
    breaklines  = true,
    captionpos  = b,
    tabsize     = 4,
    numbers     = left,
    columns     = fullflexible,
    keepspaces  = true,
    commentstyle = \color[RGB]{0,128,0},
    keywordstyle = \color[RGB]{0,0,255},
    basicstyle   = \small\ttfamily,
    rulesepcolor = \color{red!20!green!20!blue!20},
    showstringspaces = false,
}
\title{ACM/ICPC Template Runtime Error}
\author{锟斤拷之烫}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{ACM/ICPC Template Runtime Error, 锟斤拷之烫}
\begin{document}\small
\begin{titlepage}
\begin{center}
\vspace*{0.5cm}\includegraphics[width=0.75\textwidth]{logo.jpg} \\ [2cm]
\HRule \\ [1cm]
\textbf{\Huge{ACM/ICPC Template Runtime Error}} \\ [0.5cm]
\HRule \\ [4cm]
\textbf{\Huge{浙江工商大学}} \\ [1cm]
\LARGE{锟斤拷之烫}
\vfill
\Large{\today}
\end{center}
\clearpage
\end{titlepage}
\tableofcontents\clearpage
\pagestyle{fancy}
\lfoot{}
\cfoot{\thepage}\rfoot{}
\setcounter{section}{-1}
\setcounter{page}{1}
\clearpage\section{头文件}
\subsection{Header}
\begin{lstlisting}
#include "bits/stdc++.h"

using namespace std;

typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef vector<ll> VI;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef pair<ll, ll> pll;

#define endl "\n"
#define fi first
#define se second
#define eb emplace_back
#define mem(a, b) memset(a , b , sizeof(a))

const ll INF = 0x3f3f3f3f;
const ll mod = 998244353;
// const ll mod = 1e9 + 7;
const double eps = 1e-6;
const double PI = acos(-1);
const double R = 0.57721566490153286060651209;


void solve() {

}

signed main() {
    ios_base::sync_with_stdio(false);
    // cin.tie(nullptr);
    // cout.tie(nullptr);
#ifdef FZT_ACM_LOCAL
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
    signed test_index_for_debug = 1;
    char acm_local_for_debug = 0;
    do {
        if (acm_local_for_debug == '$') exit(0);
        if (test_index_for_debug > 20)
            throw runtime_error("Check the stdin!!!");
        auto start_clock_for_debug = clock();
        solve();
        auto end_clock_for_debug = clock();
        cout << "Test " << test_index_for_debug << " successful" << endl;
        cerr << "Test " << test_index_for_debug++ << " Run Time: "
             << double(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC << "s" << endl;
        cout << "--------------------------------------------------" << endl;
    } while (cin >> acm_local_for_debug && cin.putback(acm_local_for_debug));
#else
    solve();
#endif
    return 0;
}
\end{lstlisting}
\clearpage\section{字符串}
\subsection{字符串哈希}
\begin{lstlisting}
// 区间哈希

const int N = 100010, P = 131;  // 这里的P 是经验值 131 ，或者13331

int n,m;
char str[N];
// 这里用unsigned long long 存储就相当于mod 2 ^ 64, 因为超过了会溢出的
ULL h[N], p[N];   // h[]是存储字符串哈希值的  p[] 是存储p次方的  

ULL get(int l, int r) {
    return h[r] - h[l -1] * p[r - l + 1];     // 区间hash 的公式
}

int main() {
    scanf("%d%d%s", &n, &m, str + 1);

    p[0] = 1;
    for(int i=1; i<=n; i++) {
        p[i] = p[i-1] * P;  // p数组保存 计算的次方数
        h[i] = h[i-1] * P +str[i];   // 计算字符串的前缀，  后面的是0次 所以直接加上str[i]就行了
    }

    while(m -- ) {
        int l1, r1, l2, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2)   ;
        if(get(l1, r1) == get(l2, r2)) cout << "Yes" << endl;
        else cout << "No" << endl;
    }
    return 0;
}

// 线段树维护区间哈希
struct Tree {
    int l, r;
    ull sum;
    Tree operator + (const Tree &a) const {
        Tree ans;
        ans.l = l, ans.r = a.r;
        ans.sum = sum * p[a.r - a.l + 1] + a.sum;
        return ans;
    }
}t[N << 2];
\end{lstlisting}
\subsection{KMP}
\begin{lstlisting}
const int maxn = 10000005;
int Next[maxn];
int slen, tlen;
char S[maxn], T[maxn];
void GetNext() {
    int j, k;
    j = 0;
    k = -1;
    Next[0] = -1;
    while(j < tlen) {
        if(k == -1 || T[j] == T[k]) {
            Next[++j] = ++k;
        }
        else
            k = Next[k];
        }
}
 
/*返回模式串T在主串S中c首次出现的位置 , 返回的位置是从0开始的*/
int KMP_Index() {
    int i = 0, j = 0;
    GetNext();
    while(i < slen && j < tlen) {
        if(j == -1 || S[i] == T[j]) i++, j++;
        else j = Next[j];
    }
    if(j == tlen) return i - tlen;
    else return -1;
}

 /*返回模式串T在字串中出现的次数*/
int KMP_Count() {
    int ans = 0;
    if(slen == 1 && tlen == 1) {
        if(S[0] == T[0])
            return 1;
        else 
            return 0;
    }
    GetNext();
    int j = 0;
    for(int i = 0;i < slen; i++) {
        while(j > 0 && S[i] != T[j]) {
            j = Next[j];
        }
        if(S[i] == T[j]) j++;
        if(j == tlen) {
            ans++;
            j = Next[j];
        }
        /*if(j ==tlen)
        {
            printf("%d ",i - j);
        }
        模式串在主串中所有的位置*/
        }
    return ans;
}
int main()
{
    cin >> S >> T;
    slen = strlen(S);
    tlen = strlen(T);
    cout << "返回模式串T在主串S中c首次出现的位置是: " << KMP_Index() << endl;
    cout << "返回模式串T在字串中出现的次数是: "<< KMP_Count() << endl;
    return 0;
}

/*----------------------------------*/

//预处理前缀数组,前缀数组用于在字符串失配时进行转跳
#define MAXN 35000
int pi[MAXN];//前缀函数
void prefix_function(string s){
    memset(pi,0,sizeof(pi));
    for(int i=1;i<s.size();i++){
        int p = pi[i-1];
        while(p>0&&s[p]!=s[i])p=pi[p-1];
        if(s[i]==s[p])  pi[i]=++p;
    }
    return ;
}

//KMP写法一,不需要预处理版本
//将两个字符串拼接,如果从前往后求前缀,如果前缀为模式串长度,则匹配成功
vector<int> kmp(string s1,string s2){
    vector<int> appear;
    string s = s2+'%'+s1;//ATTENTION!!这个百分号应该是不存在于s1和s2中的任字符
    for (int i = 1; i < s.size(); i++) {
        int p = pi[i - 1];
        while (p > 0 && s[i] != s[p]) p = pi[p - 1];
        if (s[i] == s[p]) p++;
        pi[i] = p;
        if(pi[i]==s2.size())
            appear.push_back(i-2-s2.size());//注意这里要根据字符串首字母为止为0或1进行微调
                                            //此时为1
    }
    return appear;
}

//KMP写法2,需要对模式串进行预处理
vector<int> kmp(string s1,string s2){
    vector<int> appear;
    int p=0;
    for(int i=0;i<s1.size();i++){
        while (p > 0 && s1[i] != s2[p]) p = pi[p - 1];
        if (s1[i] == s2[p]) p++;
        if(p==s2.size())
            appear.push_back(i+2-s2.size());//要注意同理
    }
    return appear;
}

\end{lstlisting}
\subsection{AC自动机}
\begin{lstlisting}
typedef long long ll;

// 指针版

typedef struct _node {
    _node *child[26]; // 儿子节点
    _node *fail; // ！！！
    vector<int> exist; // 该节点是否存在完整的单词
    bool flag;
}node;

char T[1000005];
int n;

void insert(node *root, char *q) {
    node *tmp = root;
    int len = strlen(q);
    for(int i = 0;i < len; i++) {
        int v = q[i] - 'a';
        if(tmp -> child[v] == NULL) {
            node *temp = new node();
            tmp -> child[v] = temp;
        }
        tmp = tmp -> child[v];
    }
    tmp -> exist.push_back(len);
}

void build(node *root) {
    for(int i = 0;i < n; i++) {
        char p[1000005];
        cin >> p;
        insert(root, p); // 建立字典树
    }
    queue<node*> q; // BFS层次遍历

    for(int i = 0;i < 26; i++) { // 确定第一层的fail指针全部指向root节点
        if(root -> child[i]) {
            q.push(root -> child[i]);
            root -> child[i] -> fail = root;
        }
    }

    while(!q.empty()) {
        node *x = q.front();
        q.pop();
        for(int i = 0;i < 26; i++) {
            if(x -> child[i]) {
                node *y = x -> child[i];
                node *fafail = x -> fail;

                while(fafail && fafail -> child[i] == NULL) {
                    fafail = fafail -> fail;
                }

                if(fafail == NULL)
                    y -> fail = root;
                else
                    y -> fail = fafail -> child[i];

                q.push(y);
            }
        }
    }
}

ll query(node *root) {
    int len = strlen(T);
    ll ans = 0;
    node *tmp = root;
    for(int i = 0;i < len; i++) {
        int c = T[i] - 'a';
        while(tmp -> child[c] == NULL && tmp -> fail) {
            tmp = tmp -> fail;
        }
        if(tmp -> child[c] != NULL) {
            tmp = tmp -> child[c];
        }
        else
            continue;

        if(!tmp -> flag) {
            ans += tmp->exist.size();
            tmp->flag = true;

            if (tmp->exist.size()) {
                for (int j = 0; j < tmp->exist.size(); j++) {
                    int m = tmp->exist[j];
                    for (int k = i - m + 1; k <= i; k++) {
                        cout << T[k];
                    }
                    cout << endl;
                }
            }
        }
    }
    return ans;
}

void AC() {
    node *root = new node();
    build(root);
    query(root);
}

const int CHAR_NUM = 26; // 仅小写
const int N = 1e6 + 10;

int trie[N][CHAR_NUM], cnt;

int fail[N];

int val[N];

char T[N];
int n;

void Insert(char *s) {
    int len = strlen(s);
    int root = 0;
    for(int i = 0;i < len; i++) {
        int v = s[i] - 'a';
        if(!trie[root][v])
            trie[root][v] = ++cnt;
        root = trie[root][v];
    }
    val[root]++;
}

void Build() {
    for(int i = 0;i < n; i++) {
        char p[N];
        cin >> p;
        Insert(p);
    }

    queue<int> q;

    fail[0] = 0;
    for(int i = 0;i < 26; i++) {
        if(trie[0][i]) {
            q.push(trie[0][i]);
            fail[trie[0][i]] = 0;
        }
    }

    while(!q.empty()) {
        int now = q.front();
        q.pop();

        for(int i = 0;i < 26; i++) {
            if(trie[now][i]) {
                fail[trie[now][i]] = trie[fail[now]][i];
                q.push(trie[now][i]);
            }
            else {
                trie[now][i] = trie[fail[now]][i];
            }
        }
    }
}

ll Query() {
    ll ans = 0;
    int len = strlen(T);
    int root = 0;
    for(int i = 0;i < len; i++) {
        int v = T[i] - 'a';
        root = trie[root][v];

        for(int j = root; j && val[j] != -1; j = fail[j]) {
            ans += val[j];
            val[j] = -1;
        }
    }
    return ans;
}

void Ac() {
    Build();
    Query();
}
\end{lstlisting}
\subsection{马拉车}
\begin{lstlisting}
#include <iostream>
#include <cstdio>
#include <cstring>
#define Min(a,b) a>b?b:a
#define Max(a,b) a>b?a:b
using namespace std;
const int N = 2e6 + 10 ;
int Len[N] , a[N] ;
char str[N] ;
int n,mx,id,len;
string s ;
void init(int l , int r){
    
    int k=0;
    str[k++] = '$';
    for(int i=l;i<=r;i++){
    
        str[k++]='#';
        str[k++]=s[i];
    }
    str[k++]='#';
    len=k;
    str[k] = '\0' ;
}
int ans = 0 , flag ;
int Manacher(){
    
  Len[0] = 0;
  int sum = 0;
  mx = 0;
  id = 0 ;
  // cout << str << endl ;
  for(int i=1;i<len;i++){
    
    if(i < mx) Len[i] = Min(mx - i, Len[2 * id - i]);
    else Len[i] = 1;
    while(str[i - Len[i]]== str[i + Len[i]]) Len[i]++;
    if(Len[i] + i > mx){
            // 更新最长的回文串
      mx = Len[i] + i;          // mx是回文串右边一个位置
      id = i;             //id是回文串的中心
      sum = Max(sum, Len[i]);         // sum 是回文串的长度 + 1

    }
    // cout << i << " " << Len[i] << endl ;
    // if(Len[i] == i)  表示前缀是回文的
    //  {
    
    //    if(ans < Len[i])
    //     ans = Len[i] - 1 , flag = 1 ;
    //  }
    // if(Len[i] + i == len)  表示后缀是回文的
    //  if(ans < Len[i])
    //   ans = Len[i] - 1 , flag = 2 ;
  }
  return sum - 1 ;
}

int main()
{
    
  scanf("%d",&n);
  while(n--){
    
    cin >> s ;
    len = s.size();
    int l = 0 , r = len - 1 ;
    init(l , r);
    ans = 0 , flag = 0 ;
    // cout << Manacher() << endl ;
  }
  return 0;
}

\end{lstlisting}
\clearpage\section{动态规划}
\subsection{01背包}
\begin{lstlisting}
int v[1005], w[1005];
int f[1005];

void fsbag() {
    int n, V;
    cin >> n >> V;
    for(int i = 1;i <= n; i++) {
        cin >> v[i] >> w[i];
    }
    
    for(int i = 1;i <= n; i++) {
        for(int j = V;j >= v[i]; j--) {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    
    cout << f[V] << endl;
}
\end{lstlisting}
\subsection{简单多重背包}
\begin{lstlisting}
int v[1005], w[1005], s[1005];
int f[1005];

void mulbag() {
    int N, T;
    cin >> N >> T;
    for(int i = 1;i <= N; i++)
        cin >> v[i] >> w[i] >> s[i];
    for(int i = 1;i <= N; i++) {
        for(int j = T;j >= 0; j--) {
            for(int k = 1;k <= s[i]; k++) {
                if(j - k * v[i] >= 0)
                    f[j] = max(f[j], f[j - k * v[i]] + k * w[i]);
            }
        }
    }
    cout << f[T] << endl;
}
\end{lstlisting}
\subsection{二进制优化多重背包}
\begin{lstlisting}

int f[2005];
struct Good{
     int v, w;
};

void mulbag2() {
    int N, T;
    cin >> N >> T;
    vector<Good> goods;
    for(int i = 1;i <= N; i++) {
        int v, w, s;
        cin >> v >> w >> s;
        for(int k = 1;k <= s; k *= 2) {
            s -= k;
            goods.push_back({v * k, w * k});
        }
        if(s > 0)
            goods.push_back({s * v, s * w});
    }
    for(auto good : goods) {
        for(int j = T;j >= good.v; j--) {
            f[j] = max(f[j], f[j - good.v] + good.w);
        }
    }
    cout << f[T] << endl;
}
\end{lstlisting}
\subsection{单调队列优化多重背包}
\begin{lstlisting}
const int N = 1e5 + 10;

int que[N], head, tail;
int f[N], pre[N];
void solve() {
    int n, m; cin >> n >> m;
    for(int i = 1;i <= n; i++) {
        memcpy(pre, f, sizeof(f));
        int v, w, s; cin >> v >> w >> s;
        for(int j = 0;j < v; j++) {
            head = 1; tail = 0;
            for(int k = j;k <= m; k += v) {
                while(head <= tail && que[head] < k - s * v) head++;
                if(head <= tail) f[k] = max(pre[k], pre[que[head]] + (k - que[head]) / v * w);
                while(head <= tail && pre[k] >= pre[que[tail]] + (k - que[head]) / v * w) tail--;
                que[++tail] = k;
            }
        }
    }
    cout << f[m] << endl;
}
\end{lstlisting}
\subsection{混合背包}
\begin{lstlisting}
struct Good {
    int v, w, kind;
};

int f[2005];
void mulbag2() {
    int n, V;
    cin >> n >> V;
    vector<Good> goods;
    for(int i = 1;i <= n; i++) {
        int v, w, s;
        cin >> v >> w >> s;
        if(s < 0) {
            goods.push_back({v, w, -1});
        }
        else if(s == 0) {
            goods.push_back({v, w, 0});
        }
        else {
            for(int k = 1;k <= s; k *= 2) {
                s -= k;
                goods.push_back({v * k, w * k, -1});
            }
            if(s > 0) 
                goods.push_back({v * s, w * s, -1});
        }
    }
    for(auto good: goods) {
        if(good.kind == -1) {
            for(int j = V;j >= good.v; j--) {
                f[j] = max(f[j], f[j - good.v] + good.w);
            }
        }
        else {
            for(int j = good.v;j <= V; j++) {
                f[j] = max(f[j], f[j - good.v] + good.w);
            }
        }
    }
    cout << f[V] << endl;
}
\end{lstlisting}
\subsection{完全背包}
\begin{lstlisting}
int v[1005], w[1005];
int f[1005];

void cptbag() {
    int N, T;
    cin >> N >> T;
    for(int i = 1;i <= N; i++)
        cin >> v[i] >> w[i];
    for(int i = 1;i <= N; i++) {
        for(int j = 0;j <= T; j++) {
            if(j - v[i] >= 0)
                f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }
    cout << f[T] << endl;
}
\end{lstlisting}
\subsection{分组背包}
\begin{lstlisting}
int v[2005], w[2005];
int f[2005];

void Divbag() {
    int n, V;
    cin >> n >> V;
    for(int i = 1;i <= n; i++) {
        int s;
        cin >> s;
        for(int j = 1;j <= s; j++) {
            cin >> v[j] >> w[j];
        }
        for(int j = V;j >= 0; j--) {
            for(int k = 1;k <= s; k++) {
                if(j >= v[k]) {
                    f[j] = max(f[j], f[j - v[k]] + w[k]);
                }
            }
        }
    }
    cout << f[V] << endl;
}

\end{lstlisting}
\subsection{二维费用背包}
\begin{lstlisting}
int f[2005][2005];

void TwoCostbag() {
    int n, M, V;
    cin >> n >> V >> M;
    for(int i = 1;i <= n; i++) {
        int v, m, w;
        cin >> v >> m >> w;
        for(int j = V;j >= v; j--) {
            for(int k = M;k >= m; k--) {
                f[j][k] = max(f[j][k], f[j - v][k - m] + w);
            }
        }
    }
    cout << f[V][M] << endl;
}

\end{lstlisting}
\subsection{树上背包}
\begin{lstlisting}
//加了剪枝后复杂度为O(NM)

void dfs(int u, int fa) {
    siz[u] = 1;
    for (auto &v: g[u])
        if (v != fa) {
            dfs(v, u);

            int now = min(siz[u] + siz[v] + 1, M);
            int t[MAX_M]; for (int i = 0; i <= M; i++) t[i] = INF/-INF;//初始化
            for (int i = 0; i <= siz[u]; i++)
                for (int j = 0; j <= siz[v] && i + j <= M; j++) {
                    //...转移方程
                }
            for (int i = 0; i <= now; i++) f[u][i] = min/max(f[u][i], t[i]);
            siz[u] = now;
        }
}
\end{lstlisting}
\subsection{LIS}
\begin{lstlisting}
typedef long long ll;
const int N = 1e5 + 10;
const int INF = 0x3f3f3f3f;

int a[N], f[N];

int n;
int ans;

int DP() {
    for(int i = 1;i <= n; i++) {
        f[i] = 1;
    }
    for(int i = 1;i <= n; i++) {
        for(int j = 1;j < i; j++) {
            if(a[j] < a[i]) 
                f[i] = max(f[i], f[j] + 1);
        }
    }
    for(int i = 1;i <= n; i++) {
        ans = max(ans, f[i]);
    }
    return ans;
}

int stl() {
    int d[N];
    fill(f, f + n, INF);
    for(int i = 0;i < n; i++) {
        int j = lower_bound(f, f + n, a[i]) - f;
        d[i] = j + 1;
        if(ans < d[i]) {
            ans = d[i];
        }
        f[j] = a[i];
    }
    return ans;
}

int t[N];
int maxn;

int lowbit(int x) {
    return x & (-x);
}

void update(int k, int val) {
    while(k <= maxn) {
        t[k] = max(t[k], val);
        k += lowbit(k);
    }
}

int query(int k) {
    int res = 0;
    while(k) {
        res = max(res, t[k]);
        k -= lowbit(k);
    }
    return res;
}

int Tree() {
    for(int i = 1;i <= n; i++) {
        maxn = max(maxn, a[i]);
    }

    int ans = 0;
    for(int i = 1;i <= n; i++) {
        int q = query(a[i]) + 1; // 保证j < i，找f[j]最大的
        update(a[i], q);
        ans = max(ans, q);
    }
    return ans;
}


\end{lstlisting}
\subsection{数位DP}
\begin{lstlisting}
// 输出0~n中存在49的个数

int dight[105];
ll dp[105][10]; // 第一维是数位，第二维是上一个数位上的数字

ll DFS(int pos, int pre, bool limit) {// pos为该数位，pre为上一数位上的数字，limit表示是否上界，上一位pre是否已到达最大
    if(pos == 0) return 1; // 每一数位都遍历完，说明这一个数是可取的
    if(!limit && dp[pos][pre] != -1) return dp[pos][pre]; // 剪枝，记忆化搜索
    int up = limit ? dight[pos] : 9; // 如果有上界，则pos该数位只能取到dight[pos]这么大
    ll ans = 0;
    for(int i = 0;i <= up; i++) {// 遍历该数位1~up的每一位
        if(pre == 4 && i == 9) // 如果上一位是4且这一位是9，那就组成了49，不可取
            continue;
        ans += DFS(pos - 1, i, limit && i == dight[pos]); // ans+搜索下一位
    }
    if(!limit)
        dp[pos][pre] = ans;
    return ans;
}

ll sum(ll n) {
    int k = 0;
    while(n) {
        dight[++k] = n % 10; 
        n /= 10;
    }
    return DFS(k, 0, 1);
}

void solve() {
    mem(dp, -1); // 初始化所有的dp
    ll n; cin >> n;
    cout << n - sum(n) + 1 << endl; // +1是因为sum(n)把0也算进去了
}
\end{lstlisting}
\subsection{状压DP}
\begin{lstlisting}
// 杭电1565

int n;
int a[22][22];
int dp[22][1 << 18]; // 第一维是行数，第二位是该行的方案数，继承了前面所有行数的方案数
int tot[1 << 18]; // 方案数

int calc(int i, int k)
{
    int cnt = 1, res = 0;
    while(k)
    {
        if(k & 1) res += a[i][cnt];
        k >>= 1;
        cnt++;
    }
    return res;
}

void solve()
{
    while(cin >> n) {
        mem(dp, 0);
        int cnt = 0;

        for (int i = 0; i <= (1 << n) - 1; i++) { // 预处理
            if ((i & (i >> 1)) == 0) // 判断i这个二进制是否满足相邻没有两个1的条件
                tot[++cnt] = i;
        }

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                cin >> a[i][j];

        for (int i = 1; i <= n; i++) { // 行遍历
            for (int k = 1; k <= cnt; k++) { // 第i行k的二进制排列的数，与下面的j进行&
                int val = calc(i, tot[k]); // 计算k的二进制中1所在a数组里的权值
                for (int j = 1; j <= cnt; j++) { // 第i-1行j的二进制排列的数，与上面的k进行&并进行状态转移
                    if ((tot[j] & tot[k]) == 0)
                        dp[i][k] = max(dp[i][k], dp[i - 1][j] + val);
                }
            }
        }

        int ans = -1;
        for (int j = 1; j <= cnt; j++)
            ans = max(ans, dp[n][j]);

        cout << ans << endl;
    }
}



\end{lstlisting}
\subsection{四边形优化}
\begin{lstlisting}
//四边形优化区间dp(n^3 -> n^2)
//a < b < c < d, f[l][r] = min(f[l][k] + f[k + 1][r] + cost(l, r))
//1. cost(b, c) <= cost(a, d)
//2. cost(a, c) + cost(b, d) <= cost(a, d) + cost(b, c), 即交叉小于包含

void solve() {
    for (int len = 2; len <= n; len++) {
        for (int l = 1, r; l + len - 1 <= n; l++) {
            r = l + len - 1;
            mn[l][r] = 0x3f3f3f3f;
            for (int k = m[l][r - 1]; k <= m[l + 1][r]; k++)
                if (mn[l][k] + mn[k + 1][r] + cost(l, r) < mn[l][r]) {
                    mn[l][r] = mn[l][k] + mn[k + 1][r] + cost(l, r);
                    m[l][r] = k;
                }
        }
    }
}
\end{lstlisting}
\subsection{环基树dp}
\begin{lstlisting}
int flag, S, E;//flag是否找到环, SE为环上两个点

void findCircle(int u, int fa) {
    vis[u] = 1;
    for (int i = head[u], v; i; i = e[i].nxt)
        if ((v = e[i].to) != fa) {
            if (vis[v]) flag = 1, S = u, E = v;
            else findCircle(v, u);
        }
}

void dp(int u, int fa) {
    //dp过程

    for (int i = head[u], v; i; i = e[i].nxt)
        if ((v = e[i].to) != fa && v) {
            dp(v, u);

        }
}

ll calc(int u) {
    flag = 0;
    findCircle(u, 0);
    if (flag) {
        for (int i = head[S], v; i; i = e[i].nxt)
            if ((v = e[i].to) == E) {
                e[i].to = e[i ^ 1].to = 0;//删边操作, 注意e[tot]中tot从2开始
                break;
            }
        ll res = 0;
        dp(S, 0); res = max(res, ...);
        dp(E, 0); res = max(res, ...);
        return res;
    }
    else {
        dp(u, 0);
        return ...;
    }
}
\end{lstlisting}
\subsection{线段树优化dp}
\begin{lstlisting}
const ll INF = 0x3f3f3f3f;

#define lc u << 1
#define rc u << 1 | 1
#define mid (t[u].l + t[u].r) / 2

const int N = 3e5 + 10;
const int K = 100 + 10;
int dp[N][K];

struct Tree {
    int l, r;
    int mn;
    int tag;
}t[N << 1];

inline void push_up(int u) {
    t[u].mn = min(t[lc].mn, t[rc].mn);
}

inline void push_down(int u) {
    if(!t[u].tag) return ;
    t[lc].tag += t[u].tag;
    t[rc].tag += t[u].tag;
    t[lc].mn  += t[u].tag;
    t[rc].mn  += t[u].tag;
    t[u].tag = 0;
}

void build(int u, int l, int r, int k) {
    t[u].l = l; t[u].r = r;
    t[u].tag = 0; t[u].mn = INF;
    if(l == r) {
        t[u].mn = dp[l][k];
        return ;
    }
    int m = (l + r) / 2;
    build(lc, l, m, k);
    build(rc, m + 1, r, k);
    push_up(u);
}

void modify(int u, int ql, int qr, int val) {
    if(ql <= t[u].l && t[u].r <= qr) {
        t[u].mn += val;
        t[u].tag += val;
        return ;
    }
    push_down(u);
    if(ql <= mid) modify(lc, ql, qr, val);
    if(qr >  mid) modify(rc, ql, qr, val);
    push_up(u);
}

int query(int u, int ql, int qr) {
    if(ql <= t[u].l && t[u].r <= qr) return t[u].mn;
    push_down(u);
    int ans = INF;
    if(ql <= mid) ans = min(ans, query(lc, ql, qr));
    if(qr  > mid) ans = min(ans, query(rc, ql, qr));
    return ans;
}


void solve() {
    int n, k; cin >> n >> k;
    vector<int> a(n + 1), pre(n + 1, -1), from(n + 1);
    for(int i = 1;i <= n; i++) cin >> a[i];

    for(int i = 1;i <= n; i++) {
        dp[i][1] = dp[i - 1][1];
        from[i] = pre[a[i]];
        if(from[i] != -1) dp[i][1] += i - from[i];
        pre[a[i]] = i;
    }

    for(int i = 2;i <= k; i++) {
        build(1, 1, n, i - 1);
        for(int j = i;j <= n; j++) {
            if(from[j] != -1) modify(1, 1, from[j] - 1, j - from[j]);
            dp[j][i] = min(dp[j - 1][i - 1], query(1, i - 1, j - 1));
            // cout << j << " " << "分成" << i << "段：" << " " << dp[j][i] << endl;
        }
    }
    cout << dp[n][k] << endl;
}

signed main() {
    solve();
}
\end{lstlisting}
\clearpage\section{数据结构}
\subsection{BTree}
\begin{lstlisting}
template<class T>

struct TreeNode {
    T value;
    TreeNode *left;
    TreeNode *right;
};

template<class T>
TreeNode<T> *createTree(const T *pre, const T *in, const int len) {
    TreeNode<T> *t = NULL;
    if (len > 0) {
        t = new TreeNode<T>;
        t->value = pre[0];
        int index;
        for (index = 0; index < len; index++) {
            if (in[index] == pre[0]) {
                break;
            }
        }
        if (index == len) {
            index = -1;
        }
        t->left = createTree(pre + 1, in, index);
        t->right = createTree(pre + index + 1, in + index + 1, len - index - 1);
    }
    return t;
}

template<class T>
int preOrder(TreeNode<T> *root, queue<T> &out) {
    if (root) {
        int count = 1;
        out.push(root->value);
        count += preOrder(root->left, out);
        count += preOrder(root->right, out);
        return count;
    } else {
        return 0;
    }
}

template<class T>
int inOrder(TreeNode<T> *root, queue<T> &out) {
    if (root) {
        int count = 1;
        count += inOrder(root->left, out);
        out.push(root->value);
        count += inOrder(root->right, out);
        return count;
    } else {
        return 0;
    }
}

template<class T>
void postOrder(TreeNode<T> *root, queue<T> &out) {
    if (root) {
        postOrder(root->left, out);
        postOrder(root->right, out);
        out.push(root->value);
    } else {
        return;
    }
}

template<class T>
T *convertQueueToArray(queue<T> &out, int len) {
    T *list = new T[len];
    int now = 0;
    while (!out.empty() && now < len) {
        list[now] = out.front();
        out.pop();
        now++;
    }
    return list;
}

template<class T>
void destroyTree(TreeNode<T> *root) {
    if (root) {
        destroyTree(root->left);
        destroyTree(root->right);
        delete root;
    } else return;
}

template<class T>
void insertIntoBSTree(TreeNode<T> *root, const T &value) {
    if (!root) {
        return;
    }
    if (value < root->value) {
        if (root->left) {
            insertIntoTree(root->left, value);
        } else {
            root->left = new TreeNode<T>;
            root->left->value = value;
            root->left->left = NULL;
            root->left->right = NULL;
        }
    } else if (value > root->value) {
        if (root->right) {
            insertIntoTree(root->right, value);
        } else {
            root->right = new TreeNode<T>;
            root->right->value = value;
            root->right->left = NULL;
            root->right->right = NULL;
        }
    }
}

template<class T>
TreeNode<T> *createBSTree(T *list, int len) {
    if (len < 1) {
        return NULL;
    }
    TreeNode<T> *root = new TreeNode<char>;
    root->value = list[0];
    root->left = NULL;
    root->right = NULL;
    for (int i = 1; i < len; i++) {
        insertIntoBSTree(root, list[i]);
    }
    return root;
}\end{lstlisting}
\subsection{pbds-bbtree}
\begin{lstlisting}
// RBTree 红黑树
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
// 红黑树
__gnu_pbds::tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> t;
// null_type无映射(低版本g++为null_mapped_type)
// 类似multiset
__gnu_pbds::tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> t;
find_by_order(size_t order);
// 结点更新
tree_order_statistics_node_update
insert(p);
erase(it);
// 求k在树中是第几小,假设插入当前值判断当前值是第几小,最小为第0小
order_of_key(p);
// 找到第order小的迭代器
find_by_order(order);
// 前驱
lower_bound(p);
// 后驱
upper_bound(p);
// 合并
a.join(b);
// 分割 key小于等于v的元素属于a，其余的属于b
a.split(v, b);

// 优先队列
#include <ext/pb_ds/priority_queue.hpp>
#include <ext/pb_ds/assoc_container.hpp>
// 操作类似于stl的优先队列
typedef __gnu_pbds::priority_queue<node, greater<node>, __gnu_pbds::thin_heap_tag> heap;
heap::point_iterator; // 指向元素的指针\end{lstlisting}
\subsection{BIT}
\begin{lstlisting}
// 树状数组和二进制紧紧联系

int tree[100005];
int n;

int lowbit(int x) {
    return x & (-x); // 计算机中负数使用对应正数的补码表示
}

int getsum(int x) {
    int ans = 0;
    while(x > 0) {
        ans += tree[x];
        x -= lowbit(x);
    }
    return ans;
}

void update(int x,int value) {
    while(x <= n) {
        tree[x] += value;
        x += lowbit(x);
    }
}

/*-------区间最大值--------*/
int t[N], a[N];
void modify(int x) {
    while(x <= n) {
        t[x] = a[x];
        for(int i = 1;i < lowbit(x); i <<= 1) {
            t[x] = max(t[x], t[x - i]);
        }
        x += lowbit(x);
    }
}

int query(int l, int r) {
    int ans = 0;
    while(l <= r) {
        ans = max(ans, a[r]);
        for (r-- ;r - lowbit(r) >= l; r -= lowbit(r)) {
            ans = max(ans, t[r]);
        }
    }
    return ans;
}\end{lstlisting}
\subsection{二维BIT}
\begin{lstlisting}

#include <bits/stdc++.h>
using namespace std;

const int N = 1005;
int t[N][N];
int n;

int lowbit(int x) {
    return x & (-x);
}

void update(int x, int y, int val) {
    for(int i = x;i > 0; i -= lowbit(x)) {
        for(int j = y;j > 0; y -= lowbit(y)) {
            t[i][j] += val;
        }
    }
}

int query(int x, int y) {
    int res = 0;
    for(int i = x;i <= n; i += lowbit(x)) {
        for(int j = y;j <= n; j += lowbit(y)) {
            res += t[i][j];
        }
    }
    return res;
}

int main() {
    int m;
    cin >> n >> m;
    while(m--) {
        int opt;
        cin >> opt;
        if(opt == 1) {
            int x1, y1, x2, y2, val;
            cin >> x1 >> y1 >> x2 >> y2 >> val;
            update(x2, y2, val);
            update(x1 - 1, y2, -val);
            update(x2, y1 - 1, -val);
            update(x1 - 1, y1 - 1, val);
        }
        else {
            int x, y;
            cin >> x >> y;
            cout << query(x, y) << endl;
        }
    }
}\end{lstlisting}
\subsection{线段树}
\begin{lstlisting}
const int N = 1e5 + 10;

#define lc u << 1
#define rc u << 1 | 1
#define mid (t[u].l + t[u].r) / 2

struct Tree {
    int l, r;
    int sum, tag;
}t[N << 1];

void push_up(int u) {
    t[u].sum = t[lc].sum + t[rc].sum;
}

void push_down(int u) {
    if(!t[u].tag) return ;
    t[lc].sum += t[u].tag * (t[lc].r - t[lc].l + 1);
    t[rc].sum += t[u].tag * (t[rc].r - t[rc].l + 1);
    t[lc].tag += t[u].tag;
    t[rc].tag += t[u].tag;
    t[u].tag = 0;
}

void modify(int u, int ql, int qr, int v) {
    if(ql <= t[u].l && t[u].r <= qr) return ;
    push_down(u);
    if(ql <= mid) modify(lc, ql, qr, v);
    if(qr > mid)  modify(rc, ql, qr, v);
    push_up(u);
}

int query(int u, int ql, int qr) {
    if(ql <= t[u].l && t[u].r <= qr) return t[u].sum;
    push_down(u);
    int ans = 0;
    if(ql <= mid) ans += query(lc, ql, qr);
    if(qr > mid)  ans += query(rc, ql, qr);
    return ans;
}
\end{lstlisting}
\subsection{二维线段树}
\begin{lstlisting}
#define lc u << 1
#define rc u << 1 | 1
#define m (l + r) / 2

const int N = 1e3 + 10;

struct Tree_y {
    int mx, mn;

    Tree_y operator + (const Tree_y &rhs) {
        Tree_y ans;
        ans.mx = max(mx, rhs.mx);
        ans.mn = min(mn, rhs.mn);
        return ans;
    }
};

int leafx[N], leafy[N];

struct Tree_x {
    Tree_y ty[N << 2];

    void build(int u, int l, int r) {
        ty[u].mx = -INF; ty[u].mn = INF;
        if(l == r) {
            leafy[l] = u;
            return ;
        }
        build(lc, l, m);
        build(rc, m + 1, r);
    }

    Tree_y query(int u, int l, int r, int ql, int qr) {
        if(qr < l || r < ql) return (Tree_y) {-INF, INF};
        if(ql <= l && r <= qr) return ty[u];
        return query(lc, l, m, ql, qr) + query(rc, m + 1, r, ql, qr);
    }
}tx[N << 2];

int n;

void build(int u, int l, int r) {
    tx[u].build(1, 1, n);
    if(l == r) {
        leafx[l] = u;
        return ;
    }
    build(lc, l, m);
    build(rc, m + 1, r);
}

// (x,y)单点更新，首先更新叶子节点，然后向上合并父亲节点
void modify(int x, int y, int val) {
    int valx = leafx[x];
    int valy = leafy[y];
    tx[valx].ty[valy].mn = tx[valx].ty[valy].mx = val;
    for(int i = valx; i; i >>= 1) {
        for(int j = valy; j; j >>= 1) {
            if(i == valx && j == valy) continue ;
            if(j == valy) {
                // 如果当前更新的列就是需要更新的叶子节点，那么由当前行的两个儿子节点来更新
                tx[i].ty[j] = tx[i << 1].ty[j] + tx[i << 1 | 1].ty[j];
            }
            else {
                tx[i].ty[j] = tx[i].ty[j << 1] + tx[i].ty[j << 1 | 1];
            }
        }
    }
}

Tree_y query(int u, int l, int r, int ql, int qr, int qx, int qy) {
    if(qr < l || r < ql) return (Tree_y) {-INF, INF};
    if(ql <= l && r <= qr) return tx[u].query(1, 1, n, qx, qy);
    return query(lc, l, m, ql, qr, qx, qy) + query(rc, m + 1, r, ql, qr, qx, qy);
}
\end{lstlisting}
\subsection{权值线段树}
\begin{lstlisting}
// 权值线段树，相当于一个桶，每个节点用来表示一个区间的数***出现的次数***。

#include <bits/stdc++.h>

using namespace std;

#define lc u << 1
#define rc u << 1 | 1
#define m (l + r) / 2
#define mid (t[u].l + t[u].r) / 2

const int N = 1e5 + 10;

int t[N << 2];

int a[N];

void push_up(int u) {
    t[u] = t[lc] + t[rc];
}

void build(int u, int l, int r) {
    if(l == r) {
        t[u] = a[l]; // a[l]表示数为l的个数
        return ;
    }
    build(lc, l, m);
    build(rc, m + 1, r);
    push_up(u);
}

void update(int u, int l, int r, int k, int cnt) { // k这个数的个数增加cnt
    if(l == r) {
        t[u] += cnt;
        return ;
    }
    if(k <= m)
        update(lc, l, m, k, cnt);
    else
        update(rc, m + 1, r, k, cnt);
    push_up(u); 
}

int query(int u, int l, int r, int k) { // 查询k这个数的个数
    if(l == r) {
        return t[u];
    }
    if(k <= m)
        return query(lc, l, m, k);
    else 
        return query(rc, m + 1, r, k);
}

int k_max_th(int u, int l, int r, int k) { // 查询第k大的值
    if(l == r) {
        return l;
    }
    if(t[lc] >= k) return k_max_th(lc, l, m, k);
    else return k_max_th(rc, m + 1, r, k - t[lc]);
}
\end{lstlisting}
\subsection{线段树动态开点合并分裂}
\begin{lstlisting}
#define mid (l+r)/2
static const int MAX_N = N * 40;
int rt[N], now;
int lc[MAX_N], rc[MAX_N];
ll sum[MAX_N];
int tot, rub[MAX_N];
int newNode() { return rub[0] ? rub[rub[0]--] : ++tot; }
void remove(int &u) {
    lc[u] = rc[u] = sum[u] = 0;
    rub[++rub[0]] = u;
    u = 0;
}
void push_up(int u) { sum[u] = sum[lc[u]] + sum[rc[u]]; }
void build(int &u, int l, int r) {
    u = newNode();
    if (l == r) {
        sum[u] = cnt[l];
        return;
    }
    build(lc[u], l, mid); build(rc[u], mid + 1, r);
    push_up(u);
}
void update(int &u, int l, int r, int p, ll k) {
    if (!u) u = newNode();
    if (l == r) {
        sum[u] += k;
        return;
    }
    if (p <= mid) update(lc[u], l, mid, p, k);
    else update(rc[u], mid + 1, r, p, k);
    push_up(u);
}
ll querySum(int u, int l, int r, int ql, int qr) {
    if (!u) return 0;
    if (ql <= l && r <= qr) return sum[u];
    ll res = 0;
    if (ql <= mid) res += querySum(lc[u], l, mid, ql, qr);
    if (qr > mid) res += querySum(rc[u], mid + 1, r, ql, qr);
    return res;
}
int queryKth(int u, int l, int r, ll k) {
    if (l == r) return l;
    if (k <= sum[lc[u]]) return queryKth(lc[u], l, mid, k);
    else return queryKth(rc[u], mid + 1, r, k - sum[lc[u]]);
}
void merge(int u, int v, int l, int r) {
    if (l == r) {
        sum[u] += sum[v];
        return;
    }
    if (lc[u] && lc[v]) merge(lc[u], lc[v], l, mid), remove(lc[v]);
    else if (lc[v]) lc[u] = lc[v], lc[v] = 0;
    if (rc[u] && rc[v]) merge(rc[u], rc[v], mid + 1, r), remove(rc[v]);
    else if (rc[v]) rc[u] = rc[v], rc[v] = 0;
    push_up(u);
}
void split(int &newp, int &u, int l, int r, int ql, int qr) {//分裂出[ql, qr]间的点
    if (!u) return;
    if (ql <= l && r <= qr) {
        newp = u;
        u = 0;
        return;
    }
    if (!newp) newp = newNode();
    if (ql <= mid) split(lc[newp], lc[u], l, mid, ql, qr);
    if (qr > mid) split(rc[newp], rc[u], mid + 1, r, ql, qr);
    push_up(u);
    push_up(newp);

}
#undef mid
\end{lstlisting}
\subsection{线段树维护LIS方案数}
\begin{lstlisting}
// 线段树维护序列总LIS的长度mx.fi和方案数mx.se
// 以及对于每个点，可以存在于多少个LIS种

// https://nanti.jisuanke.com/t/39611

namespace Tree_LIS {
    const int N = 1e6 + 10;

#define lc t[u].l
#define rc t[u].r
#define mid (l + r) / 2

    struct Tree {
        int l, r;
        ll len; // 长度
        ll sum; // 个数
    }t[N << 2];

    int root, cnt;
    void init() {
        mem(t, 0);
        cnt = root = 0;
    }

    void push_up(int u) {
        if(t[lc].len == t[rc].len) {
            t[u].len = t[lc].len;
            t[u].sum = (t[lc].sum + t[rc].sum) % mod;
        }
        else if(t[lc].len < t[rc].len) {
            t[u].len = t[rc].len;
            t[u].sum = t[rc].sum;
        }
        else {
            t[u].len = t[lc].len;
            t[u].sum = t[lc].sum;
        }
    }

    void modify(int &u, int l, int r, int p, int le, int su) {
        if(!u) u = ++cnt;
        if(l == r) {
            if(t[u].len == le) t[u].sum = (t[u].sum + su) % mod;
            else if(t[u].len < le) {
                t[u].len = le;
                t[u].sum = su;
            }
            return ;
        }
        if(!lc) lc = ++cnt;
        if(!rc) rc = ++cnt;
        if(p <= mid) modify(lc, l, mid, p, le, su);
        else modify(rc, mid + 1, r, p, le, su);
        push_up(u);
    }

    pll query(int u, int l, int r, int ql, int qr) {
        if(ql <= l && r  <= qr) return pll{t[u].len, t[u].sum};
        pll lson = {0, 0}, rson = {0, 0};
        if(!lc) lc = ++cnt;
        if(!rc) rc = ++cnt;
        if(ql <= mid) lson = query(lc, l, mid, ql, qr);
        if(qr  > mid) rson = query(rc, mid + 1, r, ql, qr);
        if(lson.fi == rson.fi) return pll{lson.fi, (lson.se + rson.se) % mod};
        else if(lson.fi < rson.fi) return rson;
        else return lson;
    }
};

using namespace Tree_LIS;

ll quick_pow(ll a, ll b) {
    ll ans = 1;
    while(b) {
        if(b & 1) ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans % mod;
}

void solve() {
    int n; cin >> n;
    int L = 0, R = 1e9 + 7;
    vector<int> a(n + 1);
    vector<pll> l(n + 1), r(n + 1);
    for(int i = 1;i <= n; i++) cin >> a[i];
    init();
    modify(root, L, R, a[1], 1, 1);
    l[1] = {1, 1};
    for(int i = 2;i <= n; i++) {
        pll temp = query(root, L, R, 0, a[i] - 1);
        if(temp.fi == 0) temp = {0, 1};
        modify(root, L, R, a[i], temp.fi + 1, temp.se);
        l[i] = {temp.fi + 1, temp.se};
    }
    pll mx = query(root, L, R, 0, R);
    init();
    modify(root, L, R, R - a[n], 1, 1);
    r[n] = {1, 1};
    for(int i = n - 1;i >= 1; i--) {
        pll temp = query(root, L, R, 0, R - a[i] - 1);
        if(temp.fi == 0) temp = {0, 1};
        modify(root, L, R, R - a[i], temp.fi + 1, temp.se);
        r[i] = {temp.fi + 1, temp.se};
    }
    for(int i = 1;i <= n; i++) {
        if(r[i].fi + l[i].fi - 1 == mx.fi) {
            cout << (r[i].se * l[i].se % mod * quick_pow(mx.se, mod - 2) % mod + mod) % mod << " ";
        }
        else cout << 0 << " ";
    }
    cout << endl;
}
\end{lstlisting}
\subsection{线段树维护最小字典序LIS}
\begin{lstlisting}
// 线段树维护LIS输出字典序最小的路径
const int N = 1e5 + 10;

#define lc u << 1
#define rc u << 1 | 1
#define mid (t[u].l + t[u].r) / 2

struct Tree {
    int l, r;
    int mx;
    int id;
}t[N << 2];

inline void push_up(int u) {
    if (t[lc].mx > t[rc].mx)
        t[u].mx = t[lc].mx, t[u].id = t[lc].id;
    else if (t[lc].mx < t[rc].mx)
        t[u].mx = t[rc].mx, t[u].id = t[rc].id;
    else
        t[u].mx = t[lc].mx, t[u].id = min(t[lc].id, t[rc].id);
}

void build(int u, int l, int r) {
    t[u].l = l;
    t[u].r = r;
    t[u].mx = t[u].id = 0;
    if (l == r)
        return;
    int m = (l + r) >> 1;
    build(lc, l, m);
    build(rc, m + 1, r);
    push_up(u);
}

void modify(int u, int ql, int qr, int val, int id) {
    if (ql <= t[u].l && t[u].r <= qr) {
        if (t[u].mx < val || (t[u].mx == val && t[u].id > id)) {
            t[u].mx = val;
            t[u].id = id;
        }
        return;
    }
    if (ql <= mid)
        modify(lc, ql, qr, val, id);
    if (qr > mid)
        modify(rc, ql, qr, val, id);
    push_up(u);
}

pii query(int u, int ql, int qr) {
    if (ql <= t[u].l && t[u].r <= qr)
        return pii{t[u].mx, t[u].id};
    pii lson = {-1, -1}, rson = {-1, -1};
    if (ql <= mid)
        lson = query(lc, ql, qr);
    if (qr > mid)
        rson = query(rc, ql, qr);
    if (lson.x > rson.x)
        return lson;
    else if (lson.x < rson.x)
        return rson;
    else
        return {lson.x, min(lson.y, rson.y)};
}

void solve() {
    int n;
    cin >> n;
    assert(1 <= n && n <= 1e5);
    build(1, 1, 1e5);
    vector<int> a(n + 1), ans(n + 1), fa(n + 1);
    pii res = {0, 0};
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        assert(1 <= a[i] && a[i] <= 1e5);
        if (a[i] == 1) {
            fa[i] = 0;
            ans[i] = 1;
            modify(1, a[i], a[i], 1, i);
            continue;
        }
        pii temp = query(1, 1, a[i] - 1);
        ans[i] = temp.x + 1;
        fa[i] = temp.y;
        modify(1, a[i], a[i], ans[i], i);
        if (res.x < ans[i])
            res = pii{ans[i], i};
    }
    vector<int> v;
    int tt = res.second;
    while (tt) {
        v.push_back(tt);
        tt = fa[tt];
    }
    cout << v.size() << endl;
    for (int i = v.size() - 1; i >= 0; i--) {
        cout << v[i] << (i == 0 ? endl : " ");
    }
}


// 线段树维护LIS方案数
\end{lstlisting}
\subsection{线段树维护插队问题}
\begin{lstlisting}
// n个人，每个人a_i要顺序坐在pos_i，问最终的序列如何
// 最后一个人一定坐在自己喜欢坐的位置，去掉该位置，倒数第二个人成为最后一个人，所以就是查找空位置的第pos位置

const int N = 4e5 + 10;

#define lc u << 1
#define rc u << 1 | 1
#define mid (l + r) / 2
int sum[N << 2], ans[N];

void push_up(int u) {
    sum[u] = sum[lc] + sum[rc];
}

void build(int u, int l, int r) {
    if(l == r) {
        sum[u] = 1;
        ans[l] = 0;
        return ;
    }
    build(lc, l, mid);
    build(rc, mid + 1, r);
    push_up(u);
}

void modify(int u, int l, int r, int k, int val) {
    if(l == r) {
        ans[l] = val;
        sum[u] = 0;
        return ;
    }
    if(sum[lc] >= k) modify(lc, l, mid, k, val);
    else modify(rc, mid + 1, r, k - sum[lc], val);
    push_up(u);
}

void solve() {
    int n;
    while(~scanf("%d", &n)) {
        vector<pii> p(n + 1);
        for(int i = 1;i <= n; i++) {
            scanf("%d%d",&p[i].fi, &p[i].se);
        }
        build(1, 1, n);
        for(int i = n;i >= 1; i--) {
            modify(1, 1, n, p[i].fi + 1, p[i].se);
        }
        for(int i = 1;i <= n; i++) {
            printf("%d ", ans[i]);
        }
        printf("\n");
    }
}
\end{lstlisting}
\subsection{线段树维护连续区间异或值}
\begin{lstlisting}
// 当[l,r]^x时，很不幸异或出来的结果不一定连续，而是分成多个连续区间，所以需要用线段树来构造一个区间异或x之后还是连续区间

// [0, 7]可以分成[0, 3]和[4, 7]，这样区间异或x还是连续区间

// 主要操作：

/*
把低pos位全为0
int ql = (l ^ val) & (((1 << 30) - 1) ^ (1 << pos) - 1);
int qr = ql + (1 << pos) - 1;
把低pos位全为1

高pos不管
*/

vector<pii> g[N], len;
int l[N], r[N];

void modify(int pos, int l, int r, int L, int R, int val) {
    if(L <= l && r <= R) {
        // 把低pos设置为0
        int ql = (l ^ val) & (((1 << 30) - 1) ^ (1 << pos) - 1);
        int qr = ql + (1 << pos) - 1;
        len.push_back(pii{ql, qr});
        return ;
    }
    int mid = (l + r) / 2;
    if(L <= mid) modify(pos - 1, l, mid, L, R, val);
    if(R  > mid) modify(pos - 1, mid + 1, r, L, R, val);
}

void dfs(int u, int fa, int w) {
    modify(30, 0, (1 << 30) - 1, l[u], r[u], w);
    for(auto e : g[u]) {
        if(e.fi == fa) continue ;
        dfs(e.fi, u, e.se ^ w);
    }
}
\end{lstlisting}
\subsection{线段树维护区间异或}
\begin{lstlisting}
const int N = 2e5 + 10;

#define lc u << 1
#define rc u << 1 | 1

struct Tree {
    int sum, tag;
}t[21][N << 2];
int a[N];

void push_up(int id, int u) {
    t[id][u].sum = t[id][lc].sum + t[id][rc].sum;
}

void push_down(int id, int u, int l, int r) {
    if(!t[id][u].tag) return ;
    int m = (l + r) / 2;
    t[id][lc].sum = (m - l + 1) - t[id][lc].sum;
    t[id][rc].sum = (r - m) - t[id][rc].sum;
    t[id][lc].tag ^= 1;
    t[id][rc].tag ^= 1;
    t[id][u].tag = 0;
}

void build(int id, int u, int l, int r) {
    if(l == r) {
        t[id][u].sum = (a[l] >> id) & 1;
        t[id][u].tag = 0;
        return ;
    }
    int m = (l + r) / 2;
    build(id, lc, l, m);
    build(id, rc, m + 1, r);
    push_up(id, u);
}

void modify(int id, int u, int l, int r, int ql, int qr) {
    if(ql <= l && r <= qr) {
        t[id][u].sum = (r - l + 1) - t[id][u].sum;
        t[id][u].tag ^= 1;
        return ;
    }
    push_down(id, u, l, r);
    int m = (l + r) / 2;
    if(ql <= m) modify(id, lc, l, m, ql, qr);
    if(qr  > m) modify(id, rc, m + 1, r, ql, qr);
    push_up(id, u);
}

int query(int id, int u, int l, int r, int ql, int qr) {
    if(ql <= l && r <= qr) return t[id][u].sum;
    push_down(id, u, l, r);
    int ans = 0;
    int m = (l + r) / 2;
    if(ql <= m) ans += query(id, lc, l, m, ql, qr);
    if(qr  > m) ans += query(id, rc, m + 1, r, ql, qr);
    return ans;
}

void solve() {
    int n, m; cin >> n >> m;
    for(int i = 1;i <= n; i++) cin >> a[i];
    for(int i = 0;i <= 20; i++) {
        build(i, 1, 1, n);
    }
    while(m--) {
        int opt; cin >> opt;
        if(opt == 1) {
            int l, r; cin >> l >> r;
            ll ans = 0;
            for(int i = 0;i <= 20; i++) {
                ans += query(i, 1, 1, n, l, r) * (1ll << i);
            }
            cout << ans << endl;
        }
        else {
            int l, r, k; cin >> l >> r >> k;
            for(int i = 0;i <= 20; i++) {
                if((k >> i) & 1) modify(i, 1, 1, n, l, r);
            }
        }
    }
}
\end{lstlisting}
\subsection{树状数组维护逆序对}
\begin{lstlisting}
BITree t;
int n;
pii a[N];

void solve() {
    t.init(n);
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        a[i] = make_pair(x, i);
    }
    sort(a + 1, a + n + 1);
    ll ans = 0;
    for (int i = 1; i <= n; i++) {
        t.change(a[i].second, 1);
        ans += (i - t.query(a[i].second));
    }
    cout << ans << endl;
}


\end{lstlisting}
\subsection{ST}
\begin{lstlisting}
// 倍增思想加DP优化

#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

int a[N];
int dp[N][105];

// 一维ST表
void One_ST(){
    int n;
    cin >> n;
    for(int i = 1;i <= n; i++) {
        cin >> a[i];
        dp[i][0] = a[i];

        // cin >> dp[i][0];
    }

    for(int j = 1;j <= log2(n); j++) {
        for(int i = 1;i <= n; i++) {
            if(i + (1 << (j - 1)) <= n)
                dp[i][j] = max(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);
        }
    }

    int T;
    cin >> T;
    while(T--) {
        int l, r;
        cin >> l >> r;
        int len = log2(r - l + 1);
        int k = max(dp[l][len], dp[r - (1 << len) + 1][len]);
        cout << k << endl;
    }
}

// 二维ST表
int f[105][105][105];

void Two_ST() {
    int n, m;
    cin >> n >> m;
    for(int i = 1;i <= n; i++)
        for(int j = 1;j <= m; j++){
            cin >> a[i];
            f[i][j][0] = a[i];
        }

// 大矩阵分成四个小矩阵求最值

    for(int k = 1;k < log2(n); k++) {
        for(int i = 1;i <= n; i++) {
            for(int j = 1;j <= m; j++) {
                if((i + (1 << (k - 1)) <= n) && (j + (1 << (k - 1)) <= m))
                    f[i][j][k] = max(max(f[i][j + (1 << (k - 1))][k - 1], f[i + (1 << (k - 1))][j][k - 1]), max(f[i][j][k - 1], f[i + (1 << (k - 1))][j + (1 << (k - 1))][k - 1]));
        }
    }

    int T;
    cin >> T;
    while(T--) {
        int l, r, k;
        cin >> l >> r >> k; 
        int len = log2(k); 
        int s = max(max(f[l][r][len], f[l + k - (1 << len)][r + k - (1 << len)][len]), max(f[l + k - (1 << len)][r][len], f[l][r + k - (1 << len)][len]));
    }

}\end{lstlisting}
\subsection{笛卡尔树}
\begin{lstlisting}
// 笛卡尔树是一种由数列构造的特殊二叉搜索树，每个节点都有两个键值，first为下标，second为权值
// 笛卡尔树满足两个性质，在下标递增的情况下就是一个大/小根堆

// 笛卡尔树，静态建树，区间最值跳转
struct CartesianTree {
    int rt; // 根节点
    pii ch[N]; // 左右儿子
    int st[N]; // 单调栈

    void build(int n, int p[]) {
        rt = 0;
        int t = 0;
        for (int i = 1; i <= n; i++) {
            ch[i] = {0, 0};
            // 决定了大于还是小于
            while (t && p[st[t]] > p[i]) --t;
            if (t) { 
                // 上一个点的右儿子作为自己的左儿子
				// 成为上一个点的右儿子
                ch[i].first = ch[st[t]].second;
                ch[st[t]].second = i;
            } else { // 自己作为根节点
                ch[i].first = rt;
                rt = i;
            }
            st[++t] = i;
        }
    }
} dika;\end{lstlisting}
\subsection{DancingLinks}
\begin{lstlisting}
// Dancing Links
struct DLX {
    int n, m, size;
    int U[MaxNode], D[MaxNode], L[MaxNode], R[MaxNode], Row[MaxNode], Col[MaxNode];
    int H[MaxN], S[MaxM];
    int ansd, ans[MaxN];

    void init(int _n, int _m) {
        n = _n;
        m = _m;
        for (int i = 0; i <= m; i++) {
            S[i] = 0;
            U[i] = D[i] = i;
            L[i] = i - 1;
            R[i] = i + 1;
        }
        R[m] = 0;
        L[0] = m;
        size = m;
        for (int i = 0; i <= n; i++) {
            H[i] = -1;
        }
    }

    void Link(int r, int c) {
        ++S[Col[++size] = c];
        Row[size] = r;
        D[size] = D[c];
        U[D[c]] = size;
        U[size] = c;
        D[c] = size;
        if (H[r] < 0) {
            H[r] = L[size] = R[size] = size;
        } else {
            R[size] = R[H[r]];
            L[R[H[r]]] = size;
            L[size] = H[r];
            R[H[r]] = size;
        }
    }

    void remove(int c) {
        L[R[c]] = L[c];
        R[L[c]] = R[c];
        for (int i = D[c]; i != c; i = D[i]) {
            for (int j = R[i]; j != i; j = R[j]) {
                U[D[j]] = U[j];
                D[U[j]] = D[j];
                --S[Col[j]];
            }
        }
    };

    void resume(int c) {
        for (int i = U[c]; i != c; i = U[i])
            for (int j = L[i]; j != i; j = L[j])
                ++S[Col[U[D[j]] = D[U[j]] = j]];
        L[R[c]] = R[L[c]] = c;
    }

    bool Dance(int d) {
        if (R[0] == 0) {
            for (int i = 0; i < d; i++) {
                printf("%d%c", ans[i], " \n"[i == d - 1]);
            }
            return true;
        }
        int c = R[0];
        for (int i = R[0]; i != 0; i = R[i]) if (S[i] < S[c]) c = i;
        remove(c);
        for (int i = D[c]; i != c; i = D[i]) {
            ans[d] = Row[i];
            for (int j = R[i]; j != i; j = R[j])remove(Col[j]);
            if (Dance(d + 1))return true;
            for (int j = L[i]; j != i; j = L[j])resume(Col[j]);
        }
        resume(c);
        return false;
    }
};\end{lstlisting}
\subsection{珂朵莉树}
\begin{lstlisting}
// 要先Split右端点(r+1)，在Split左端点(l)

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

struct node {
    int l, r;
    mutable ll v;
    node (int L, int R = -1, ll V = 0) : l(L), r(R), v(V) {}
    bool operator < (const node &rhs) const {
        return l < rhs.l;
    }
};

set<node> s;

auto Split(int pos) {
    auto it = s.lower_bound(node(pos));
    if(it != s.end() && it -> l == pos) return it;
    --it;
    int L = it -> l, R  = it -> r;
    ll V = it -> v;
    s.erase(it);
    s.insert(node(L, pos - 1, V));
    return s.insert(node(pos, R, V)).first;
}

void assign_val(int l, int r, ll val) { // 推平操作
    auto itr = Split(r + 1);
    auto itl = Split(l);
    s.erase(itl, itr);
    s.insert(node(l, r, val));
}

void add(int l, int r, ll val) { // 区间加
    auto itr = Split(r + 1);
    auto itl = Split(l);
    for( ;itl != itr; ++itl) {
        itl -> v += val;
    }
}

ll kth(int l, int r, int k) { // 区间第k小
    vector<pair<ll, int> > v;
    auto itr = Split(r + 1);
    auto itl = Split(l);
    for( ;itl != itr; ++itl) {
        v.push_back(pair<ll, int>{itl -> v, itl -> r - itl -> l + 1});
    }
    sort(v.begin(), v.end());
    for(auto it = v.begin();it != v.end(); ++it) {
        k -= it -> second;
        if(k <= 0) return it -> first;
    }
}

ll quick_pow(ll a, ll b, ll p) ;

ll qpow(int l, int r, int ex, int p) {
    auto itr = Split(r + 1);
    auto itl = Split(l);
    ll ans = 0;
    for( ;itl != itr; ++itl)
        ans = (ans + ll(itl -> r - itl -> l + 1) * quick_pow(itl -> v, ll(ex), ll(p)) % ll(p)) % ll(p);
    return ans % ll(p);
}
int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i){
        ll x;
        cin >> x;
        s.insert(node(i,i,x));
    }
    s.insert(node(n + 1, n + 1, 0));
    while(m--) {
        int opt, l, r, x;
        cin >> opt >> l >> r >> x;
        if(opt == 1) add(l, r, x);
        else if(opt == 2) assign_val(l, r, x);
        else if(opt == 3) cout << kth(l, r, x)  << endl;
        else {
            int y;
            cin >> y;
            cout << qpow(l, r, x, y) << endl;
        }
    }
}\end{lstlisting}
\subsection{单调队列}
\begin{lstlisting}
const int N = 2e5 + 10;
int f[N], que[N], tail, head;

void solve() {
    int n, k; cin >> n >> k;
    vector<int> a(n + 1);
    for(int i = 1;i <= n; i++) cin >> a[i];
    // 维护最小值
    tail = 1; head = 0;
    for(int i = 1;i <= n; i++) {
        while(tail >= head && f[tail] >= a[i]) tail--;
        que[++tail] = i;
        f[tail] = a[i];
        while(que[head] + k <= i) head++;
        if(i >= k) cout << f[head] << " ";
    }
    cout << endl;
    
    // 维护最大值
    tail = 1; head = 0;
    for(int i = 1;i <= n; i++) {
        while(tail >= head && f[tail] <= a[i]) tail--;
        que[++tail] = i;
        f[tail] = a[i];
        while(que[head] + k <= i) head++;
        if(i >= k) cout << f[head] << " ";
    }
    cout << endl;
}\end{lstlisting}
\subsection{单调栈}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

struct Monotone_stack {
    static const int N = 1e5 + 10;
    int a[N];
    stack<int> s;
    int n;
    
    void read() {
        cin >> n;
        for(int i = 1;i <= n; i++) cin >> a[i];
    }

    void Monotone_min() {
        for(int i = 1;i <= n; i++) {
            if(s.empty() || s.top() >= a[i])
                s.push(a[i]);
            else {
                while(!s.empty() && s.top() < a[i]) {
                    cout << s.top() << endl;
                    s.pop();
                }
                s.push(a[i]);
            }
        }
        while(!s.empty()) { 
            cout << s.top() << endl;
            s.pop();
        }
    }

    void Monotone_max() {
        for(int i = 1;i <= n; i++) {
            if(s.empty() || s.top() <= a[i])
                s.push(a[i]);
            else {
                while(!s.empty() && s.top() > a[i]) {
                    cout << s.top() << endl;
                    s.pop();
                }
                s.push(a[i]);
            }
        }
        while(!s.empty()) {
            cout << s.top() << endl;
            s.pop();
        }
    }

}Worker;
\end{lstlisting}
\subsection{差分}
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;

/*------------------一维差分--------------------*/

//可以区间修改，更改的值必须一样
int f[1005]; // 原始数组
int d[1005]; // 差分数组，原始数组的相邻元素之间的差值

int n;

void init() {
    for(int i = 1;i <= n; i++) {
        d[i] = f[i] - f[i - 1];
    }
}

void update(int l, int r, int k) {
    d[l] += k;
    d[r + 1] -= k;
}

void merge() {
    for(int i = 1;i <= n; i++) {
        d[i] = d[i] + d[i - 1];
    }
}

/*---------------二维差分------------------*/
const int N = 1005;

int mp[N][N];
int p[N][N];
int n, m;

void init() {

    for(int i = 1;i <= n; i++) {
        for(int j = 1;j <= m; j++) {
            p[i][j] = mp[i][j] - mp[i - 1][j] - mp[i][j - 1] + mp[i - 1][j - 1];
        }
    }
}

void update(int x1, int y1, int x2, int y2, int k) {
    p[x1][y1] += k;
    p[x1][y2 + 1] -= k;
    p[x2 + 1][y1] -= k;
    p[x2 + 1][y2 + 1] += k;
}

void merge() {

    for(int i = 1;i <= n; i++) {
        for(int j = 1;j <= m; j++) {
            p[i][j] = p[i][j] + p[i - 1][j] + p[i][j - 1] - p[i - 1][j - 1];
        }
    }
}

// 求区间交
// len存的是各线段长度
int Interval_crossing() {
    vector<pii> res;
    for(auto item : len) {
        res.push_back(pii{item.fi, 1});
        res.push_back(pii{item.se + 1, -1});
    }
    sort(res.begin(), res.end());
    int tag = 0, lst = 0, ans = 0;
    for(auto i : res) {
        if(tag == n) ans += i.fi - lst;
        tag += i.se;
        lst = i.fi;
    }
    return ans;    
}\end{lstlisting}
\subsection{trie}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;

int cnt[N], idx;
int trie[N][26];

void insert(string s) {
    int len = s.length();
    int root = 0;
    for(int i = 0;i < len; i++) {
        int v = s[i] - 'a';
        if(!trie[root][v]) trie[root][v] =++idx;
        root = trie[root][v];
    }
    cnt[root]++;
}

int query(string s) {
    int ans = 0;
    int len = s.length();
    int root = 0;
    for(int i = 0;i < len; i++) {
        int v = s[i] - 'a';
        if(!trie[root][v]) break;
        root = trie[root][v];
        ans += cnt[root];
    }
    return ans;
}

void solve()
{
    int n, m;
    scanf("%d%d",&n,&m);
    for(int i = 1;i <= n; i++) {
        char s[N];
        scanf("%s",s);
        insert(s);
    }
    while(m--) {
        char s[N];
        scanf("%s",s);
        printf("%d\n",query(s));
    }
}\end{lstlisting}
\subsection{HashTable}
\begin{lstlisting}
struct HashTable {
    static const int MOD = 1e7 + 10;
    struct edge {
        int nxt;
        ll num, val;
    } e[MOD];
    int head[MOD], tot;
    void clear() { tot = 0; memset(head, 0, sizeof(head)); }
    void insert(ll u, ll w) { e[++tot] = edge{head[u % MOD], u, w }, head[u % MOD] = tot; }
    int find(ll u) {
        for (int i = head[u % MOD]; i; i = e[i].nxt)
            if (e[i].num == u) return e[i].val;
        return -1;
    }
} hs;\end{lstlisting}
\subsection{2-4维前缀和}
\begin{lstlisting}
// 统计(a,b)到(c,d)这个矩阵中的所有0子矩阵

const int N = 50 + 10;
int sum[N][N];
int Q[N][N][N][N];

void solve() {
    int n, m, q; cin >> n >> m >> q;
    for(int i = 1;i <= n; i++) {
        string s; cin >> s;
        for(int j = 1;j <= m; j++) {
            sum[i][j] = (s[j - 1] - '0') + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
        }
    }

    for(int a = 1;a <= n; a++) {
        for(int b = 1;b <= m; b++) {
            for(int c = a;c <= n; c++) {
                for(int d = b;d <= m; d++) {
                    if(sum[c][d] - sum[a - 1][d] - sum[c][b - 1] + sum[a - 1][b - 1] == 0) {
                        Q[a][b][c][d]++;
                    }
                }
            }
        }
    }

    for(int a = n;a >= 1; a--) {
        for(int b = m;b >= 1; b--) {
            for(int c = 1;c <= n; c++) {
                for(int d = 1;d <= m; d++) {
                    Q[a][b][c][d] += Q[a + 1][b][c][d];
                }
            }
        }
    }

    for(int a = n;a >= 1; a--) {
        for(int b = m;b >= 1; b--) {
            for(int c = 1;c <= n; c++) {
                for(int d = 1;d <= m; d++) {
                    Q[a][b][c][d] += Q[a][b + 1][c][d];
                }
            }
        }
    }

    for(int a = n;a >= 1; a--) {
        for(int b = m;b >= 1; b--) {
            for(int c = 1;c <= n; c++) {
                for(int d = 1;d <= m; d++) {
                    Q[a][b][c][d] += Q[a][b][c - 1][d];
                }
            }
        }
    }

    for(int a = n;a >= 1; a--) {
        for(int b = m;b >= 1; b--) {
            for(int c = 1;c <= n; c++) {
                for(int d = 1;d <= m; d++) {
                    Q[a][b][c][d] += Q[a][b][c][d - 1];
                }
            }
        }
    }

    while(q--) {
        int a, b, c, d; cin >> a >> b >> c >> d;
        cout << Q[a][b][c][d] << endl;
    }
}
\end{lstlisting}
\subsection{普通并查集}
\begin{lstlisting}
const int N = 1e5 + 10;

int f[N], dep[N];

inline int find(int x) {
    return f[x] == x ? x : f[x] = find(f[x]);
}

inline void merge(int x, int y) {
    int u = find(x);
    int v = find(y);
    if(u == v) return ;
    else {
        if(dep[u] <= dep[v]) { f[u] = v; dep[v] = max(dep[v], dep[u] + 1); }
        else { f[v] = u; dep[u] = max(dep[u], dep[v] + 1); }
    }
}\end{lstlisting}
\subsection{带权并查集}
\begin{lstlisting}
// 根据题目时候并成链还是树
const int N = 1e5 + 10;
int d[N], f[N];

int find(int x) {
    if(f[x] != x) {
        int fa = f[x];
        f[x] = find(f[x]);
        d[x] += d[fa];
    }
    return f[x];
}

void merge(int x, int y, int v) { // 两个点和权值
    int px = find(x);
    int py = find(y);
    if(px == py) return ;
    else {
        f[px] = py;
        d[px] = d[y] + v - d[x];
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    for(int i = 1;i <= n; i++) f[i] = i;
    while(m--) {
        int x, y, v;
        cin >> x >> y >> v;
        merge(x, y, v);
    }
}
\end{lstlisting}
\subsection{可撤销并查集}
\begin{lstlisting}
struct node {
    int x, y, z;
};

struct UnionFind {
private:
    int rk[N], pre[N], siz[N], totNode;//N为最大点数
    stack<node> st;//node记录上次修改的内容
public:
    void init(int tot) {
        totNode = tot;
        for (int i = 1; i <= totNode; i++)
            pre[i] = i, siz[i] = rk[i] = 1;
    }
    int find(int x) { while (x ^ pre[x]) x = pre[x]; return x; }
    void merge(int x, int y) {//按秩合并
        x = find(x), y = find(y);
        if (x == y) return;
        if (rk[x] < rk[y]) swap(x, y);
        st.push(node{ y, rk[x], siz[y] });
        pre[y] = x, rk[x] += rk[x] == rk[y], siz[x] += siz[y];
    }
    int start() { return st.size(); }
    void end(int last) {//撤回merge操作
        while (st.size() > last) {
            node tp = st.top();
            rk[pre[tp.x]] -= tp.y, siz[pre[tp.x]] -= tp.z;
            pre[tp.x] = tp.x;
            st.pop();
        }
    }
    bool judge() { return siz[find(1)] == totNode; }
} uf;
\end{lstlisting}
\subsection{种类并查集}
\begin{lstlisting}
// 根据题目要求，若是集合中有n个关系，那需要开n倍的并查集大小

const int N = 1e5 + 10;
int f[N * 2], dep[N * 2];

int find(int x) { return f[x] == x ? x : (f[x] = find(f[x])); }

void merge(int x, int y) {
    x = find(x);
    y = find(y);
    if(x == y) return ;
    if(dep[x] <= dep[y]) {
        f[x] = y; dep[y] = max(dep[x] + 1, dep[y]);
    }
    else { 
        f[y] = x; dep[x] = max(dep[y] + 1, dep[x]);
    }
}

int main() {
    int n, q;
    cin >> n >> q;
    for(int i = 1;i <= 2 * n; i++) f[i] = i;// **

    while(q--) {
        int flag, x, y;
        cin >> flag >> x >> y;
        if(flag) { // 敌人
            merge(x + n, y);
            merge(y + n, x);
        }
        else {
            merge(x, y); // 同伴
        }
    }    
    int ans = 0;
    for(int i = 1;i <= n; i++) {
        if(f[i] == i) ans ++;
    }
    cout << ans << endl;
}
\end{lstlisting}
\subsection{KD求矩阵权值和}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int MAX = 200005;
const double alpha = 0.75;
//查包含在x1,y1,x2,y2为左下角和右上角的矩形里面权值之和
//K-D Tree 二维划分树
int n, ans, rt, WD, tot, top, rub[MAX];

struct node {
    int x[2], w;
} p[MAX];

struct K_D_tree {
    int ls, rs, siz, mn[2], mx[2], sum;
    //mn[0], mx[0] -> x的取值范围
    //mn[1], mx[1] -> y的取值范围
    node tmp;
} t[MAX];

int operator < (const node &a, const node &b) { return a.x[WD] < b.x[WD]; }

int newnode() {
    if (top) return rub[top--];
    else return ++tot;
}

void push_up(int u) {
    for (int i = 0; i <= 1; i++) {//更新x, y的取值范围
        t[u].mn[i] = t[u].mx[i] = t[u].tmp.x[i];
        if (t[u].ls) {//左子树的最大最小值
            t[u].mn[i] = min(t[u].mn[i], t[t[u].ls].mn[i]);
            t[u].mx[i] = max(t[u].mx[i], t[t[u].ls].mx[i]);
        }
        if (t[u].rs) {//右子树的最大最小值
            t[u].mn[i] = min(t[u].mn[i], t[t[u].rs].mn[i]);
            t[u].mx[i] = max(t[u].mx[i], t[t[u].rs].mx[i]);
        }
    }
    t[u].sum = t[t[u].ls].sum + t[t[u].rs].sum + t[u].tmp.w;
    t[u].siz = t[t[u].ls].siz + t[t[u].rs].siz + 1;
}

int build(int l, int r, int wd) {
    if (l > r) return 0;
    int u = newnode();
    int m = (l + r) >> 1;
    WD = wd; nth_element(p + l, p + m, p + r + 1);
    t[u].tmp = p[m];
    t[u].ls = build(l, m - 1, wd ^ 1);
    t[u].rs = build(m + 1, r, wd ^ 1);
    push_up(u);
    return u;
}

void pia(int u, int num) {//拍扁回炉重做
    if (t[u].ls) pia(t[u].ls, num);
    p[t[t[u].ls].siz + num + 1] = t[u].tmp, rub[++top] = u;
    if (t[u].rs) pia(t[u].rs, t[t[u].ls].siz + num + 1);
}

void check(int &u, int wd) {//检查是否平衡，不平衡则需要重建
    if (t[u].siz * alpha < t[t[u].ls].siz || t[u].siz * alpha < t[t[u].rs].siz) pia(u, 0), u = build(1, t[u].siz, wd);
}

void insert(int &u, node tp, int wd) {//插入点
    if (!u) {
        u = newnode();
        t[u].ls = t[u].rs = 0, t[u].tmp = tp;
        push_up(u);
        return;
    }
    if (tp.x[wd] <= t[u].tmp.x[wd]) insert(t[u].ls, tp, wd ^ 1);
    else insert(t[u].rs, tp, wd ^ 1);
    push_up(u);
    check(u, wd);
}

bool in(int x1, int y1, int x2, int y2, int X1, int Y1, int X2, int Y2) {//完全被包含
    return (x1 <= X1 && X2 <= x2 && y1 <= Y1 && Y2 <= y2);
}

bool out(int x1, int y1, int x2, int y2, int X1, int Y1, int X2, int Y2) {//完全无交集
    return (x1 > X2 || x2 < X1 || y1 > Y2 || y2 < Y1);
}

int query(int u, int x1, int y1, int x2, int y2) {
    if (!u) return 0;
    int res = 0;
    if (in(x1, y1, x2, y2, t[u].mn[0], t[u].mn[1], t[u].mx[0], t[u].mx[1])) return t[u].sum;
    if (out(x1, y1, x2, y2, t[u].mn[0], t[u].mn[1], t[u].mx[0], t[u].mx[1])) return 0;
    if (in(x1, y1, x2, y2, t[u].tmp.x[0], t[u].tmp.x[1], t[u].tmp.x[0], t[u].tmp.x[1])) res += t[u].tmp.w;
    res += query(t[u].ls, x1, y1, x2, y2) + query(t[u].rs, x1, y1, x2, y2);
    return res;
}

void init() {
    ans = rt = top = tot = 0;
}


void solve() {
    scanf("%d", &n);
    while(1) {
        int opt; scanf("%d",&opt);
        if(opt == 1) {
            int x, y, w; scanf("%d%d%d",&x,&y,&w);
            insert(rt, node{x ^ ans, y ^ ans, w ^ ans}, 0);
        }
        else if(opt == 2) {
            int x1, y1, x2, y2; scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
            ans = query(rt, x1 ^ ans, y1 ^ ans, x2 ^ ans, y2 ^ ans);
            printf("%d\n",ans);
        }
        else break;
    }
}\end{lstlisting}
\subsection{KD求最近点对距离}
\begin{lstlisting}
// 二维平面里最近点对距离
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 1e5 + 10;
struct node {
    ll x[2];
}a[N], b[N];

int now, n;
ll ans;
map<pair<ll, ll>, int> mp;

bool cmp(node a, node b) { return a.x[now] < b.x[now]; }

ll sqr(int x) { return (ll)x * x; }
ll dis(node a, node b) { return sqr(a.x[0] - b.x[0]) + sqr(a.x[1] - b.x[1]); }

void build(int l, int r, int d) {
    if(l >= r) return ;
    int m = (l + r) >> 1;
    now = d;
    nth_element(a + l, a + m, a + r, cmp);
    build(l, m, d ^ 1);
    build(m + 1, r, d ^ 1);
}

void query(int l, int r, int d, node p) {
    if(l >= r) return ;
    int m = (l + r) >> 1;
    int ql = l, qr = m;
    ll res = dis(a[m], p);
    if(ans == 0 || res && ans > res) ans = res;
    if(p.x[d] > a[m].x[d]) ql = m + 1, qr = r;
    query(ql, qr, d ^ 1, p);
    if(ans > sqr(a[m].x[d] - p.x[d]))
        query(l + m - ql + 1, m + r - qr, d ^ 1, p);
}

void solve() {
    scanf("%d",&n);
    ll sum = 5e18;
    for(int i = 0;i < n; i++) {
        scanf("%lld %lld",&a[i].x[0],&a[i].x[1]);
        if(mp[{a[i].x[0], a[i].x[1]}]) sum = 0;
        else mp[{a[i].x[0], a[i].x[1]}]++;
        b[i] = a[i];
    }
    build(0, n, 0);
    for(int i = 0;i < n; i++) {
        ans = 0;
        query(0, n, 0, b[i]);
        sum = min(ans, sum);
    }
    printf("%.4lf\n",sqrt(1.0 * sum));
}

\end{lstlisting}
\subsection{CDQ分治}
\begin{lstlisting}
// 原问题：“任意两个元素之间的贡献”

// 降维成的子问题：“左段元素对右段每一个元素的贡献”

// 分而治之，最基础的应用为归并排序
// 将一个区间分成两个区间[l,mid]和[mid+1,r]，然后排序使其有序
// 注意事项：
// 1、离散化
// 2、如果有多个点的参量完全相同，由于顺着添加，查出来的最后一个答案才是正确的
// 对于y排序，我们可以直接对两段区间Sort，然而归并排序本身就是分治，我们可以在CDQ的过程中进行归并排序，要比Sort少一个log

// 千万不要忘记离散化！！！！！！！！！！！！！！！！！！\end{lstlisting}
\subsection{cdq处理逆序数}
\begin{lstlisting}
const int N = 1e5 + 10;
int ans[N], cnt[N];

struct star {
    int x, y, id;
}a[N], tmp[N];

bool cmp(star a, star b) {
    if(a.y == b.y) return a.x < b.x;
    return a.y < b.y;
}

void cdq(int l, int r) {
    if(l == r) return ;
    int m = (l + r) / 2;
    cdq(l, m);
    cdq(m + 1, r);
    int p = l, q = m + 1;
    for(int i = l;i <= r; i++) {
        if((p <= m && a[p].x <= a[q].x) || q > r) {
            tmp[i] = a[p++];
        }
        else {
            ans[a[q].id] += p - l;
            tmp[i] = a[q++];
        }
    }
    for(int i = l;i <= r; i++) a[i] = tmp[i];
}

void solve() {
    int n; cin >> n;
    for(int i = 1;i <= n; i++) cin >> a[i].x >> a[i].y, a[i].id = i;
    sort(a + 1, a + n + 1, cmp);
    cdq(1, n);
    for(int i = 1;i <= n; i++) cnt[ans[i]]++;
    for(int i = 0;i < n; i++) cout << cnt[i] << endl;
}
\end{lstlisting}
\subsection{cdq处理二维偏序}
\begin{lstlisting}

const int N = 1e5 + 10;
int ans[N], cnt[N];

struct star {
    int x, y, id;
}a[N], tmp[N];

bool cmp(star a, star b) {
    if(a.x == b.x) return a.y < b.y;
    return a.x < b.x;
}

void cdq(int l, int r) {
    if(l == r) return ;
    int m = (l + r) / 2;
    cdq(l, m);
    cdq(m + 1, r);
    int p = l, q = m + 1;
    for(int i = l;i <= r; i++) {
        if((p <= m && a[p].x <= a[q].x) || q > r) {
            tmp[i] = a[p++]; 
        }
        else {
            ans[a[q].id] += i - l;
            tmp[i] = a[q++];
        }
    }
    for(int i = l;i <= r; i++) a[i] = tmp[i];
}

void solve() {
    int n; cin >> n;
    for(int i = 1;i <= n; i++) cin >> a[i].x >> a[i].y;
    sort(a + 1, a + n + 1, cmp);
    cdq(1, n);
    for(int i = 1;i <= n; i++) cnt[ans[i]]++;
    for(int i = 0;i < n; i++) cout << cnt[i] << endl;
}\end{lstlisting}
\subsection{cdq套cdq处理三维偏序}
\begin{lstlisting}
// 一维排序、二维cdq、三维树状数组

const int N = 1e5 + 10;
struct node {
    int x, y, z;
    int id;
    int tag;
    bool operator < (const node &a)const{
        if(x != a.x) return x < a.x;
        if(y != a.y) return y < a.y;
        return z < a.z;
    }
    bool operator == (const node &a)const{
        return x == a.x && y == a.y && z == a.z;
    }
}a[N], b[N], tmp[N];

int ans[N];
int n;

void cdq2(int l, int r) {
    if(l == r) return ;
    int mid = (l + r) / 2;
    cdq2(l, mid); cdq2(mid + 1, r);
    int p = l, q = mid + 1, cnt = 0;
    for(int i = l;i <= r; i++) {
        if(q > r || (p <= mid && b[p].z <= b[q].z)) {
            if(b[p].tag == 0) cnt++;
            tmp[i] = b[p++];
        }
        else {
            if(b[q].tag == 1) ans[b[q].id] += cnt;
            tmp[i] = b[q++];
        }
    }
    for(int i = l;i <= r; i++) b[i] = tmp[i];
}

void cdq1(int l, int r) {
    if(l == r) return ;
    int mid = (l + r) / 2;
    cdq1(l, mid); cdq1(mid + 1, r);
    int p = l, q = mid + 1;
    /* 因为是计算左端元素对右端元素的影响，所以需要打个标记tag来记录他是左端还是右端元素 */
    for(int i = l;i <= r; i++) {
        if(q > r || (p <= mid && a[p].y <= a[q].y)) {
            a[p].tag = 0;
            b[i] = a[p++];
        }
        else {
            a[q].tag = 1;
            b[i] = a[q++];
        }
    }
    for(int i = l;i <= r; i++) a[i] = b[i];
    cdq2(l, r);
}

void solve() {
    n = read();
    for(int i = 1;i <= n; i++) {
        a[i].x = read(), a[i].y = read(), a[i].z = read();
        a[i].id = i;
    }
    sort(a + 1, a + n + 1);
    for(int i = n - 1;i >= 1; i--) {
        if(a[i + 1] == a[i]) ans[a[i].id] = ans[a[i + 1].id] + 1;
    }
    cdq1(1, n);
    for(int i = 1;i <= n; i++) cout << ans[i] << endl;
}\end{lstlisting}
\subsection{cdq套树状数组处理三维偏序}
\begin{lstlisting}
// 一维排序、二维cdq、三维树状数组

const int N = 1e5 + 10;
struct node {
    int x, y, z;
    int id;
    bool operator < (const node &a)const{
        if(x != a.x) return x < a.x;
        if(y != a.y) return y < a.y;
        return z < a.z;
    }
    bool operator == (const node &a)const{
        return x == a.x && y == a.y && z == a.z;
    }
}a[N], b[N];
int n;


int ans[N];

struct BIT {
#define lowbit(x) (x & (-x))
    int n;
    int t[N];

    void init(int _n) {
        mem(t, 0);
        n = _n;
    }

    void update(int x, int val) {
        while (x <= n) {
            t[x] += val;
            x += lowbit(x);
        }
    }

    int query(int x) {
        int ans = 0;
        while (x) {
            ans += t[x];
            x -= lowbit(x);
        }
        return ans;
    }
}bit;

void cdq(int l, int r) {
    if(l == r) return ;
    int mid = (l + r) / 2;
    cdq(l, mid);
    cdq(mid + 1, r);
    int p = l, q = mid + 1;
    for(int i = l;i <= r; i++) {
        if(q > r || (p <= mid && a[p].y <= a[q].y)) {
            bit.update(a[p].z, 1);
            b[i] = a[p++];
        }
        else {
            ans[a[q].id] += bit.query(a[q].z);
            b[i] = a[q++];
        }
    }
    for(int i = l;i <= mid; i++) bit.update(a[i].z, -1);
    for(int i = l;i <= r; i++) a[i] = b[i];
}

void solve() {
    n = read();
    int mx = 0;
    for(int i = 1;i <= n; i++) {
        a[i].x = read(), a[i].y = read(), a[i].z = read();
        a[i].id = i;
        mx = max(mx, a[i].z);
    }
    bit.init(mx);
    sort(a + 1, a + n + 1);
    for(int i = n - 1;i >= 1; i--) {
        if(a[i] == a[i + 1]) ans[a[i].id] = ans[a[i + 1].id] + 1;
    }
    cdq(1, n);
    for(int i = 1;i <= n; i++) cout << ans[i] << endl;
}
\end{lstlisting}
\subsection{cdq维护矩阵内二维数点}
\begin{lstlisting}
// 求二维平面上(x1,y1)到(x2,y2)的矩阵中数点

// 利用前缀和思想，把问题划分成[x2,y2] - [x1-1,y2] - [x2,y2-1] + [x1-1,y1-1]

// 所有要建立4个虚点为查询点，而原本实点为修改点

const int N = 3e6 + 10;

struct node {
    int x, y, opt, id;
    // opt为操作类型，1为修改，0为查询
    bool operator < (const node& o) const {
        return x == o.x ? (y == o.y ? opt : y < o.y) : x < o.x;
    }
    // 注意排序顺序，坐标相同时，要使opt放前面，因为要先修改

    bool operator == (const node &o) const {
        return x == o.x && y == o.y;
    }
}a[N], tmp[N];

int ans[N];

void cdq(int l, int r) {
    if(l == r) return ;
    int mid = (l + r) / 2;
    cdq(l, mid); cdq(mid + 1, r);
    int p = l, q = mid + 1, cnt = 0;
    for(int i = l;i <= r; i++) {
        if(q > r || (p <= mid && a[p].y <= a[q].y)) {
            cnt += a[p].opt;
            tmp[i] = a[p++];
        }
        else {
            ans[a[q].id] += cnt;
            tmp[i] = a[q++];
        }
    }
    for(int i = l;i <= r; i++) a[i] = tmp[i];
}

void solve() {
    int n = read(), m = read();
    for(int i = 1;i <= n; i++) {
        a[i].x = read(), a[i].y = read(), a[i].opt = 1;
    }
    int _n = 0;
    for(int i = 1;i <= m; i++) {
        int x1 = read(), y1 = read(), x2 = read(), y2 = read();
        a[++n] = (node){x2, y2, 0, ++_n};
        a[++n] = (node){x2, y1 - 1, 0, ++_n};
        a[++n] = (node){x1 - 1, y2, 0, ++_n};
        a[++n] = (node){x1 - 1, y1 - 1, 0, ++_n};
    }
    sort(a + 1, a + n + 1);
    cdq(1, n);
    for(int i = 1;i + 3 <= _n; i += 4) {
        cout << ans[i] - ans[i + 1] - ans[i + 2] + ans[i + 3] << endl;
    }
}
\end{lstlisting}
\subsection{可持久化01trie}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int N = 2e7 + 10;

int t[N][2];
int cnt, root[N], sz[N][2];
int a[N];

void insert(int pre, int &now, int i, int x) {
    if(i < 0) return ;
    now = ++cnt;
    int d = x >> i & 1;
    t[now][d ^ 1] = t[pre][d ^ 1]; 
    sz[now][d ^ 1] = sz[pre][d ^ 1]; sz[now][d] = sz[pre][d] + 1;
    insert(t[pre][d], t[now][d], i - 1, x);
}

int query(int l, int r, int i, int x) {
    if(i < 0) return 0;
    int d = x >> i & 1;
    int tmp = sz[r][d ^ 1] - sz[l][d ^ 1];
    if(tmp > 0) return query(t[l][d ^ 1], t[r][d ^ 1], i - 1, x) + (1 << i);
    else return query(t[l][d], t[r][d], i - 1, x);
}

int main() {
    int n, m;
    cin >> n >> m;
    for(int i = 1;i <= n; i++) {
        int x;
        cin >> x;
        insert(root[i - 1], root[i], 30, x);
    }
    while(m--) {
        int l, r, x;
        cin >> l >> r >> x;
        cout << query(root[l - 1], root[r], 30, x) << endl;
    }
}\end{lstlisting}
\subsection{可持久化数组}
\begin{lstlisting}

#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

struct Node {
    int l, r, val;
}hjt[N * 40];
int cnt, root[N];
int a[N];

inline void build(int &now, int l, int r) {
    now = ++cnt;
    if(l == r) {
        hjt[now].val = a[l];
        return ;
    }
    int m = (l + r) >> 1;
    build(hjt[now].l, l, m);
    build(hjt[now].r, m + 1, r);
}

inline void modify(int ver, int &now, int l, int r, int pos, int value) {
    hjt[now = ++cnt] = hjt[ver];
    if(l == r) {
        hjt[now].val = value;
        return ;
    }
    int m = (l + r) >> 1;
    if(pos <= m) modify(hjt[ver].l, hjt[now].l, l, m, pos, value);
    else modify(hjt[ver].r, hjt[now].r, m + 1, r, pos, value);
}

inline int query(int now, int l, int r, int pos) {
    if(l == r) return hjt[now].val;
    int m = (l + r) >> 1;
    if(pos <= m) return query(hjt[now].l, l, m, pos);
    else return query(hjt[now].r, m + 1, r, pos); 
}

int main() {
    int n, m;
    cin >> n >> m;
    for(int i = 1;i <= n; i++) cin >> a[i];
    build(root[0], 1, n);
    for(int i = 1;i <= m; i++) {
        int ver, opt;
        cin >> ver >> opt;
        if(opt == 1) {
            int pos, value;
            cin >> pos >> value;
            modify(root[ver], root[i], 1, n, pos, value);
        }
        else {
            int pos;
            cin >> pos;
            root[i] = root[ver];
            cout << query(root[i], 1, n, pos) << endl;
        }
    }
}\end{lstlisting}
\subsection{可持久化并查集}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

struct Node {
    int l, r, val;
}hjt[N * 40 * 2];

int cnt, rootfa[N], rootdep[N], tot;
int n;

inline void build(int &now, int l, int r) {
    now = ++cnt;
    if(l == r) {
        hjt[now].val = ++tot;
        return ;
    }
    int m = (l + r) >> 1;
    build(hjt[now].l, l, m);
    build(hjt[now].r, m + 1, r);
}

inline void modify(int ver, int &now, int l, int r, int pos, int value) {
    hjt[now = ++cnt] = hjt[ver];
    if(l == r) {
        hjt[now].val = value;
        return ;
    }
    int m = (l + r) >> 1;
    if(pos <= m) modify(hjt[ver].l, hjt[now].l, l, m, pos, value);
    else modify(hjt[ver].r, hjt[now].r, m + 1, r, pos, value);
}

inline int query(int now, int l, int r, int pos) {
    if(l == r) return hjt[now].val;
    int m = (l + r) >> 1;
    if(pos <= m) return query(hjt[now].l, l, m, pos);
    else return query(hjt[now].r, m + 1, r, pos);
}

inline int find(int ver, int x) {
    int fx = query(rootfa[ver], 1, n, x);
    return fx == x ? x : find(ver, fx);
}

inline void merge(int ver, int x, int y) {
    x = find(ver - 1, x);
    y = find(ver - 1, y);
    if(x == y) {
        rootfa[ver] = rootfa[ver - 1];
        rootdep[ver] = rootdep[ver - 1];
    }
    else {
        int depx = query(rootdep[ver - 1], 1, n, x);
        int depy = query(rootdep[ver - 1], 1, n, y);
        if(depx < depy) {
            modify(rootfa[ver - 1], rootfa[ver], 1, n, x, y);
            rootdep[ver] = rootdep[ver - 1];
        }
        else if(depx > depy) {
            modify(rootfa[ver - 1], rootfa[ver], 1, n, y, x);
            rootdep[ver] = rootdep[ver - 1];
        }
        else {
            modify(rootfa[ver - 1], rootfa[ver], 1, n, x, y);
            modify(rootdep[ver - 1], rootdep[ver], 1, n, y, depy + 1);
        }
    }
}

int main() {
    int m;
    cin >> n >> m;
    build(rootfa[0], 1, n);
    for(int ver = 1;ver <= m; ver++) {
        int opt, x, y;
        cin >> opt;
        if(opt == 1) {
            cin >> x >> y;
            merge(ver, x, y);
        }
        else if(opt == 2) {
            cin >> x;
            rootfa[ver] = rootfa[x];
            rootdep[ver] = rootdep[x];
        }
        else {
            cin >> x >> y;
            rootfa[ver] = rootfa[ver - 1];
            rootdep[ver] = rootdep[ver - 1];
            int u = find(ver, x);
            int v = find(ver, y);
            if(u == v) cout << 1 << endl;
            else cout << 0 << endl;
        }
    }
}
\end{lstlisting}
\subsection{扫描线求面积并}
\begin{lstlisting}
// 横向扫描
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 10;

#define lc u << 1
#define rc u << 1 | 1
#define mid (t[u].l + t[u].r) >> 1

int n, cnt;

double v[N];
struct L {
    double x, y1, y2;
    int state;
    bool operator < (L rhs) {return x < rhs.x; }
}line[N << 2];

struct Node {
    int l, r, cover;
    double len;
}t[N << 2];

inline void push_up(int u) {
    if(t[u].cover) t[u].len = v[t[u].r + 1] - v[t[u].l];
    else if(t[u].l == t[u].r) t[u].len = 0;
    else t[u].len = t[lc].len + t[rc].len;
}

void build(int u, int l, int r) {
    t[u].l = l; t[u].r = r;
    if(l == r) {
        t[l].cover = t[l].len = 0;
        return ;
    }
    int m = (l + r) >> 1;
    build(lc, l, m);
    build(rc, m + 1, r);
}

void modify(int u, int ql, int qr, int state) {
    if(ql <= t[u].l && t[u].r <= qr) {
        t[u].cover += state;
        push_up(u);
        return ;
    }
    if(ql <= mid) modify(lc, ql, qr, state);
    if(qr > mid)  modify(rc, ql, qr, state);
    push_up(u);
}

void init() {
    cin >> n;
    for(int i = 1;i <= n; i++) {
        double x1, y1, x2, y2;
        scanf("%lf%lf%lf%lf",&x1,&y1,&x2,&y2);
        line[i] = L{x1, y1, y2, 1}; v[i] = y1;
        line[n + i] = L{x2, y1, y2, -1}; v[n + i] = y2;
    }
    n <<= 1;
    sort(line + 1, line + n + 1);
    sort(v + 1, v + n + 1);
    cnt = unique(v + 1, v + n + 1) - (v + 1);
    build(1, 1, cnt);
}

void solve() {
    double ans = 0;
    for(int i = 1;i <= n; i++) {
        int ql = lower_bound(v + 1, v + cnt + 1, line[i].y1) - v;
        int qr = lower_bound(v + 1, v + cnt + 1, line[i].y2) - v - 1;
        modify(1, ql, qr, line[i].state);
        ans += t[1].len * (line[i + 1].x - line[i].x);
    }
    cout << ans << endl;
}

int main() {
    init();
    solve();
}
\end{lstlisting}
\subsection{扫描线求周长并}
\begin{lstlisting}
// 纵向扫描
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 10;

#define INF 0x3fffff
#define lc u << 1
#define rc u << 1 | 1
#define mid (t[u].l + t[u].r) >> 1

int n;

struct L {
    int y, x1, x2;
    int state;
    bool operator < (L rhs) {return y < rhs.y; }
}line[N << 2];

struct Node {
    int l, r, cover;
    bool ls, rs;
    int num;
    int len;
}t[N << 2];

inline void push_up(int u) {
    if(t[u].cover) {
        t[u].len = t[u].r - t[u].l + 1;
        t[u].ls = t[u].rs = 1;
        t[u].num = 1;
    }
    else if(t[u].l == t[u].r) {
        t[u].ls = t[u].rs = 0;
        t[u].len = t[u].num = 0;
    }
    else {
        t[u].len = t[lc].len + t[rc].len;
        t[u].ls = t[lc].ls; t[u].rs = t[rc].rs;
        t[u].num = t[lc].num + t[rc].num - (t[lc].rs & t[rc].ls);
    }
}

void build(int u, int l, int r) {
    t[u].l = l; t[u].r = r;
    if(l == r) {
        t[u].len = t[u].cover = t[u].ls = t[u].rs = t[u].num = 0;
        return ;
    }
    int m = (l + r) >> 1;
    build(lc, l, m);
    build(rc, m + 1, r);
}

void modify(int u, int ql, int qr, int state) {
    if(ql <= t[u].l && t[u].r <= qr) {
        t[u].cover += state;
        push_up(u);
        return ;
    }
    if(ql <= mid) modify(lc, ql, qr, state);
    if(qr > mid)  modify(rc, ql, qr, state);
    push_up(u);
}

void init() {
    cin >> n;
    int mx = -INF, mn = INF;
    for (int i = 1; i <= n; i++) {
        int x1, x2, y1, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        mx = max(mx, max(x1, x2));
        mn = min(mn, min(x1, x2));
        line[i] = L{y1, x1, x2, 1};
        line[n + i] = L{y2, x1, x2, -1};
    }
    n <<= 1;
    sort(line + 1, line + n + 1);
    build(1, mn, mx);
}

void solve() {
    int ans = 0;
    int last = 0;
    for(int i = 1;i <= n; i++) {
        modify(1, line[i].x1, line[i].x2 - 1, line[i].state);
        ans += abs(t[1].len - last); // 横线
        ans += (line[i + 1].y - line[i].y) * 2 * t[1].num; // 竖线
        last = t[1].len;
    }
    printf("%d\n",ans);
}

int main() {
    init();
    solve();
}
\end{lstlisting}
\subsection{区间第k小}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

vector<int> v;
struct Node {
    int l, r;
    int val;
}hjt[N * 40];
int root[N], cnt;

int get_id(int x) { return lower_bound(v.begin(), v.end(), x) - v.begin() + 1; }

void insert(int pre, int &now, int l, int r, int p) {
    hjt[++cnt] = hjt[pre];
    now = cnt;
    hjt[now].val++;
    if(l == r) return ;
    int m = (l + r) >> 1;
    if(p <= m) insert(hjt[pre].l, hjt[now].l, l, m, p);
    else insert(hjt[pre].r, hjt[now].r, m + 1, r, p);
}

int query(int L, int R, int l, int r, int k) {
    if(l == r) return l;
    int m = (l + r) >> 1;
    int tmp = hjt[hjt[R].l].val - hjt[hjt[L].l].val;
    if(k <= tmp) return query(hjt[L].l, hjt[R].l, l, m, k);
    else return query(hjt[L].r, hjt[R].r, m + 1, r, k - tmp); 
}

int main() {
    int n, q;
    cin >> n >> q;
    vector<int> a(n + 1);
    for(int i = 1;i <= n; i++) { cin >> a[i]; v.push_back(a[i]); }
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());

    for(int i = 1;i <= n; i++) {
        insert(root[i - 1], root[i], 1, n, get_id(a[i]));
    }

    while(q--) {
        int l, r, k;
        cin >> l >> r >> k;
        cout << v[query(root[l - 1], root[r], 1, n, k) - 1] << endl;
    }
}
\end{lstlisting}
\subsection{区间前k大}
\begin{lstlisting}

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 1e6 + 10;
int a[N];
vector<int> v;
int cnt, root[N];

struct Node {
    int l, r;
    ll sum;
    int num;
    int val;
}hjt[N * 40];

int getid(int x) { return lower_bound(v.begin(), v.end(), x) - v.begin() + 1; }

void insert(int pre, int &now, int l, int r, int p, int val) {
    now = ++cnt;
    hjt[now] = hjt[pre];
    hjt[now].num++; hjt[now].sum += val;
    if(l == r) {
        hjt[now].val = val;
        return ;
    }
    int m = (l + r) >> 1;
    if(p <= m) insert(hjt[pre].l, hjt[now].l, l, m, p, val);
    else insert(hjt[pre].r, hjt[now].r, m + 1, r, p, val);
}

ll query(int L, int R, int l, int r, int k) {
    if(l == r) return hjt[R].val * k;
    int m = (l + r) >> 1;
    int tmp = hjt[hjt[R].r] .num - hjt[hjt[L].r].num;
    if(k <= tmp) return query(hjt[L].r, hjt[R].r, m + 1, r, k);
    else return hjt[hjt[R].r].sum - hjt[hjt[L].r].sum + query(hjt[L].l, hjt[R].l, l, m, k - tmp);
}

void init(int n) {
    v.clear();
    cnt = 0;
    for(int i = 1;i <= n; i++) {
        scanf("%d",&a[i]);
        v.push_back(a[i]); root[i] = 0;
    }
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
}

int main() {
    int _;
    scanf("%d",&_);
    while(_--) {
        int n;
        scanf("%d",&n);
        init(n);
        for(int i = 1;i <= n; i++) {
            insert(root[i - 1], root[i], 1, n, getid(a[i]), a[i]);
        }
        int q;
        scanf("%d",&q);
        while(q--) {
            int l, r, k;
            scanf("%d%d%d",&l,&r,&k);
            int t = r - l + 1;
            ll ans = query(root[l - 1], root[r], 1, n, k);
            printf("%lld\n",1ll * t * (t + 1) * (2 * t + 1) / 6 + ans);
        }
    }
}
\end{lstlisting}
\subsection{树套树维护三维偏序}
\begin{lstlisting}
const int N = 4e6 + 10;

int n, k;
struct node {
    int a, b, c;
    int operator < (const node &o) const {
        return a != o.a ? (a < o.a) : (b != o.b ? (b < o.b) : (c < o.c));
    }

    int operator == (const node &o) const {
        return a == o.a && b == o.b && c == o.c;
    }
}p[N];


struct Tree1 {
    int l, r;
}t1[N << 2];

struct Tree2 {
    int l, r;
    int num;
}t2[N << 2];

int root, root2[N];
int cnt1, cnt2;

void vec_insert(int &u, int l, int r, int pos, int val) {
    if(!u) u = ++cnt2;
    t2[u].num += val;
    if(l == r) return ;
    int m = (l + r) / 2;
    if(pos <= m) vec_insert(t2[u].l, l, m, pos, val);
    else vec_insert(t2[u].r, m + 1, r, pos, val);
}

int vec_query(int u, int l, int r, int ql, int qr) {
    if(!u) return 0;
    if(ql <= l && r <= qr) return t2[u].num;
    int ans = 0;
    int mid = (l + r) / 2;
    if(ql <= mid) ans += vec_query(t2[u].l, l, mid, ql, qr);
    if(qr  > mid) ans += vec_query(t2[u].r, mid + 1, r, ql, qr);
    return ans;
}

// 在第一维权值线段树在[1,k]根据p[x].b插入，第二维权值线段树在[1,k]根据p[x].c插入
void tree_insert(int &u, int l, int r, int x, int val) {
    if(!u) u = ++cnt1;
    vec_insert(root2[u], 1, k, p[x].c, val);
    if(l == r) return ;
    int m = (l + r) / 2;
    if(p[x].b <= m) tree_insert(t1[u].l, l, m, x, val);
    else tree_insert(t1[u].r, m + 1, r, x, val);
}

int tree_query(int u, int l, int r, int x) {
    if(!u) return 0;
    if(1 <= l && r <= p[x].b) return vec_query(root2[u], 1, k, 1, p[x].c);
    int mid = (l + r) / 2;
    int ans = 0;
    if(1 <= mid) ans += tree_query(t1[u].l, l, mid, x);
    if(p[x].b > mid) ans += tree_query(t1[u].r, mid + 1, r, x);
    return ans;
}

void solve() {
    cin >> n >> k;
    for(int i = 1;i <= n; i++) cin >> p[i].a >> p[i].b >> p[i].c;
    sort(p + 1, p + n + 1);
    vector<int> ans(n + 1);
    int sum = 1;
    for(int i = 1;i <= n; i++) {
        // 因为这些个都一样，如果不这样操作，会使后面的不会对前面的有贡献
        if(p[i + 1] == p[i]) {
            sum++;
            continue;
        }
        tree_insert(root, 1, k, i, sum);
        int res = tree_query(root, 1, k, i);
        ans[res] += sum;
        sum = 1;
    }
    for(int i = 1;i <= n; i++) cout << ans[i] << endl;
}
\end{lstlisting}
\subsection{线段树套主席树_二维区间不同数}
\begin{lstlisting}
const int N = 2e5 + 10;

int n, m, l, r, a, b, num[N], Last[N], pre[N], Hash[N], ans[N][2];
int cnt, root[N], sum[N * 20], lc[N * 20], rc[N * 20];
struct Query {
    int a, b, l, id;
};

struct data {
    int a, v;

    bool operator<(const data &b) const {
        return a < b.a;
    }
} d[N];

vector<Query> q[N * 4];

void addquery(int o, int l, int r, int L, int R, Query qry) {
    if (L <= l && R >= r) {
        q[o].push_back(qry);
        return;
    }
    int mid = (l + r) / 2;
    if (L <= mid) {
        addquery(o * 2, l, mid, L, R, qry);
    }
    if (R > mid) {
        addquery(o * 2 + 1, mid + 1, r, L, R, qry);
    }
}

void build(int y, int &x, int l, int r, int k) {
    x = ++cnt;
    sum[x] = sum[y] + 1;
    lc[x] = lc[y];
    rc[x] = rc[y];
    if (l == r) {
        return;
    }
    int mid = (l + r) / 2;
    if (k <= mid) {
        build(lc[y], lc[x], l, mid, k);
    } else {
        build(rc[y], rc[x], mid + 1, r, k);
    }
}

int query(int y, int x, int l, int r, int k) {
    if (!x || l == r) {
        return 0;
    }
    int mid = (l + r) / 2;
    if (k <= mid) {
        return query(lc[y], lc[x], l, mid, k);
    } else {
        return sum[lc[x]] - sum[lc[y]] + query(rc[y], rc[x], mid + 1, r, k);
    }
}

void insert(int o, int l, int r) {
    if (q[o].size()) {
        Hash[0] = 0;
        for (int i = l; i <= r; i++) {
            Hash[++Hash[0]] = num[i];
        }
        sort(Hash + 1, Hash + Hash[0] + 1);
        int s = 0;
        for (int i = l; i <= r; i++) {
            d[++s].a = lower_bound(Hash + 1, Hash + Hash[0] + 1, num[i]) - Hash;
            d[s].v = pre[i];
        }
        sort(d + 1, d + s + 1);
        for (int i = 1; i <= s; i++) {
            build(root[i - 1], root[i], 0, n, d[i].v);
        }
        int a, b;
        for (int i = 0; i < q[o].size(); i++) {
            a = lower_bound(Hash + 1, Hash + Hash[0] + 1, q[o][i].a) - Hash;
            b = upper_bound(Hash + 1, Hash + Hash[0] + 1, q[o][i].b) - Hash - 1;
            ans[q[o][i].id][0] += sum[root[b]] - sum[root[a - 1]];
            ans[q[o][i].id][1] += query(root[a - 1], root[b], 0, n, q[o][i].l);
        }
        memset(root, 0, sizeof(int) * (Hash[0] + 1));
        memset(sum, 0, sizeof(int) * (cnt + 1));
        memset(lc, 0, sizeof(int) * (cnt + 1));
        memset(rc, 0, sizeof(int) * (cnt + 1));
        cnt = 0;
    }
    if (l == r) {
        return;
    }
    int mid = (l + r) / 2;
    insert(o * 2, l, mid);
    insert(o * 2 + 1, mid + 1, r);
}

void solve() {
    int _;
    cin >> _;
    while (_--) {
        for (int i = 0; i < N * 4; i++) q[i].clear();
        cnt = 0;
        for (int i = 0; i < N; i++) ans[i][0] = ans[i][1] = pre[i] = Last[i] = 0;
        cin >> n >> m;
        for (int i = 1; i <= n; i++) {
            cin >> num[i];
            num[i]++;
            pre[i] = Last[num[i]];
            Last[num[i]] = i;
        }
        for (int i = 1; i <= m; i++) {
            cin >> l >> a >> r >> b;
            a++, b++;
            addquery(1, 1, 1e5 + 1, l, r, (Query) {a, b, l, i});
        }
        insert(1, 1, 1e5 + 1);
        for (int i = 1; i <= m; i++) {
            cout << ans[i][1] << endl;
        }
    }
}
\end{lstlisting}
\subsection{Scapegoat}
\begin{lstlisting}
// 无旋转平衡，暴力拍扁重构

#include <bits/stdc++.h>
using namespace std;

namespace Scapegoat_Tree {
#define MAXN (100000 + 10)
	const double alpha = 0.75;
	struct Node {
	Node * ch[2];
	int key, size, cover; // size为有效节点的数量，cover为节点总数量 
	bool exist;	// 是否存在（即是否被删除） 
	void PushUp(void) {
		size = ch[0]->size + ch[1]->size + (int)exist;
		cover = ch[0]->cover + ch[1]->cover + 1;
	}
	bool isBad(void) { // 判断是否需要重构 
		return ((ch[0]->cover > cover * alpha + 5) || 
				(ch[1]->cover > cover * alpha + 5));
		}
	};
	struct STree {
	protected:
		Node mem_poor[MAXN]; //内存池，直接分配好避免动态分配内存占用时间 
		Node *tail, *root, *null; // 用null表示NULL的指针更方便，tail为内存分配指针，root为根 
		Node *bc[MAXN]; int bc_top; // 储存被删除的节点的内存地址，分配时可以再利用这些地址 

		Node * NewNode(int key) {
			Node * p = bc_top ? bc[--bc_top] : tail++;
			p->ch[0] = p->ch[1] = null;
			p->size = p->cover = 1; p->exist = true;
			p->key = key;
			return p;
		}
		void Travel(Node * p, vector<Node *>&v) {
			if (p == null) return;
			Travel(p->ch[0], v);
			if (p->exist) v.push_back(p); // 构建序列 
			else bc[bc_top++] = p; // 回收 
			Travel(p->ch[1], v);
		}
		Node * Divide(vector<Node *>&v, int l, int r) {
			if (l >= r) return null;
			int mid = (l + r) >> 1;
			Node * p = v[mid];
			p->ch[0] = Divide(v, l, mid);
			p->ch[1] = Divide(v, mid + 1, r);
			p->PushUp(); // 自底向上维护，先维护子树 
			return p;
		}
		void Rebuild(Node * &p) {
			static vector<Node *>v; v.clear();
			Travel(p, v); p = Divide(v, 0, v.size());
		}
		Node ** Insert(Node *&p, int val) {
			if (p == null) {
				p = NewNode(val);
				return &null;
			}
			else {
				p->size++; p->cover++;
				
				// 返回值储存需要重构的位置，若子树也需要重构，本节点开始也需要重构，以本节点为根重构 
				Node ** res = Insert(p->ch[val >= p->key], val);
				if (p->isBad()) res = &p;
				return res;
			}
		}
		void Erase(Node *p, int id) {
			p->size--;
			int offset = p->ch[0]->size + p->exist;
			if (p->exist && id == offset) {
				p->exist = false;
				return;
			}
			else {
				if (id <= offset) Erase(p->ch[0], id);
				else Erase(p->ch[1], id - offset);
			}
		}
	public:
		void Init(void) {
			tail = mem_poor;
			null = tail++;
			null->ch[0] = null->ch[1] = null;
			null->cover = null->size = null->key = 0;
			root = null; bc_top = 0;
		}
		STree(void) { Init(); }

		void Insert(int val) {
			Node ** p = Insert(root, val);
			if (*p != null) Rebuild(*p);
		}
		int Rank(int val) {
			Node * now = root;
			int ans = 1;
			while (now != null) { // 非递归求排名 
				if (now->key >= val) now = now->ch[0];
				else {
					ans += now->ch[0]->size + now->exist;
					now = now->ch[1];
				}
			}
			return ans;
		}
		int Kth(int k) {
			Node * now = root;
			while (now != null) { // 非递归求第K大 
				if (now->ch[0]->size + 1 == k && now->exist) return now->key;
				else if (now->ch[0]->size >= k) now = now->ch[0];
				else k -= now->ch[0]->size + now->exist, now = now->ch[1];
			}
		}
		void Erase(int k) {
			Erase(root, Rank(k));
			if (root->size < alpha * root->cover) Rebuild(root);
		}
		void Erase_kth(int k) {
			Erase(root, k);
			if (root->size < alpha * root->cover) Rebuild(root);
		}
	}sTree;
#undef MAXN

}

int main() {
    Scapegoat_Tree::sTree.Init();
    int _; cin >> _;
    while(_--) {
        int opt, x;
        cin >> opt >> x;
        if(opt == 1) Scapegoat_Tree::sTree.Insert(x);
        else if(opt == 2) Scapegoat_Tree::sTree.Erase(x);
        else if(opt == 3) cout << Scapegoat_Tree::sTree.Rank(x) << endl;
        else if(opt == 4) cout << Scapegoat_Tree::sTree.Kth(x) << endl;
        else if(opt == 5) cout << Scapegoat_Tree::sTree.Kth(Scapegoat_Tree::sTree.Rank(x) - 1) << endl;
        else if(opt == 6) cout << Scapegoat_Tree::sTree.Kth(Scapegoat_Tree::sTree.Rank(x + 1)) << endl;
    }
}\end{lstlisting}
\subsection{Splay}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

struct Splay { // 有旋平衡树
#define rt  ch[0][1]
#define lc  ch[u][0]
#define rc  ch[u][1]
#define identify(u) (ch[fa[u]][1] == u)
    int tot, totElement;
    int val[N], cnt[N], fa[N], sum[N];
    int ch[N][2];
    Splay() { tot = totElement = 0; }
    void push_up(int u) { sum[u] = sum[lc] + sum[rc] + cnt[u]; }
    void connect(int u, int par, int son) { ch[par][son] = u, fa[u] = par; }
    void rotate(int u) {
        int fc = identify(u), f = fa[u];
        int gc = identify(f), g = fa[f];
        int uc = fc ^ 1, son = ch[u][uc];
        connect(son, f, fc);
        connect(f, u, uc);
        connect(u, g, gc);
        push_up(f);
        push_up(u);
    }
    void splay(int u, int v) {
        v = fa[v];
        while (fa[u] != v) {
            int f = fa[u];
            if (fa[f] != v)
                rotate(identify(u) ^ identify(f) ? u : f);
            rotate(u);
        }
    }
    int creat(int v, int par) {
        val[++tot] = v;
        fa[tot] = par;
        sum[tot] = cnt[tot] = 1;
        return tot;
    }
    void destory(int u) {
        val[u] = cnt[u] = fa[u] = sum[u] = lc = rc = 0;
        tot -= u == tot;
    }
    int find(int v) {
        int u = rt;
        while (1) {
            if (val[u] == v) {
                splay(u, rt);
                return u;
            }
            int nxt = v > val[u];
            if (!ch[u][nxt]) return -1;
            u = ch[u][nxt];
        }
    }
    int insert(int v) {
        totElement++;
        if (totElement == 1) {
            creat(v, 0);
            return rt = tot;
        }
        int u = rt;
        while (1) {
            sum[u]++;
            if (v == val[u]) {
                cnt[u]++;
                return u;
            }
            int nxt = v > val[u];
            if (!ch[u][nxt]) {
                creat(v, u);
                splay(ch[u][nxt] = tot, rt);
                return tot;
            }
            u = ch[u][nxt];
        }
    }
    void remove(int v) {
        int u = find(v);
        if (!u) return;
        totElement--;
        if (cnt[u] > 1) {
            cnt[u]--, sum[u]--;
            return;
        }
        if (!lc) fa[rt = rc] = 0;
        else {
            int now = lc;
            while (ch[now][1]) now = ch[now][1];
            splay(now, lc);
            connect(rc, now, 1); connect(now, 0, 1);
            push_up(now);
        }
        destory(u);
    }
    int getRank(int v) {
        int k = 0, u = rt;
        while (1) {
            if (v == val[u]) {
                k += sum[lc] + 1;
                splay(u, rt);
                return k;
            }
            else if (v < val[u]) u = lc;
            else {
                k += sum[lc] + cnt[u];
                u = rc;
            }
            if (!u) return 0;
        }
    }
    int atRank(int k) {
        if (k > totElement) return -1;
        int u = rt;
        while (1) {
            if (k > sum[lc] && k <= sum[lc] + cnt[u]) {
                splay(u, rt);
                break;
            }
            if (k <= sum[lc]) u = lc;
            else {
                k -= sum[lc] + cnt[u];
                u = rc;
            }
        }
        return val[u];
    }
    int upper(int v) {
        int u = rt, minn = 0x3f3f3f3f, p = 0;
        while (u) {
            if (val[u] > v && val[u] < minn) minn = val[u], p = u;
            if (v >= val[u]) u = rc;
            else u = lc;
        }
        if (!p) splay(p, rt);
        return minn;
    }
    int lower(int v) {
        int u = rt, maxx = -0x3f3f3f3f, p = 0;
        while (u) {
            if (val[u] < v && val[u] > maxx) maxx = val[u], p = u;
            if (v <= val[u]) u = lc;
            else u = rc;
        }
        if (!p) splay(p, rt);
        return maxx;
    }
}splay;

void solve() {
    int _; cin >> _;
    while(_--) {
        int opt, x;
        cin >> opt >> x;
        if(opt == 1) splay.insert(x);
        else if(opt == 2) splay.remove(x);
        else if(opt == 3) cout << splay.getRank(x) << endl;
        else if(opt == 4) cout << splay.atRank(x) << endl;
        else if(opt == 5) cout << splay.lower(x) << endl;
        else if(opt == 6) cout << splay.upper(x) << endl;
    }
}\end{lstlisting}
\subsection{Splay区间翻转}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int MAX = 4e5 + 10;
int n;

struct Splay {
#define rt  ch[0][1]
#define lc  ch[u][0]
#define rc  ch[u][1]
    int tot, totElement;
    int val[MAX], fa[MAX], sum[MAX], tag[MAX];
    int ch[MAX][2];
    Splay() { tot = totElement = 0; }
    void push_up(int u) { sum[u] = sum[lc] + sum[rc] + 1; }
    void push_down(int u) {
        if (tag[u]) {
            tag[lc] ^= 1;
            tag[rc] ^= 1;
            tag[u] = 0;
            swap(lc, rc);
        }
    }
    int identify(int u) { return ch[fa[u]][1] == u; }
    void connect(int u, int par, int son) { ch[par][son] = u, fa[u] = par; }
    void rotate(int u) {
        int fc = identify(u), f = fa[u];
        int gc = identify(f), g = fa[f];
        int uc = fc ^ 1, son = ch[u][uc];
        connect(son, f, fc);
        connect(f, u, uc);
        connect(u, g, gc);
        push_up(f);
        push_up(u);
    }
    void splay(int u, int v) {
        v = fa[v];
        while (fa[u] != v) {
            int f = fa[u];
            if (fa[f] != v)
                rotate(identify(u) ^ identify(f) ? u : f);
            rotate(u);
        }
    }
    int creat(int v, int par) {
        val[++tot] = v;
        fa[tot] = par;
        sum[tot] = 1;
        return tot;
    }
    int insert(int v) {
        totElement++;
        if (totElement == 1) {
            creat(v, 0);
            return rt = tot;
        }
        int u = rt;
        while (1) {
            sum[u]++;
            if (v == val[u]) return u;
            int nxt = v > val[u];
            if (!ch[u][nxt]) {
                creat(v, u);
                splay(ch[u][nxt] = tot, rt);
                return tot;
            }
            u = ch[u][nxt];
        }
    }
    int queryKth(int k) {
        if (k > totElement) return -1;
        int u = rt;
        while (1) {
            push_down(u);
            if (k > sum[lc] && k <= sum[lc] + 1) {
                splay(u, rt);
                return val[u];
            }
            if (k <= sum[lc]) u = lc;
            else {
                k -= sum[lc] + 1;
                u = rc;
            }
        }
    }
    void reverse(int ql, int qr) {
        ql = queryKth(ql);
        qr = queryKth(qr + 2);
        splay(ql, rt);
        splay(qr, ch[ql][1]);
        tag[ch[qr][0]] ^= 1;
    }
    void DFS(int u) {
        push_down(u);
        if(lc) DFS(lc);
        if(val[u] > 1 && val[u] < n + 2)
            cout << val[u] - 1 << " ";
        if(rc) DFS(rc);
    }
} splay;

void solve() {
    int m; cin >> n >> m;
    for(int i = 1;i <= n + 2; i++) splay.insert(i);
    while(m--) {
        int l, r; cin >> l >> r;
        splay.reverse(l, r);
    }
    splay.DFS(splay.ch[0][1]);
    cout << endl;
}

/*--------------------------*/

typedef long long ll;

#define INF 0x3f3f3f3f

const int N = 1e5 + 10;

int a[N];
int n, cnt, root;

struct Node {
    int ch[2];
    int val, fa;
    int siz, tag;
} t[N];

void update(int x) {
    t[x].siz = t[t[x].ch[0]].siz + t[t[x].ch[1]].siz + 1;
}

void push_down(int x) {
    if (x && t[x].tag) {
        t[t[x].ch[0]].tag ^= 1;
        t[t[x].ch[1]].tag ^= 1;
        swap(t[x].ch[0], t[x].ch[1]);
        t[x].tag = 0;
    }
}

int id(int x) {
    return x == t[t[x].fa].ch[1];
}

void connect(int fa, int x, int d) {
    t[x].fa = fa;
    t[fa].ch[d] = x;
}

void rotate(int x) {
    int f = t[x].fa;
    int ff = t[f].fa;
    push_down(x);
    push_down(f);
    int fson = id(x);
    int ffson = id(f);
    int son = t[x].ch[fson ^ 1];
    connect(f, son, fson);
    connect(x, f, fson ^ 1);
    connect(ff, x, ffson);
    update(f), update(x);
}

void splay(int x, int to) { // 将 x 转到 to 的子节点位置
    while (t[x].fa != to) {
        int f = t[x].fa;
        if (t[f].fa != to) {
            rotate(id(x) == id(f) ? f : x);
        }
        rotate(x);
    }
    if (!to) { // 在 splay(l, 0) 时起作用
        root = x;
    }
}

int build(int l, int r, int fa) {
    if (l > r) {
        return 0;
    }
    int mid = (l + r) >> 1;
    int x = ++cnt;
    t[x].fa = fa;
    t[x].siz = 1;
    t[x].val = a[mid];
    t[x].ch[0] = build(l, mid - 1, x);
    t[x].ch[1] = build(mid + 1, r, x);
    update(x);
    return x;
}

int find(int rank) {
    int x = root;
    while (1) {
        push_down(x);
        if (rank <= t[t[x].ch[0]].siz) {
            x = t[x].ch[0];
        } else {
            rank -= t[t[x].ch[0]].siz + 1;
            if (!rank) {
                return x;
            }
            x = t[x].ch[1];
        }
    }
}

void reverse(int l, int r) {
    l = find(l);
    r = find(r);
    splay(l, 0);
    splay(r, l);
    int pos = t[t[root].ch[1]].ch[0];
    t[pos].tag ^= 1;
}

void print(int x) {
    if (!x) {
        return;
    }
    push_down(x);
    print(t[x].ch[0]);
    if (t[x].val != INF && t[x].val != -INF) {
        printf("%d ", t[x].val);
    }
    print(t[x].ch[1]);
}

void solve() {
    cin >> n >> m;
    for(int i = 1;i <= n; i++) cin >> a[i + 1];
    a[1] = -INF; a[n + 2] = INF;
    root = build(1, n + 2, 0);
    for(int i = 1;i <= m; i++) {
        int l, r; cin >> l >> r;
        reverse(l + 1, r + 1);
    }
    print(root);
}\end{lstlisting}
\subsection{01trie}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int N = 1e3 * 32 + 10;

int t[N][2];
int num[N];
int idx;

void insert(ll x) {
    int rt = 0;
    for(int i = 32;i >= 0; i--) {
        int v = x >> i & 1;
        if(!t[rt][v]) {
            t[idx][0] = t[idx][1] = 0;
            num[idx] = 0;
            t[rt][v] = idx++;
        }
        rt = t[rt][v];
        num[rt]++;
    }
}

void modify(ll x, int val) {
    int rt = 0;
    for(int i = 32;i >= 0; i--) {
        int v = x >> i & 1;
        rt = t[rt][v];
        num[rt] += val;
    }
}

ll query(ll x) {
    ll ans = 0;
    int rt = 0;
    for(int i = 32;i >= 0; i--) {
        int v = x >> i & 1;
        if(t[rt][!v] && num[t[rt][!v]]) {
            ans += 1 << i;
            rt = t[rt][!v];
        }
        else rt = t[rt][v];
    }
    return ans;
}

// 不能有两个相同的异或，加一个num数组，表示访问次数

int main() {
    int _ = read();
    while(_--) {
        idx = 1; t[0][0] = t[0][1] = 0;
        int n = read();
        vector<ll> a(n + 1);
        for(int i = 1;i <= n; i++) insert(a[i] = read());
        ll ans = 0;
        for(int i = 1;i <= n; i++) {
            modify(a[i], -1);
            for(int j = i + 1;j <= n; j++) {
                modify(a[j], -1);
                ans = max(ans, query(a[i] + a[j]));
                modify(a[j], 1);
            }
            modify(a[i], 1);
        }
        cout << ans << endl;
    }
}\end{lstlisting}
\clearpage\section{博弈论}
\subsection{巴什博弈}
\begin{lstlisting}
// 一堆石头，一次只能拿m个
void BaShe() {
    int n, m;
    cin >> n >> m;
    if(n % (m + 1))
        cout << "first" << endl;
    else 
        cout << "second" << endl;
}
\end{lstlisting}
\subsection{斐波那契博弈}
\begin{lstlisting}
int fib[100001], n;
map<int, bool> p;
int main() {
    fib[1] = 1; fib[2] = 2;
    for(int i = 3;i <= 50; i++) {
        fib[i] = fib[i - 1] + fib[i - 2];
        p[fib[i]] = 1;
    }
    scanf("%d",&n);
    if(p[n]) printf("second");
    else printf("first");
}
\end{lstlisting}
\subsection{尼姆博弈}
\begin{lstlisting}
//  尼姆博弈是巴什博弈的进化版
// 有n堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，没法拿的人失败

// 定理：当n堆石子的数量异或和等于0时，先手必胜，否则先手必败

const int N = 1e5 + 10;
int a[N];

void Nim() {
    int n, ans = 0;
    cin >> n;
    for(int i = 1;i <= n; i++) {
        cin >> a[i];
        ans ^= a[i];
    }
    if(ans == 0)
        cout << "second" << endl;
    else 
        cout << "first" << endl;
}

// Auti-nim 反尼姆游戏
// 当先拿完所有石子时候输
// 当如下条件时，先手必胜
// ①：所有堆的石子数均=1，且有偶数堆。 
// ②：至少有一个堆的石子数>1，且石子堆的异或和≠0。
\end{lstlisting}
\subsection{威佐夫博弈}
\begin{lstlisting}
// 每次每个人可以从任意一堆石子中取任意多的石子或者从两堆石子中取同样多的石子，不能取得人输

void WZF() {
    int a, b;
    cin >> a >> b;
    if(a > b) swap(a, b);
    int temp = b - a;
    int ans = temp * (1.0 + sqrt(5.0)) / 2.0;
    if(ans == a)
        cout << "second" << endl;
    else 
        cout << "first" << endl;
}

void EX_WZF() {
    int a, b, k;
    cin >> a >> b >> k;
    k++;
    if(a > b) swap(a, b);
    int temp = (b - a) / k;
    int ans1 = temp * (2 - k + sqrt(4.0 + k * k)) / 2;
    int ans2 = temp * (2 + k + sqrt(4.0 + k * k)) / 2;
    if(ans1 == a && ans2 == b)
        cout << "second" << endl;
    else 
        cout << "first" << endl;
}
\end{lstlisting}
\subsection{SG函数}
\begin{lstlisting}
// SG函数
#define N 1001
//f[]：可以取走的石子个数
//sg[]:0~n的SG函数值
int f[N], sg[N], mex[N];

void getSG(int n) {
    int i, j;
    memset(sg, 0, sizeof(sg));
    for (i = 1; i <= n; i++) {
        memset(mex, 0, sizeof(mex));
        for (j = 1; f[j] <= i; j++)
            mex[sg[i - f[j]]] = 1;
        for (j = 0; j <= n; j++) { //求mes{}中未出现的最小的非负整数
            if (mex[j] == 0) {
                sg[i] = j;
                break;
            }
        }
    }
}
\end{lstlisting}
\clearpage\section{树与森林}
\subsection{dp树上直径}
\begin{lstlisting}
// 树的最长路径

#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 10;

int f[N][2];
int down[N], up[N];
int ans;

vector<int> g[N];

void dfs1(int u, int fa) {
    for(auto v : g[u]) {
        if(v == fa) continue ;
        dfs1(v, u);
        if(f[v][0] + 1 > f[u][0]) {
            f[u][1] = f[u][0];
            f[u][0] = f[v][0] + 1;
            down[u] = v;
        }
        else if(f[v][0] + 1 > f[u][1]) f[u][1] = f[v][0] + 1;
    }
    ans = max(ans, f[u][0] + f[u][1]);
}

void dfs2(int u, int fa) {
    for(auto v : g[u]) {
        if(v == fa) continue ;
        up[v] = up[u] + 1;
        if(down[u] == v) up[v] = max(up[v], f[u][1] + 1);
        else up[v] = max(up[v], f[u][0] + 1);
        dfs2(v, u);
    }
}

int main() {
    int n; cin >> n;
    for(int i = 1;i < n; i++) {
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs1(0, -1);
    dfs2(0, -1);
    for(int i = 0;i < n; i++) {
        int d[3] = {f[i][1], f[i][0], up[i]};
        sort(d, d + 3);
        if(d[2] + d[1] == ans) cout << i << endl;
    }
}\end{lstlisting}
\subsection{重链剖分}
\begin{lstlisting}
const int maxn = 4e5 + 10;

struct Edge {
    int v, next;
}e[maxn << 1];

int head[maxn * 2], cnt;

inline void add(int u, int v) {
    e[++cnt].v = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}
 
int fa[maxn], dep[maxn], siz[maxn], son[maxn];

void dfs1(int u, int par) {
    dep[u] = dep[fa[u] = par] + (siz[u] = 1);
    for(int i = head[u]; ~i; i = e[i].next) {
        int v = e[i].v;
        if(v == par) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if(!son[u] || siz[v] > siz[son[u]]) 
            son[u] = v;
    }
}

int dfn[maxn], top[maxn], nodeof[maxn], tim;

void dfs2(int u, int topf) {
    nodeof[dfn[u] = ++tim] = u;
    top[u] = topf;
    if(!son[u]) return ;
    dfs2(son[u], topf);
    for(int i = head[u]; ~i; i = e[i].next) {
        int v = e[i].v;
        if(v == fa[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}

int w[maxn];

#define lc u << 1
#define rc u << 1 | 1
#define mid (t[u].l + t[u].r) / 2
struct Tree {
    int l, r, sum, tag;
}t[maxn << 2];
inline void push_up(int u) ;
inline void push_down(int u) ;
void build(int u, int l, int r) ;
void modify(int u, int ql, int qr, int v) ;
int query(int u, int ql, int qr) ;

void modify_chain(int x, int y, int val) {
    while(top[x] != top[y]) {
        if(dep[top[x]] < dep[top[y]]) swap(x, y);
        modify(1, dfn[top[x]], dfn[x], val);
        x = fa[top[x]];
    }
    if(dep[x] > dep[y]) swap(x, y);
    modify(1, dfn[x], dfn[y], val);
}

int query_chain(int x, int y) {
    int ans = 0;
    while(top[x] != top[y]) {
        if(dep[top[x]] < dep[top[y]]) swap(x, y);
        ans += query(1, dfn[top[x]], dfn[x]);
        x = fa[top[x]];
    }
    if(dep[x] > dep[y]) swap(x, y);
    ans += query(1, dfn[x], dfn[y]);
    return ans;
}

signed main() {
    memset(head, -1, sizeof(head));
    int n; cin >> n;
    for(int i = 1;i <= n; i++) cin >> w[i];
    for(int i = 1;i <= n - 1; i++) {
        int u, v; cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    dfs1(1, 0);
    dfs2(1, 1);
    build(1, 1, n);
    int m; cin >> m;
    while(m--) {
        int opt; cin >> opt;
        if(opt == 1) {
            int x, y, val; cin >> x >> y >> val;
            modify_chain(x, y, val);
        }
        else if(opt == 2) {
            int x, val; cin >> x >> val;
            modify(1, dfn[x], dfn[x] + siz[x] - 1, val);
        }
        else if(opt == 3) {
            int x, y; cin >> x >> y;
            cout << query_chain(x, y) << endl;
        }
        else if(opt == 4) {
            int x; cin >> x;
            cout << query(1, dfn[x], dfn[x] + siz[x] - 1) << endl;
        }
    }
}\end{lstlisting}
\subsection{倍增LCA}
\begin{lstlisting}
const int N = 1e5 + 10;
vector<int> g[N];

int fa[N][30];
int dep[N];

void dfs(int u, int par) {
    dep[u] = dep[fa[u][0] = par] + 1;
    for(int i = 1;i <= 20; i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for(auto v : g[u]) {
        if(v == par) continue;
        dfs(v, u);
    }
}

int LCA(int x, int y) {
    if(dep[x] < dep[y]) swap(x, y);
    for(int i = 20;i >= 0; i--) {
        if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];
    }
    if(x == y) return x;
    for(int i = 20;i >= 0; i--) {
        if(fa[x][i] != fa[y][i]) {
            x = fa[x][i];
            y = fa[y][i];
        }
    }
    return fa[x][0];
}\end{lstlisting}
\subsection{树剖LCA}
\begin{lstlisting}
int son[N], siz[N], top[N], fa[N], dep[N];
void dfs(int u, int par) {
    dep[u] = dep[fa[u] = par] + (siz[u] = 1);
    int max_son = -1;
    for (auto &v: g[u])
        if (v != par) {
            dfs(v, u);
            siz[u] += siz[v];
            if (max_son < siz[v])
                son[u] = v, max_son = siz[v];
        }
}
void dfs2(int u, int topf) {
    top[u] = topf;
    if (!son[u]) return;
    dfs2(son[u], topf);
    for (auto &v: g[u])
        if (v != fa[u] && v != son[u]) dfs2(v, v);
}
int LCA(int x, int y) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        x = fa[top[x]];
    }
    return dep[x] < dep[y] ? x : y;
}\end{lstlisting}
\subsection{树的直径}
\begin{lstlisting}
const int N = 1e5 + 10;

struct Edge {
    int v, w;
};
vector<Edge> g[N];
int dp[N][2];
int ans;

void dfs(int u, int fa) {
    for(auto e : g[u]) {
        int v = e.v;
        if(v == fa) continue;
        dfs(v, u);
        if(dp[v][0] + e.w > dp[u][0]) {
            dp[u][1] = dp[u][0];
            dp[u][0] = dp[v][0] + e.w;
        }
        else if(dp[v][0] + e.w > dp[u][1]) dp[u][1] = dp[v][0] + e.w;
    }
    ans = max(ans, dp[u][0] + dp[u][1]);
}\end{lstlisting}
\subsection{树的重心}
\begin{lstlisting}
const int N = 1e5 + 10;

struct Edge {
    int v, next;
}e[N * 2];

int cnt, head[N * 2];

int d[N], R[2], root;
int n;

int balance;

inline void add(int u, int v) {
    e[++cnt].v = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void DFS(int u, int fa) {
    d[u] = 1;
    int res = 0;
    for(int i = head[u] ; i != -1 ; i = e[i].next) {
        int v = e[i].v;
        if(v == fa) continue;
        DFS(v, u);
        d[u] += d[v];
        res = max(res, d[v]);
    }
    res = max(res, n - d[u]);
    if(res < balance) {
        R[root++] = u;
        balance = res;
    }
    else if(res == balance) {
        R[root++] = u;
    }
}

int main() {
    cin >> n;
    balance = n / 2;
    for(int i = 1;i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    DFS(1, 0);
    if(R[0]) cout << R[0] << endl;
    if(R[1]) cout << R[1] << endl;
}\end{lstlisting}
\subsection{树的最大匹配}
\begin{lstlisting}
// 设状态为f[u][1/0]表示以u为根的子树与儿子连边/不连边的最大匹配

const int N = 1e5 + 10;
vector<int> g[N];
int f[N][2];

void dfs(int u, int fa) {
    int mn = INF;
    for(auto v : g[u]) {
        if(v == fa) continue ;
        dfs(v, u);
        f[u][0] += f[v][1]; // u不与儿子连边，即加上所有与儿子连边的v
        f[u][1] += f[v][1]; // u与儿子连边，即加上一个不与儿子连边的v和其他所有与儿子连边的v
        mn = min(mx, f[v][1] - f[v][0]);
    }
    if(mn != INF) f[u][1] = dp[u][1] - mx + 1;
}
\end{lstlisting}
\subsection{树分治-点分治}
\begin{lstlisting}
// 题意: n个节点的树，存在边权，范围1e18
// 求任意两点之间点集的子集中两点之间路径异或和为0的个数
// u<v,u'<v',(u',v') ∈ path(u,v),求path(u', v')异或和==0

struct Edge {
    int to, nxt;
    ll w;
};
const int N = int(1e5 + 10);
const int M = N << 1;

struct Grahp {
    int head[N];
    Edge eg[M];
    int tot;

    void init(int n) {
        memset(head, -1, sizeof(int) * ++n);
    }

    inline void addEdge(int u, int v, ll w) {
        eg[tot] = {v, head[u], w};
        head[u] = tot++;
    }
} gh;

bool vis[N];
// q队列, fa祖先, sz是子树大小, smx是子树最大
int q[N], fa[N], sz[N], smx[N];

int froot(int s) {
    int l, r, mn = N, rt = 0;
    q[l = r = 1] = s;
    while (l <= r) {
        int u = q[l++];
        sz[u] = 1;
        smx[u] = 0;
        for (int i = gh.head[u]; ~i; i = gh.eg[i].nxt) {
            int v = gh.eg[i].to;
            if (v == fa[u] || vis[v]) continue;
            fa[v] = u;
            q[++r] = v;
        }
    }
    // 反向遍历所有点算size
    while (--l) {
        int u = q[l];
        int mx = max(smx[u], r - sz[u]);
        if (mx < mn) mn = mx, rt = u;
        if (l == 1) break; // 根节点没有fa
        sz[fa[u]] += sz[u];
        smx[fa[u]] = max(smx[fa[u]], sz[u]);
    }
    return rt;
}

// sons子树方向节点个数, val根到该节点异或和, gc边后继方向的节点个数
int sons[N], gc[M];
ll val[N];
ll ans = 0;
int n;

const int MOD = int(1e9 + 7);

ll nums[N];
int cnt[N];

void go(int s, int rt) {
    fa[s] = rt;
    val[s] = 0;
    int l, r;
    // 不计算s
    q[l = r = 0] = s;
    int m = 0;
    while (l <= r) {
        int u = q[l++];
        nums[m++] = val[u];
        for (int i = gh.head[u]; ~i; i = gh.eg[i].nxt) {
            int v = gh.eg[i].to;
            if (v == fa[u] || vis[v]) continue;
            fa[v] = u;
            q[++r] = v;
            val[v] = val[u] ^ gh.eg[i].w;
            // 这个点方向后面有多少点
            sons[v] = gc[i];
        }
    }
    sort(nums, nums + m);
    m = unique(nums, nums + m) - nums;
    mst(cnt, 0, m);
    // 遍历分支
    for (int j = gh.head[s]; ~j; j = gh.eg[j].nxt) {
        // 分支的根
        int du = gh.eg[j].to;
        if (vis[du]) continue;
        q[l = r = 1] = du;
        while (l <= r) {
            int u = q[l++];
            int k = lower_bound(nums, nums + m, val[u]) - nums;
            (ans += 1ll * sons[u] * cnt[k] % MOD) %= MOD;
            if (val[u] == 0) {
                (ans += 1ll * sons[u] * (n - gc[j]) % MOD) %= MOD;
            }
            for (int i = gh.head[u]; ~i; i = gh.eg[i].nxt) {
                int v = gh.eg[i].to;
                if (v == fa[u] || vis[v]) continue;
                q[++r] = v;
            }
        }
        // 增加这个方向的值
        while (--l) {
            int u = q[l];
            int k = lower_bound(nums, nums + m, val[u]) - nums;
            (cnt[k] += sons[u]) %= MOD;
        }
    }
}

void work(int u) {
    // 换根
    u = froot(u);
    vis[u] = true;
    go(u, 0);
    for (int i = gh.head[u]; ~i; i = gh.eg[i].nxt) {
        int v = gh.eg[i].to;
        if (vis[v]) continue;
        work(v);
    }
}

// 预处理边后继节点个数
int pdfs(int u, int f) {
    int fg_id = -1;
    int s = 1;
    for (int i = gh.head[u]; ~i; i = gh.eg[i].nxt) {
        int v = gh.eg[i].to;
        if (v == f) { // 记录父边ID
            fg_id = i;
            continue;
        }
        int c = pdfs(v, u);
        gc[i] = c;
        s += c;
    }
    // 存在父边
    if (~fg_id) gc[fg_id] = n - s;
    return s;
}

void solve() {
    while (cin >> n) {
        gh.init(n);
        for (int i = 2; i <= n; i++) {
            int u, v;
            ll w;
            u = i;
            cin >> v >> w;
            gh.addEdge(u, v, w);
            gh.addEdge(v, u, w);
        }
        mst(vis, false, n + 1);
        pdfs(1, 0);
        ans = 0;
        work(1);
        cout << ans << endl;
    }
}
\end{lstlisting}
\subsection{树上dsu_维护路径信息}
\begin{lstlisting}
const int N = 1e5 + 10;

vector<int> g[N];
int siz[N], dep[N], son[N], dfn[N], nodeof[N], tim;

void calc(int u, int w) {
    // ....对u这一节点进行单独处理
    if(w > 0) // ....计算贡献
    else // ....撤销影响
}

void dfs1(int u, int fa) {
    dep[u] = dep[fa] + (siz[u] = 1);
    nodeof[dfn[u] = ++tim] = u;
    for(auto v : g[u]) {
        if(v == fa) continue ;
        dfs1(v, u);
        siz[u] += siz[v];
        if(!son[u] || siz[v] > siz[son[u]]) son[u] = v;
    }
}

void dfs2(int u, int fa, bool keep) {
    for(auto v : g[u]) {
        if(v == fa || v == son[u]) continue ;
        dfs2(v, u, 0);
    }
    if(son[u]) {
        dfs2(son[u], u, 1);
    }
    for(auto v : g[u]) {
        if(v == fa || v == son[u]) continue ;
        for(int j = 0;j < siz[v]; j++) {
            // ....更新答案
        }
        for(int j = 0;j < siz[v]; j++) {
            calc(nodeof[dfn[v] + j], 1);
        }
    }
    calc(u, 1);
    // ....更新答案
    if(!keep) {
        for(int i = 0;i < siz[u]; i++) calc(nodeof[dfn[u] + i], -1);
    }
}

int main() {
    int n; cin >> n;
    for(int i = 1;i < n; i++) {
        int u, v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs1(1, 0);
    dfs2(1, 0, 0);
}\end{lstlisting}
\subsection{树上dsu_维护子树信息}
\begin{lstlisting}
const int N = 2e5 + 10;

vector<int> g[N];

int siz[N], son[N], col[N];
int ans[N], cnt[N];
bool vis[N];
int maxx, sum;
// maxx为每棵子树里出现最多的颜色，sum为编号和

void calc(int u, int fa, int val) {
    /*
    针对不同问题，采取的操作
    */
    else if(val > 0 && cnt[col[u]] == maxx) sum += col[u];
    for(auto v : g[u]) {
        if(v != fa && !vis[v]) calc(v, u, w);
    }
}

void dfs1(int u, int fa) {
    siz[u] = 1;
    for(auto v : g[u]) {
        if(v == fa) continue ;
        dfs1(v, u);
        siz[u] += siz[v];
        if(!son[u] || siz[v] > siz[son[u]]) son[u] = v;
    }
}

void dfs2(int u, int fa, bool keep) {
    for(auto v : g[u]) {
        if(v != fa && v != son[u]) {
            dfs2(v, u, 0);
        }
    }
    if(son[u]) {
        dfs2(son[u], u, 1);
        vis[son[u]] = 1;
    }
    calc(u, fa, 1);
    ans[u] = sum;
    if(son[u]) vis[son[u]] = 0;
    if(!keep) {
        calc(u, fa, -1);
        maxx = sum = 0;
    }
}

int main() {
    int n; cin >> n;
    for(int i = 1;i <= n; i++) cin >> col[i];
    for(int i = 1;i < n; i++) {
        int u,  v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs0(1, 0);
    dfs1(1, 0, false);
    for(int i = 1;i <= n; i++) cout << ans[i] << endl;
}\end{lstlisting}
\subsection{树上K祖先}
\begin{lstlisting}
//倍增KFA, 空间大点, 但是好写
vector<int> g[N];

int anc[N][20];
void dfs(int u, int fa) {
    anc[u][0] = fa;
    for (int i = 1; i <= 19; i++) anc[u][i] = anc[anc[u][i - 1]][i - 1];
    for (auto &v: g[u])
        if (v != fa) dfs(v, u);
}

int kthFa(int u, int k) {
    int bit = 0;
    while (k) {
        if (k & 1) u = anc[u][bit];
        k >>= 1;
        bit++;
    }
    return u;
}


//树剖KFA
int siz[N], son[N], dep[N], fa[N], top[N];
int id[N], nodeOf[N], cnt;
void dfs(int u, int par) {
    dep[u] = dep[fa[u] = par] + (siz[u] = 1);
    for (auto &v: g[u])
        if (v != par) {
            dfs(v, u);
            siz[u] += siz[v];
            if (!son[u] || siz[v] > siz[son[u]])
                son[u] = v;
        }
}

void dfs2(int u, int topf) {
    nodeOf[id[u] = ++cnt] = u, top[u] = topf;
    if (!son[u]) return;
    dfs2(son[u], topf);
    for (auto &v: g[u])
        if (v != fa[u] && v != son[u]) dfs2(v, v);
}

int kthFa(int u, int k) {
    while (k >= id[u] - id[top[u]] + 1 && u) {
        k -= id[u] - id[top[u]] + 1;
        u = fa[top[u]];
    }
    return nodeOf[id[u] - k];
}\end{lstlisting}
\subsection{虚树}
\begin{lstlisting}
//虚树可以处理多次询问, 并且每次询问只需要树上的K个关键点
//建立的虚树能保证点数 < 2 * K
//如果对虚树做dp, 总体复杂度和∑K有关
//考虑dp的时候, 需要同时考虑非关键点对答案的影响

int n;

struct edge {
    int nxt, to;
} e[N << 1];
int head[N], tot;
void add(int u, int v) { e[++tot] = edge{ head[u], v }, head[u] = tot;}

int dep[N], fa[N], topfa[N], siz[N], son[N], dfn[N], cnt;
void dfs(int u, int par) {
    dep[u] = dep[fa[u] = par] + (siz[u] = 1);
    int max_son = -1;
    for (int i = head[u], v; i; i = e[i].nxt)
        if ((v = e[i].to) != par) {
            dfs(v, u);
            siz[u] += siz[v];
            if (max_son < siz[v]) son[u] = v, max_son = siz[v];
        }
}
void dfs2(int u, int topf) {
    topfa[u] = topf, dfn[u] = ++cnt;
    if (!son[u]) return;
    dfs2(son[u], topf);
    for (int i = head[u], v; i; i = e[i].nxt)
        if ((v = e[i].to) != fa[u] && v != son[u]) dfs2(v, v);
}
int LCA(int x, int y) {
    while (topfa[x] != topfa[y]) {
        if (dep[topfa[x]] < dep[topfa[y]]) swap(x, y);
        x = fa[topfa[x]];
    }
    return dep[x] < dep[y] ? x : y;
}
int getDis(int x, int y) { return dep[x] + dep[y] - 2 * dep[LCA(x, y)]; }

//建立虚树
int tag[N];//tag[u] = 1 <=> 关键点
vector<int> g[N];//虚树边
void add_edge(int u, int v) { g[u].push_back(v); }
int st[N], top, rt;//rt为虚树根
void insert(int u) {
    if (top == 1) {
        st[++top] = u;
        return;
    }
    int lca = LCA(u, st[top]);
    if (lca != st[top]) {
        while (top > 1 && dfn[st[top - 1]] >= dfn[lca])
            add_edge(st[top - 1], st[top]), top--;
        if (lca != st[top]) add_edge(lca, st[top]), st[top] = lca;
    }
    st[++top] = u;
}
bool cmp(const int &x, const int &y) { return dfn[x] < dfn[y]; }
void build(vector<int> &v) {
    st[top = 1] = rt;
    sort(v.begin(), v.end(), cmp);
    for (auto &i: v) {
        tag[i] = 1;
        if (i != rt) insert(i);
    }
    while (top > 1) add_edge(st[top - 1], st[top]), top--;
}


void dp(int u) {
    //...
}
void clear(int u) {//清空虚树边和标记, 也可以和dp合并
    for (auto &v: g[u]) clear(v);
    g[u].clear(); tag[u] = 0;
}
void solve() {
    //...
    dp(rt); clear(rt);
    //...
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        int u, v; scanf("%d%d", &u, &v);
        add(u, v); add(v, u);
    }
    //此处距离为1, 所以用dep替代dis, dis[fa[rt] = 0] = -1
    dep[0] = -1, rt = 1;
    dfs(rt, 0); dfs2(rt, rt);


    int Q; scanf("%d", &Q);
    while (Q--) {
        int K; scanf("%d", &K);//读取关键点
        for (int i = 1; i <= K; i++) scanf("%d", &a[i]);
        //构建虚树
        build(a);
        solve();
    }

    return 0;
}\end{lstlisting}
\subsection{LCT}
\begin{lstlisting}
int ch[N][2], fa[N], rev[N], siz[N];//基本内容
int sum[N], val[N], tag[N];//另外要维护的
#define lc  ch[u][0]
#define rc  ch[u][1]
#define identify(u) (ch[fa[u]][1] == u)
#define isRoot(u)   (u != ch[fa[u]][0] && u != ch[fa[u]][1])
void flip(int u) { swap(lc, rc); rev[u] ^= 1; }
void push_up(int u) {
    siz[u] = siz[lc] + siz[rc] + 1;
    //...
}
void push_down(int u) {
    if (rev[u]) {
        if (lc) flip(lc);
        if (rc) flip(rc);
        rev[u] = 0;
    }
    //...
}
void update(int u) {//当前点之上的所有点都push_down
    if (!isRoot(u)) update(fa[u]);
    push_down(u);
}
void rotate(int u) {
    int f = fa[u], fc = identify(u);
    int g = fa[f], gc = identify(f);
    int uc = fc ^ 1, c = ch[u][uc];
    if (!isRoot(f))
        ch[g][gc] = u; fa[u] = g;
    ch[f][fc] = c, fa[c] = f;
    ch[u][uc] = f, fa[f] = u;
    push_up(f); push_up(u);
}
void splay(int u) {//将u变为u所在的Splay的根
    update(u);
    for (int f; f = fa[u], !isRoot(u); rotate(u))
        if (!isRoot(f)) rotate(identify(f) ^ identify(u) ? u : f);
}
int access(int u) {//将(rt, u)之间的路径变为实链
    int pre = 0;
    for (; u; u = fa[pre = u])
        splay(u), rc = pre, push_up(u);
    return pre;
}
void makeRoot(int u) {//将u变为整棵树的根(注意:不一定是当前splay的根)
    u = access(u);
    flip(u);
}
int findRoot(int u) {
    access(u), splay(u);
    while (lc) push_down(u), u = lc;
    splay(u);
    return u;
}
void link(int u, int v) {
    makeRoot(u); splay(u);
    if (findRoot(v) != u) fa[u] = v;
}
void split(int u, int v) {
    makeRoot(u);
    access(v); splay(v);//加了这个就将v变为splay的根
}
void cut(int u, int v) {
    makeRoot(u); splay(u);
    if (findRoot(v) == u && fa[v] == u && !ch[v][0]) {
        fa[v] = ch[u][1] = 0;
        push_up(u);
    }
}
void fix(int u, int k) {
    splay(u); val[u] = k;
}\end{lstlisting}
\clearpage\section{数学}
\subsection{快速幂}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

ll quick_pow(ll a, ll b, ll mod) {
    ll ans = 1;
    while(b) {
        if(b & 1) ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans % mod;
}

// 快速乘和中国剩余定理搭配更香哦
ll ksc(ll a, ll b, ll mod)   {
    ll ans = 0;
    while(b > 0) {
        if(b & 1) {
            ans = (ans + a) % mod;
        }
        a = (a << 1) % mod;
        b >>= 1;
    }
    return ans;
}

ll quick_mul(ll a,ll b,ll c) {
    return (a * b - (ll)((ld)a * b / c) * c + c) % c;
}


const int N = 100 + 10;

int n;

struct Martix {
    ll a[N][N];
    Martix operator * (const Martix &rhs) const {
        Martix ans;
        mem(ans.a, 0);
        for(int i = 1;i <= n; i++) {
            for(int j = 1;j <= n; j++) {
                for(int k = 1;k <= n; k++) {
                    ans.a[i][j] = (ans.a[i][j] + a[i][k] * rhs.a[k][j]) % mod;
                }
            }
        }
        return ans;
    }
};

Martix quick_pow(Martix a, ll b) {
    Martix ans; mem(ans.a, 0);
    for(int i = 1;i <= n; i++) ans.a[i][i] = 1;
    while(b) {
        if(b & 1) ans = a * ans;
        a = a * a;
        b >>= 1;
    }
    return ans;
}\end{lstlisting}
\subsection{光速幂}
\begin{lstlisting}

ll v_pow(ll a, ll b) {
    ll ans = 1;
    ll base = 65536, k = 1;
    while(1) {
        if((b % (k * base)) / k == 0) break;
        ans = ans * quick_pow(a, (b % (k * base)) / k) % mod;
        a = quick_pow(a, base) % mod;
        k = k * base;
    }
    return ans;
}
\end{lstlisting}
\subsection{EX_GCD}
\begin{lstlisting}
typedef long long ll;

ll ex_gcd(ll a, ll b, ll &x, ll &y) {
    ll res, t;
    if(!b) {
        x = 1;
        y = 0;
        return a;
    }
    res = ex_gcd(b, a % b, x, y);
    t = x;
    x = y;
    y = t - (a / b) * y;
    return res;
}

ll INV(ll a, ll mod) {
    ll x, y;
    ll d = ex_gcd(a, mod, x, y);
    return d ? (x % mod + mod) % mod : -1;
}
 
ll solve_ex_gcd(ll a, ll b, ll c, ll &x, ll &y) {
    ll d = ex_gcd(a, b, x, y);
    if(c % d)
    {
        x = -1;
        y = -1;
        return -1;
    }
    x *= (c / d);
    b = abs(b / d);
    x = (x % b + b) % b;
    y = (c - a * x) / (b * d);
    return 0;
}

int main() {
    ll x, y;
    cout << solve_ex_gcd(2, 3, 4, x, y) << endl; 
}
\end{lstlisting}
\subsection{素数筛}
\begin{lstlisting}
const int N = 1e6 + 10;
bool is_prime[N]; //is_prime[i]为true时，i为素数
int prime[N], cnt = 0;

void sieve(int n) {
    is_prime[0] = is_prime[1] = 1; //0和1都不是素数
    for(int i = 2;i <= sqrt(n); i++) {
        if(!is_prime[i]) {
            for(int j = 2 * i;j <= n; j += i) {
                is_prime[j] = 1; //删除所有的素数的倍数
            }
        }
    }
}
    

void euler() {
    is_prime[0] = is_prime[1] = 1;
    for(int i = 2;i < N; i++) {
        if(!is_prime[i]) {
            prime[++cnt] = i;
        }
        for(int j = 1;j <= cnt && prime[j] * i < N; j++) {
            is_prime[i * prime[j]] = 1;
            if(i % prime[j] == 0) break;
        }
    }
}
\end{lstlisting}
\subsection{整除分块}
\begin{lstlisting}
int calc(int n, int m) {
    //\sum_{i = 1} ^ {m} n / i
    //向下取整
    for (int l = 1, r; l <= m; l = r + 1) {
        if (n / l) r = min(m, n / (n / l));
        else r = m;
        //[l, r]之间的 n / l 都相等
    }

    //向上取整
    for (int l = 1, r; l <= m; l = r + 1) {
        int t = (n + l - 1) / l;
        if (t == 1) r = m;
        else r = min(m, (n - 1) / (t - 1));
        //[l, r]之间的 (n + l - 1) / l 都相等
    }

}
\end{lstlisting}
\subsection{线性递推逆元}
\begin{lstlisting}
// 乘法逆元的线性递推，复杂度O(n)

typedef long long ll;

ll inv[3000005] = {0 , 1}; //n等于1时，关于mod的逆元就为1

int main()
{
    ll n, mod;
    cin >> n >> mod;
    cout << 1 << endl;
    for(int i = 2;i <= n; i++)
    {
        inv[i] = mod - (mod / i) * inv[mod % i] % mod;
        cout << inv[i] << endl;
    }
    return 0;
}\end{lstlisting}
\subsection{线性求任意n个数的逆元}
\begin{lstlisting}
typedef long long ll;

ll a[10005]; // n个数
ll s[10005]; // 前缀积
ll invs[10005]; // 前缀积的逆元
ll inv[10005]; // a[i]的逆元

ll qucik_pow(ll a, ll b, ll mod) ;

void Line_INV() {
    s[0] = 1;
    ll p;
    for(int i = 1;i <= n; i++)
        cin >> a[i]; // 任意n个数
    cin >> p;
    for (int i = 1; i <= n; ++i) 
        s[i] = s[i - 1] * a[i] % p;
    sv[n] = quick_pow(s[n], p - 2);
    for (int i = n; i >= 1; --i) 
        sv[i - 1] = sv[i] * a[i] % p;
    for (int i = 1; i <= n; ++i) 
        inv[i] = sv[i] * s[i - 1] % p;
}\end{lstlisting}
\subsection{算术基本定理}
\begin{lstlisting}
ll get_Count(ll n) {
    ll ans = 1;
    for(int i = 2;i * i <= n; i++) {
        if(n % i == 0) {
            int a = 0;
            while(n % i == 0) {
                a++;
                n /= i;
            }
            ans *= (a + 1);
        }
    }
    if(n > 1)  ans *= 2;
    return ans;
}

ll get_Sum(ll n) {
    ll ans = 1;
    for(int i = 2;i * i <= n; i++) {
        if(n % i == 0) {
            ll a = 1;
            while(n % i == 0) {
                n /= i;
                a *= i;
            }
            ans = ans * (a * i - 1) / (i - 1);
        }
    }
    if(n > 1) ans *= (n + 1);
    return ans;
}
\end{lstlisting}
\subsection{筛phi}
\begin{lstlisting}
int is_prime[N], prime[N], cnt, phi[N];
void makePhi() {
    phi[1] = 1, cnt = 0;
    for (int i = 2; i < N; i++) {
        if (!is_prime[i]) prime[++cnt] = i, phi[i] = i - 1;
        for (int j = 1; j <= cnt && i * prime[j] < N; j++) {
            is_prime[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            else phi[i * prime[j]] = phi[i] * phi[prime[j]];
        }
    }
}
\end{lstlisting}
\subsection{筛mobius}
\begin{lstlisting}
const int N = 1e5 + 10;
bool is_prime[N];
int prime[N], mu[N], cnt;

void makeMobius() {
    mu[1] = 1; is_prime[0] = is_prime[1] = true;
    for(int i = 2;i < N; i++) {
        if (!is_prime[i]) {
            mu[i] = -1;
            prime[++cnt] = i;
        }
        for (int j = 1; j <= cnt && i * prime[j] < N; j++) {
            is_prime[i * prime[j]] = true;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
}
\end{lstlisting}
\subsection{筛积性函数}
\begin{lstlisting}
//只需要计算f(p ^ k)即可
//其余的都可以通过积性函数的性质来计算

int vis[N], prime[N], num;
int f[N], low[N];

void makeF(int siz) {//f为积性函数
    num = 0, low[1] = f[1] = 1;
    for (int i = 2; i <= siz; i++) {
        if (!vis[i]) prime[++num] = i, low[i] = i, f[i] = ...;//这里是f(p)的答案
        for (int j = 1; j <= num && i * prime[j] <= siz; j++) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                low[i * prime[j]] = low[i] * prime[j];
                if(low[i] == i) {//i = prime[j] ^ k
                    //只需要这里算一下
                    //考虑 p ^ 1 , p ^ 2, p ^ 3...
                }
                else f[i * prime[j]] = 1ll * f[i / low[i]] * f[prime[j] * low[i]] % mod;
                break;
            }
            low[i * prime[j]] = prime[j];
            f[i * prime[j]] = 1ll * f[i] * f[prime[j]] % mod;
        }
    }
}

\end{lstlisting}
\subsection{欧拉函数}
\begin{lstlisting}
// 求解单个正整数的欧拉函数
int Get_phi(int n) {
    int ans = n;
    for(int i = 2;i * i <= n; i++) {
        if(n % i == 0) {
            ans = ans - ans / i;
            while(n % i == 0)
                n /= i;
        }
    }
    if(n > 1)
        ans = ans - ans / n;
    return ans;
}

// 埃拉托斯特尼筛求欧拉函数
int phi[10005];

void Euler_sieve(int n) {
    phi[1] = 1;
    for(int i = 2;i <= n; i++) {
        if(!phi[i]) {
            for(int j = i;j <= n; j += i)    {
                if(!phi[j])
                    phi[j] = j;
                phi[j] = phi[j] / i * (i - 1); 
            }
        }
    }
}

// 欧拉筛求欧拉函数

const int N = 5e6 + 10;
bool is_prime[N];
int prime[N], phi[N], tot;

void Euler() {
    phi[1] = 1; is_prime[1] = true;
    for(int i = 2;i < N; i++){
        if(!is_prime[i]) {
            phi[i] = i - 1;
            prime[++tot] = i;
        }
        for(int j = 1;j <= tot && i * prime[j] < N; j++){
            is_prime[i * prime[j]] = true;
            if(i % prime[j]) {
                phi[i * prime[j]] = phi[i] * (prime[j] - 1);
            }
            else{
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
        }
    }
}\end{lstlisting}
\subsection{原根}
\begin{lstlisting}
typedef long long ll;

vector<ll> YG;
ll p, n; // p是模数，n是p的欧拉函数值

ll gcd(ll a, ll b) {
    return b ? gcd(b, a % b) : a;
}

ll quick_pow(ll a, ll b, ll p) ; 

ll phi(ll n) {
    ll ans = n;
    for(int i = 2;i * i <= n; i++) {
        if(n % i == 0) {
            ans = ans - ans / i;
            while(n % i == 0) {
                n /= i;
            }
        }
    }
    if(n > 1)
        ans = ans - ans / n;
    return ans;
}

vector<ll> PrimeFac(ll n) { // n的素因子
    vector<ll> fac;
    fac.clear();
    for(ll i = 2;i * i <= n; i++) {
        if(n % i == 0) {
            fac.push_back(i);
            while(n % i == 0)
                n /= i;
        }
    }
    if(n > 1)
        fac.push_back(n);
    return fac;
}

bool is_Protogen(ll p) { // 原根p = 2、4、p^k、2*p^k(p为非2的质数，k为任意数) 
    if(p == 2 || p == 4) return true;
    if(p <= 1 || p % 4 == 0) return false;
    ll num = 0;
    while(p % 2 == 0) // 2的倍数先筛掉
        p /= 2;
    for(int i = 3;i * i <= p; i++) { // p只能是一个非2的素数的倍数构成，否则没有原根
        if(p % i == 0) {
            num++;
            while(p % i == 0)
                p /= i;
        }
    }
    if(p > 1) num++;
    if(num == 1) return true;
    return false;
}

ll Protogen(ll p) {
    if(!is_Protogen(p)) // 先判断是否存在原根
        return -1;
    n = phi(p); 
    if(p == 2) return 1;
    if(p == 3) return 2;
    if(p == 4) return 3;
    vector<ll> fac = PrimeFac(n); // f(p)的素因子
    for(int i = 2;i <= p - 1; i++) {
        if(gcd(i, p) != 1) // n是模p的欧拉函数值，i要和n互质
            continue;
        bool flag = true; 
        for(ll j = 0;j < fac.size(); j++) {
            if(quick_pow(i, n / fac[j] , p) == 1)
                flag = 0;
        }
        if(flag) // i就是原根
            return i;
    }
    return -1;
}

void Sum_Protogen(ll k) { // 找出n的所有原根
    YG.push_back(k);
    for(int i = 2;i < n; i++) {
        if(gcd(i, n) == 1) // i要与f(n)互质
            YG.push_back(quick_pow(k, i, p));
    }
}

int main() {
    cin >> p;
    ll k = Protogen(p); // p的原根
    cout << k << endl;
    Sum_Protogen(k);
    for(int i = 0;i < YG.size(); i++) {
        cout << YG[i] << " ";
    }
    cout << endl;
    return 0;
}\end{lstlisting}
\subsection{原根表}
\begin{lstlisting}
mod                                         原根
r*2^k+1   r               k              g
3	1	1	2
5	1	2	2
17	1	4	3
97	3	5	5
193	3	6	5
257	1	8	3
7681	15	9	17
12289	3	12	11
40961	5	13	3
65537	1	16	3
786433	3	18	10
5767169	11	19	3
7340033	7	20	3
23068673	11	21	3
104857601	25	22	3
167772161	5	25	3
469762049	7	26	3
998244353	119	23	3   这个数常用
1004535809	479	21	3   加起来不会爆int
2013265921	15	27	31
2281701377	17	27	3    这个数平方刚好不会爆ll
3221225473	3	30	5
75161927681	35	31	3
77309411329	9	33	7
206158430209	3	36	22
2061584302081	15	37	7
2748779069441	5	39	3
6597069766657	3	41	5
39582418599937	9	42	5
79164837199873	9	43	5
263882790666241	15	44	7
1231453023109121	35	45	3
1337006139375617	19	46	3
3799912185593857	27	47	5
4222124650659841	15	48	19
7881299347898369	7	50	6
31525197391593473	7	52	3
180143985094819841	5	55	6
1945555039024054273	27	56	5
4179340454199820289	29	57	3
\end{lstlisting}
\subsection{阶乘逆元}
\begin{lstlisting}
const int N = 5e6 + 10;
const ll mod = 1e9 + 7;

ll F[N], invn[N], invF[N];

void Init() {
    F[0] = F[1] = invn[0] = invn[1] = invF[0] = invF[1] = 1;
    for(int i = 2;i < N; i++){
        F[i] = F[i - 1] * i % mod;
        invn[i] = (mod - mod / i) * invn[mod % i] % mod;
        invF[i] = invF[i - 1] * invn[i] % mod;
    }
}
\end{lstlisting}
\subsection{常见积性函数}
\begin{lstlisting}
//phi
//phi[i * j] = phi[i] * phi[j] * gcd(i, j) / phi[gcd(i, j)]

// d
// d[i * j] = \sum_{x|i} * \sum_{y|j} * [gcd(x, y) = 1]

\end{lstlisting}
\subsection{Miller_Rabin}
\begin{lstlisting}
// 二次探测定理：对素数p,满足x^2≡1(modp)的小于p的正整数解x只有1或p−1.

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 7;
const int times = 10;

ll ksc(ll a, ll b, ll mod)  {
    ll ans = 0;
    while(b > 0) {
        if(b & 1) {
            ans = (ans + a) % mod;
        }
        a = (a << 1) % mod;
        b >>= 1;
    }
    return ans;
}

ll quick_pow(ll a, ll b, ll mod) {
    ll ans = 1, base = a;
    while(b != 0) {
        if(b & 1) {
            ans = ans * base % mod;
        }
        base = base * base % mod;
        b >>= 1;
    }
    return ans;
}

bool Miller_Pabin(ll n)//Miller测试的主体结构
{
    if(n < 2) return false;
    if(n == 2) return true;
    if(n & 1 == 0) return false;//对于偶数的优化
    ll k = 0,u = n - 1;//p为Miller测试的k，u为Miller测试的m
    
    while(u & 1 == 0){ // 把x拆成u*2^k
        u >>= 1;
        k++;
    }
    srand(time(NULL));

    ll x, pre; // pre为上次探测的x的值

    for(int i = 1;i <= times; i++) {
        x = rand() % (n - 1) + 1;
        x = quick_pow(x, u, n); // 先求出x^u(mod n)
        pre = x;
        for(int j = 1;j <= k; j++) {
            x = ksc(x, x, n);
            if(x == 1 && pre != 1 && pre != n - 1)
                return false;
            pre = x;
        }
        if(x != -1)
        return false;
    }
    return true;
}
 
int main() {
    ll n; cin >> n;
    cout << (Miller_Pabin(n) ? "Prime" : "Not a Prime") << endl;
}\end{lstlisting}
\subsection{二次剩余}
\begin{lstlisting}
typedef long long ll;

typedef struct{
    ll x, y; // 把求出来的w作为虚部，则为a + bw
}num;

ll quick_pow(ll a, ll b, ll p) {
    ll ans = 1;
    while(b) {
        if(b & 1) ans = ans * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return ans % p;
}


num num_mul(num a, num b, ll w, ll p) {// 复数乘法
    num ans = {0, 0};
    ans.x = (a.x * b.x % p + a.y * b.y % p * w % p + p) % p;
    ans.y = (a.x * b.y % p + a.y * b.x % p + p) % p;
    return ans;
} 

ll num_pow(num a, ll b, ll w, ll p) { // 复数快速幂
    num ans = {1, 0};
    while(b) {
        if(b & 1)
            ans = num_mul(ans, a, w, p);
        a = num_mul(a, a, w, p);
        b >>= 1;
    }
    return ans.x % p;
}

ll legendre(ll a, ll p) { // 勒让德符号 = {1, -1, 0}
    return quick_pow(a, (p - 1) >> 1, p);
}

ll Cipolla(ll n, ll p) {// 输入a和p，是否存在x使得x^2 = a (mod p)，存在二次剩余返回x，存在二次非剩余返回-1     注意：p是奇质数
    n %= p;
    if(n == 0)
        return 0;
    if(p == 2)
        return 1;
    if(legendre(n, p) + 1 == p) // 二次非剩余
        return -1;
    
    ll a, w; 
    
    while(true) {// 找出a，求出w，随机成功的概率是50%，所以数学期望是2
        a = rand() % p;
        w = ((a * a - n) % p + p) % p;
        if(legendre(w, p) + 1 == p) // 找到w，非二次剩余条件
            break;
    }
    num x = {a, 1};   
    return num_pow(x, (p + 1) >> 1, w, p) % p; // 计算x,一个解是x，另一个解是p-x，这里的w其实要开方，但是由拉格朗日定理可知虚部为0，所以最终答案就是对x的实部用快速幂求解
}

int main()
{
    ll n, p;
    cin >> n >> p;
    srand((unsigned)time(NULL));
    cout << Cipolla(n, p) << endl;
    return 0;
}\end{lstlisting}
\subsection{BSGS}
\begin{lstlisting}
// 求解a^x = b (mod c)，要求gcd(a, c) = 1， 不要求p为素数, x的范围是0 <= x <= p-1

#include <iostream>
#include <map>

using namespace std;
typedef long long ll;

const int maxn = 5e5 + 10;

int Hash[maxn], id[maxn], head[maxn], Next[maxn], cnt; // 链式前向星，比map快log，但是需要极大空间

struct HASH{
    void insert(ll x, ll y) {
        ll k = x % maxn;
        Hash[cnt] = x;
        id[cnt] = y;
        Next[cnt] = head[k];
        head[k] = cnt++;
    }

    ll query(ll x) {
        for(int i = head[x % maxn]; i != -1 ; i = Next[i]){
            if(Hash[i] == x)
                return id[i];
        }
        return -1;
    }
}HASH;

ll BSGS(ll a, ll b, ll c) {
    a %= c;
    b %= c;
    cnt = 1;
    if(b == 1)  return 0; 

    memset(head, -1, sizeof(head));

    ll m = ceil(sqrt((double)c)); // 向上取整
    ll x = 1, p = 1;

    for(ll j = 0;j < m; j++, p = p * a % c) {// 0 ~ m - 1
        HASH.insert(p * b % c, j); // 先枚举右边，把(b*a^j, j)放入hash中
    }

    for(ll i = 1, j ;i <= m; i++) { // 枚举a^im
        x = x * p % c;
        if((j = HASH.query(x)) != -1)
            return i * m - j; // 找到相匹配的哈希值
    }
    return -1;
}

int main() {
    ll a, b, c;
    cin >> a >> b >> c;
    cout << BSGS(a, b, c) << endl;
}
\end{lstlisting}
\subsection{EX_BSGS}
\begin{lstlisting}
// a和c不互质
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

ll gcd(ll a, ll b) {
    return b ? gcd(b, a % b) : a;
}

ll EX_BSGS(ll a, ll b, ll c) {
    a %= c;
    b %= c;

    if(b == 1) return 0;

    ll k = 0, tmp = 1, d;
    while(true) {
        d = gcd(a, c);
        if(d == 1)
            break;
        if(b % d) // 无解
            return -1;
        b /= d; c /= d;
        tmp = tmp * (a / d) % c;
        k++;
        if(tmp == b)
            return k;
    }

    map<ll, ll> mp;
    mp.clear();

    ll m = ceil(sqrt((double)c)); // 向上取整
    ll x = 1, p = 1;
    for(ll j = 0;j < m; j++, p = p * a % c) {// 0 ~ m - 1
        mp[p * b % c] = j;
    }

    x = tmp % c;

    for(ll i = 1 ;i <= m; i++) { // 枚举a^im
        x = x * p % c;
        if(mp[x]) {
            return k + i * m - mp[x];
        }
    }
    return -1;
}

int main() {
    ll a, b, c;
    cin >> a >> b >> c;
    cout << EX_BSGS(a, b, c) << endl;
}
\end{lstlisting}
\subsection{CRT}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
ll m[10005], a[10005], n; //a是余数，b是模数

void exgcd(ll a, ll b, ll &x, ll &y) {
    if(b == 0) {
        x = 1;
        y = 0;
        return;
    }
    exgcd(b, a % b , y , x);
    y -= a / b * x;
}

ll INV(ll a, ll mod) {
    ll x, y;
    exgcd(a , mod , x , y);
    x = (x % mod + mod) % mod;
    return x;
}

ll CRT() {
    ll ans = 0, M = 1;
    for(ll i = 1;i <= n; i++) {
        M *= m[i]; // M是所有除数的乘积
    }
    for(ll i = 1;i <= n; i++) {
        ll mm = M / m[i];
        ll ret = INV(mm , m[i]); // 先求逆元
        ans = (ans + a[i] * mm % M * ret % M) % M;
/*
 
 ans = (ans + quick_mul(quick_mul(m , ret , M) , b[i] , M)) % M;
 利用快速乘防止爆longlong 
        
 */
    }
    return (ans + M) % M;
}

int main() {
    ll ans = 0;
    scanf("%lld",&n);
    for(ll i = 1;i <= n; i++) {
        scanf("%lld%lld",&m[i],&a[i]);
        a[i] = (a[i] % m[i] + m[i]) % m[i];// 防止b[i]为负
    }
    ans = CRT(); // 精髓
    printf("%lld",ans);
    return 0;
}\end{lstlisting}
\subsection{EX_CRT}
\begin{lstlisting}
#include <iostream>

using namespace std;

typedef long long ll;

ll c[100005], m[100005], n; 

ll ksc(ll a, ll b, ll mod) {
    ll ans = 0;
    while(b > 0) {
        if(b & 1) {
            ans = (ans + a) % mod;
        }
        a = (a << 1) % mod;
        b >>= 1;
    }
    return ans;
}

ll gcd(ll a, ll b) {
    return b ? gcd(b, a % b) : a;
}

ll ex_gcd(ll a, ll b, ll &x, ll &y) {
    ll res, t;
    if(!b) {
        x = 1;
        y = 0;
        return a;
    }
    res = ex_gcd(b, a % b, x, y);
    t = x;
    x = y;
    y = t - (a / b) * y;
    return res;
}

ll INV(ll a, ll mod) {
    ll x, y;
    ll d = ex_gcd(a, mod, x, y);
    return d ? (x % mod + mod) % mod : -1;
}

ll EX_CRT() {
    ll x, y;
    ll ans = c[1];
    ll M = m[1];
    for(int i = 2; i <= n; i++) {
        ll C = ((c[i] - ans) % m[i] + m[i]) % m[i];
        ll T = ex_gcd(M, m[i], x, y);
        if((c[i] - ans) % T)
            return -1;
        x = ksc(x, C / T, m[i] / T);
        ans += M * x;
        M *= (m[i] / T);
        ans = (ans % M + M) % M;
    }
    return ans;
}

/*
ll EX_CRT() // 便于理解
{
    for(int i = 2;i <= n; i++)
    {
        ll M1 = m[i - 1], M2 = m[i], C1 = c[i - 1], C2 = c[i];
        ll T = gcd(M1, M2); // gcd(M1, M2)
        if((C2 - C1) % T) // 无解
            return -1;
        m[i] = (M1 * M2) / T; // 合并后新同余方程的模
        c[i] = INV(M1 / T, M2 / T) * (C2 - C1) / T % (M2 / T) * M1 + C1; // 可快速乘优化
        c[i] = (c[i] % m[i] + m[i]) % m[i]; // 合并后新同余方程的余
    }
    return c[n];
}
*/

int main()
{
    cin >> n;
    for(int i = 1;i <= n; i++)
    cin >> c[i] >> m[i];
    cout << EX_CRT() << endl;
}\end{lstlisting}
\subsection{Lucas}
\begin{lstlisting}
namespace Comb {
    const int N = 1e6 + 10;
    ll F[N], invF[N], inv[N];

    void init() {
        F[0] = F[1] = invF[0] = invF[1] = inv[0] = inv[1] = 1;
        for (int i = 2; i < N; i++) {
            F[i] = F[i - 1] * i % mod;
            inv[i] = (mod - mod / i) * inv[mod % i] % mod;
            invF[i] = invF[i - 1] * inv[i] % mod;
        }
    }

    ll C(ll m, ll n) {
        if (m < 0 || n < 0 || n > m) return 0;
        ll ans = F[m];
        ans = ans * invF[n] % mod;
        ans = ans * invF[m - n] % mod;
        return ans;
    }

    ll Lucas(ll m, ll n) {
        return n ? Lucas(m / mod, n / mod) * C(m % mod, n % mod) % mod : 1;
    }

}\end{lstlisting}
\subsection{EX_Lucas}
\begin{lstlisting}
// p不为质数，利用中国剩余定理结合求解
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int N = 1e5 + 10;

ll quick_pow(ll a, ll b, ll P) {
    ll ans = 1;
    while(b) {
        if(b & 1)
            ans = ans * a % P;
        a = a * a % P;
        b >>= 1;
    }
    return ans % P;
}

ll ex_gcd(ll a, ll b, ll &x, ll &y) {
    ll res, t;
    if(!b) {
        x = 1;
        y = 0;
        return a;
    }
    res = ex_gcd(b, a % b, x, y);
    t = x;
    x = y;
    y = t - (a / b) * y;
    return res;
}

ll INV(ll a, ll mod) {
    ll x, y;
    ll d = ex_gcd(a, mod, x, y);
    return d ? (x % mod + mod) % mod : -1;
}

ll fac(ll n, ll P, ll pk) {// 阶乘除去质因子后模质数幂 (n / p^a) % pk
    if(!n) return 1;
    ll ans = 1;
    for(int i = 1;i < pk; i++) {// 第三部分：n!与p互质的乘积
        if(i % P)
            ans = ans * i % pk;
    }
    ans = quick_pow(ans, n / pk, pk) % pk; // 第三部分：n!与p互质的乘积,ans循环的次数为n/pk
    for(int i = 1;i <= n % pk; i++) {// 第四部分：循环过后n!剩下的部分
        if(i % P) ans = ans * i % pk;
    }
    return ans * fac(n / P, P, pk) % pk;  // 第一部分，p的幂，个数为n/p；  第二部分：(n/p)!
}

ll C(ll m, ll n, ll P, ll pk) {// 组合数模质数幂
    if(n < 0 || m < 0 || n > m) return 0;
    ll f1 = fac(m, P, pk), f2 = fac(n, P, pk), f3 = fac(m - n, P, pk), tmp = 0; // tmp = pk1 - pk2 - pk3
    for(ll i = m; i ; i /= P)     tmp += i / P;
    for(ll i = n; i ; i /= P)     tmp -= i / P;
    for(ll i = m - n; i ; i /= P) tmp -= i / P;
    return f1 * INV(f2, pk) % pk * INV(f3, pk) * quick_pow(P, tmp, pk) % pk;
}

ll p[N], a[N];
int cnt;

ll CRT() {
    ll M = 1, ans = 0;
    for(int i = 1;i <= cnt; i++)  M *= p[i];
    for(int i = 1;i <= cnt; i++) {
        ll m = M / p[i];
        ans = (ans + a[i] * m % M * INV(m, p[i]) % M) % M;
    }
    return (ans % M + M) % M;
}

ll EX_Lucas(ll m, ll n, ll P) {
    for(int i = 2;i * i <= P; i++) {
        if(P % i == 0) {
            ll tmp = 1;
            while(P % i == 0) {
                tmp *= i;
                P /= i;
            }
            p[++cnt] = tmp;
            a[cnt] = C(m, n, i, tmp);
        }
    }
    if(P > 1) {
        p[++cnt] = P;
        a[cnt] = C(m, n, P, P);
    }
    return CRT();
}
int main() {
    ll m, n, P;
    cin >> m >> n >> P;
    cnt = 0;
    cout << EX_Lucas(m, n, P) << endl;
}\end{lstlisting}
\subsection{Min25筛}
\begin{lstlisting}
typedef long long ll;

const int N = 1e5 + 10;


namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;

    ll g[N], sum[N], a[N], T, n;

    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }

    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }

    inline ll f(ll x) {
        return x;
    }

    inline void init() {
        ncnt = 0, m = 0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++)
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }

    inline ll Solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }

}
\end{lstlisting}
\subsection{杜教BM}
\begin{lstlisting}
typedef long long ll;
const ll mod = 1e9 + 7;

typedef vector<ll> VI;

ll quick_pow(ll a, ll b) ;

namespace linear_seq {
    const ll N = 1e5 + 10;
    ll res[N], base[N], _c[N], _md[N];

    vector<ll> Md;
    void mul(ll *a, ll *b, ll k) {
        for (ll i = 0; i < 2 * k; i++)
            _c[i] = 0;
        for (ll i = 0; i < k; i++) {
            if (a[i]) {
                for (int j = 0; j < k; j++) {
                    _c[i + j] = (_c[i + j] + a[i] * b[j]) % mod;
                }
            }
        }
        for (ll i = 2 * k - 1; i >= k; i--) {
            if (_c[i]) {
                for (ll j = 0; j < Md.size(); j++) {
                    _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod;
                }
            }
        }
        for (ll i = 0; i < k; i++)
            a[i] = _c[i];
    }

    ll solve(ll n, VI a, VI b) {
        // a 系数 b 初值 b[n + 1] = a[0] * b[n] + ...
        // cout << b.size() << endl;
        ll ans = 0, pnt = 0;
        ll k = a.size();
        assert(a.size() == b.size());
        for (ll i = 0; i < k; i++)
            _md[k - i - 1] = -a[i];
        _md[k] = 1;
        Md.clear();
        for (ll i = 0; i < k; i++) {
            if (_md[i] != 0)
                Md.push_back(i);
        }
        for (ll i = 0; i < k; i++)
            res[i] = base[i] = 0;
        res[0] = 1;
        while ((1ll << pnt) <= n)
            pnt++;
        for (ll p = pnt; p >= 0; p--) {
            mul(res, res, k);
            if ((n >> p) & 1) {
                for (ll i = k - 1; i >= 0; i--)
                    res[i + 1] = res[i];
                res[0] = 0;
                for (ll i = 0; i < Md.size(); i++)
                    res[Md[i]] = (res[Md[i]] - res[k] * _md[Md[i]]) % mod;
            }
        }
        for (ll i = 0; i < k; i++)
            ans = (ans + res[i] * b[i]) % mod;
        return ans;
    }

    VI BM(VI s) {
        VI C(1, 1), B(1, 1);
        ll L = 0, m = 1, b = 1;
        for (ll n = 0; n < s.size(); n++) {
            ll d = 0;
            for (ll i = 0; i < L + 1; i++)
                d = (d + (ll)C[i] * s[n - i]) % mod;
            if (d == 0)
                m++;
            else if (2 * L <= n) {
                VI T = C;
                ll c = mod - d * quick_pow(b, mod - 2) % mod;
                while (C.size() < B.size() + m)
                    C.push_back(0);
                for (int i = 0; i < B.size(); i++)
                    C[i + m] = (C[i + m] + c * B[i]) % mod;
                L = n + 1 - L;
                B = T;
                b = d;
                m = 1;
            }
            else {
                ll c = mod - d * quick_pow(b, mod - 2) % mod;
                while (C.size() < B.size() + m)
                    C.push_back(0);
                for (ll i = 0; i < B.size(); i++)
                    C[i + m] = (C[i + m] + c * B[i]) % mod;
                m++;
            }
        }
        return C;
    }

    ll gao(VI a, ll n) {
        VI c = BM(a);
        c.erase(c.begin());
        for (ll i = 0; i < c.size(); i++)
            c[i] = (mod - c[i]) % mod;
        return solve(n, c, VI(a.begin(), a.begin() + c.size()));
    }
}

void solve() {
    int n;
    while (~scanf("%d", &n)) {
        VI v = VI{1,2,4,7,13,24};
            printf("%d\n", linear_seq::gao(v, n - 1));
    }
}\end{lstlisting}
\subsection{杜教筛}
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int N = 1e6 + 10;

unordered_map<int, ll> smu, sphi;
bool isPrime[N];
int prime[N], num;
ll mu[N], phi[N];

void makeMobiusAndEuler(int siz) {
    mu[1] = phi[1] = 1;
    for (int i = 2; i <= siz; i++) {
        if (!isPrime[i]) prime[++num] = i, mu[i] = -1, phi[i] = i - 1;
        for (int j = 1; j <= num && i * prime[j] <= siz; j++) {
            isPrime[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            else {
                phi[i * prime[j]] = phi[prime[j]] * phi[i];
                mu[i * prime[j]] = -mu[i];
            }
        }
    }
    for (int i = 1; i <= siz; i++) mu[i] += mu[i - 1], phi[i] += phi[i - 1];
}

ll getSmu(int n) {
    if (n < N) return mu[n];
    if (smu[n]) return smu[n];
    ll res = 1;
    for (unsigned int l = 2, r = 0; l <= n; l = r + 1) {
        r = n / (n / l);
        res -= 1ll * (r - l + 1) * getSmu(n / l);
    }
    return smu[n] = res;
}

ll getSphi(int n) {
    if (n < N) return phi[n];
    if (sphi[n]) return sphi[n];
    ll res = 1ll * n * (n + 1) / 2;
    for (unsigned int l = 2, r = 0; l <= n; l = r + 1) {
        r = n / (n / l);
        res -= 1ll * (r - l + 1) * getSphi(n / l);
    }
    return sphi[n] = res;
}
\end{lstlisting}
\subsection{反演相关}
\begin{lstlisting}
/*
莫比乌斯反演
g[n] = \sum_{d | n} f[d]
f[d] = \sum_{d | n} g[d] * mu[n / d]
二项式反演
g[n] = \sum{i = 1}^{n} C(n, i) * f[i]
f[n] = \sum{i = 1}^{n} C(n, i) * g[i] * (-1)^{n - i}
子集反演
f(S) = \sum_{T \belong S} g(T)
g(S) = \sum_{T \belong S} f(T) * (-1) ^ {|S| - |T|}
*/
\end{lstlisting}
\subsection{整数拆分}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

//递归
ll PartitionCount(ll n, ll m) {
    if(n == 1 || m == 1)  return 1;
    else if(n < m) return PartitionCount(n , n);
    else if(n == m) return PartitionCount(n , n - 1) + 1;
    else return PartitionCount(n - m , m) + PartitionCount(n , m - 1);
}

//DP
ll dp[1005][1005];

void Partition_DP(ll n, ll m) {
    for(ll i = 1;i <= n + 1; i++) {
        for(ll j = 1;j <= m + 1; j++) {
            if(i == 1 || j == 1) dp[i][j] = 1;
            else if(i == j) dp[i][j] = 1 + dp[i][j - 1];
            else if(i < j) dp[i][j] = dp[i][i];
            else dp[i][j] = dp[i - j][j] + dp[i][j - 1];
         }
     }
}\end{lstlisting}
\subsection{自适应Simpson积分}
\begin{lstlisting}
// 求一个函数在一个区间上的数值积分

double f(double x) { // 题目中要求的辛普森积分函数，这里简单写一下f(x)=x*x
    return x * x;
}

double Simpson(double a, double b) {
    double mid = (a + b) / 2.0;
    return (b - a) *(f(a) + f(b) + 4.0 * f(mid)) / 6.0;
}

double DFS(double a, double b, double eps)
{
    double mid = (a + b) / 2.0;
    double SA = Simpson(a, mid), SM = Simpson(a, b), SB = Simpson(mid, b);
    if(fabs(SA + SB - SM) <= 15.0 * eps) 
        return SA + SB + (SA + SB - SM) / 15.0;
    return DFS(a, mid, eps / 2.0) + DFS(mid, b, eps / 2.0);
}

// 求一个函数在0~无穷的上的数值积分，若收敛输出答案，若发散输出orz\end{lstlisting}
\subsection{Bell}
\begin{lstlisting}

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int N = 20;

ll S2[N][N];
ll B[N];

void Stirling2() {
    S2[0][0] = 1;
    
    for(int i = 1;i < N; i++) {
        for(int j = 1;j <= i; j++) {
            S2[i][j] = S2[i - 1][j - 1] + j * S2[i - 1][j];
        }
    } 

}

// 根据第二类斯特林数

void Bell1() {
    
    for(int i = 0;i < N; i++) {
        for(int j = 0;j <= i; j++) {
            B[i] += S2[i][j];
        }
    }
}

// Bell三角形递推

ll b[N][N];

void Bell2() {
    b[1][1] = 1;
    for(int i = 2;i < N; i++) {
        b[i][1] = b[i - 1][i - 1];
        
        for(int j = 2;j < N; j++) {
            b[i][j] = b[i][j - 1] + b[i - 1][j - 1];
        }
    }
}

// 自身递推

ll fac[N];

ll C(ll m, ll n) {
    return fac[m] / (fac[n] * fac[m - n]);
}

void Bell3() {

    fac[1] = 1;
    for(int i = 2;i < N; i++)
        fac[i] = fac[i - 1] * i;

    B[0] = 1;

    for(int i = 1;i < N; i++) {
        for(int k = 0;k <= i; k++) {
            B[i] += C(i, k) * B[k];
        }
    }
}

\end{lstlisting}
\subsection{Catalan}
\begin{lstlisting}

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int N = 1e5 + 10;

int C[N];

// 线性递推

void Calc1() {
    C[0] = 1;
    for(int i = 1;i < N; i++) {
        C[i] = C[i - 1] * (4 * i - 2) / (i + 1);
    }
}

// 组合数求解 

int f[N];

void fac() {
    f[0] = 1;
    for(int i = 1;i < N; i++) {
        f[i] = f[i - 1] * i;
    }
}

void Calc2(int n) {
    C[n] = f[2 * n] / f[n + 1];
}

// 多项式求解

void Calc3(int n) {
    if(n == 1)
        C[n] = 1;
    
    for(int i = 1;i <= n; i++) {
        C[n] += C[n - i] * C[i - 1];
    }
}\end{lstlisting}
\subsection{Lucas}
\begin{lstlisting}
// mod一定为质数

namespace Comb {
    ll mod;
    const int N = 1e6 + 10;
    ll F[N], invF[N], inv[N];

    void init() {
        F[0] = F[1] = invF[0] = invF[1] = inv[0] = inv[1] = 1;
        for (int i = 2; i < N; i++) {
            F[i] = F[i - 1] * i % mod;
            inv[i] = (mod - mod / i) * inv[mod % i] % mod;
            invF[i] = invF[i - 1] * inv[i] % mod;
        }
    }

    ll C(ll m, ll n) {
        if (m < 0 || n < 0 || n > m) return 0;
        ll ans = F[m];
        ans = ans * invF[n] % mod;
        ans = ans * invF[m - n] % mod;
        return ans;
    }

    ll Lucas(ll m, ll n) {
        return n ? Lucas(m / mod, n / mod) * C(m % mod, n % mod) % mod : 1;
    }

}

// Comb::Lucas(m, n)\end{lstlisting}
\subsection{伯努利数}
\begin{lstlisting}
namespace BNL {
    const int N = 1e7 + 10, M = 1e6 + 10;
    struct Complex {
        double x, y;
        Complex(double a = 0, double b = 0): x(a), y(b) {}
        Complex operator + (const Complex &rhs) { return Complex(x + rhs.x, y + rhs.y); }
        Complex operator - (const Complex &rhs) { return Complex(x - rhs.x, y - rhs.y); }
        Complex operator * (const Complex &rhs) { return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); }
        Complex conj() { return Complex(x, -y); }
    } w[N];

    int tr[N];
    ll F[N], G[N];

    ll quick_pow(ll a, ll b, ll p) {
        ll ans = 1;
        while(b) {
            if(b & 1) ans = ans * a % p;
            a = a * a % p;
            b >>= 1;
        }
        return ans % p;
    }

    void FFT(Complex *A, int len) {
        for (int i = 0; i < len; i++) if(i < tr[i]) swap(A[i], A[tr[i]]);
        for (int i = 2, lyc = len >> 1; i <= len; i <<= 1, lyc >>= 1)
            for (int j = 0; j < len; j += i) {
                Complex *l = A + j, *r = A + j + (i >> 1), *p = w;
                for (int k = 0; k < i >> 1; k++) {
                    Complex tmp = *r * *p;
                    *r = *l - tmp, *l = *l + tmp;
                    ++l, ++r, p += lyc;
                }
            }
    }

    inline void MTT(ll *x, ll *y, ll *z, int n) {
        int len = 1; while (len <= n) len <<= 1;
        for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
        for (int i = 0; i < len; i++) w[i] = w[i] = Complex(cos(2 * PI * i / len), sin(2 * PI * i / len));

        for (int i = 0; i < len; i++) (x[i] += mod) %= mod, (y[i] += mod) %= mod;
        static Complex a[N], b[N];
        static Complex dfta[N], dftb[N], dftc[N], dftd[N];

        for (int i = 0; i < len; i++) a[i] = Complex(x[i] & 32767, x[i] >> 15);
        for (int i = 0; i < len; i++) b[i] = Complex(y[i] & 32767, y[i] >> 15);
        FFT(a, len), FFT(b, len);
        for (int i = 0; i < len; i++) {
            int j = (len - i) & (len - 1);
            static Complex da, db, dc, dd;
            da = (a[i] + a[j].conj()) * Complex(0.5, 0);
            db = (a[i] - a[j].conj()) * Complex(0, -0.5);
            dc = (b[i] + b[j].conj()) * Complex(0.5, 0);
            dd = (b[i] - b[j].conj()) * Complex(0, -0.5);
            dfta[j] = da * dc;
            dftb[j] = da * dd;
            dftc[j] = db * dc;
            dftd[j] = db * dd;
        }
        for (int i = 0; i < len; i++) a[i] = dfta[i] + dftb[i] * Complex(0, 1);
        for (int i = 0; i < len; i++) b[i] = dftc[i] + dftd[i] * Complex(0, 1);
        FFT(a, len), FFT(b, len);
        for (int i = 0; i < len; i++) {
            int da = (ll)(a[i].x / len + 0.5) % mod;
            int db = (ll)(a[i].y / len + 0.5) % mod;
            int dc = (ll)(b[i].x / len + 0.5) % mod;
            int dd = (ll)(b[i].y / len + 0.5) % mod;
            z[i] = (da + ((ll)(db + dc) << 15) + ((ll)dd << 30)) % mod;
        }
    }

    int getLen(int n) {
        int len = 1; while (len < (n << 1)) len <<= 1;
        for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
        for (int i = 0; i < len; i++) w[i] = w[i] = Complex(cos(2 * PI * i / len), sin(2 * PI * i / len));
        return len;
    }

    void Get_Inv(ll *f, ll *g, int n) {
        if(n == 1) { g[0] = quick_pow(f[0], mod - 2, mod); return ; }
        Get_Inv(f, g, (n + 1) >> 1);
        int len = getLen(n);
        static ll c[N];
        for(int i = 0;i < len; i++) c[i] = i < n ? f[i] : 0;
        MTT(c, g, c, len); MTT(c, g, c, len);
        for(int i = 0;i < n; i++) g[i] = (2ll * g[i] - c[i] + mod) % mod;
        for(int i = n;i < len; i++) g[i] = 0;
        for(int i = 0;i < len; i++) c[i] = 0;
    }

    ll ff[N], invff[N], inv[N];
    ll B[N];

    ll C(ll m, ll n) {
        if(m < 0 || n < 0 || n > m)
            return 0;
        ll ans = ff[m];
        ans = ans * invff[n] % mod;
        ans = ans * invff[m - n] % mod;
        return ans;
    }

    void init(int m) {
        ff[0] = ff[1] = inv[0] = inv[1] = invff[0] = invff[1] = 1;
        for(int i = 2;i < M; i++)
        {
            ff[i] = ff[i - 1] * i % mod;
            inv[i] = mod - (mod / i) * inv[mod % i] % mod;
            invff[i] = invff[i - 1] * inv[i] % mod;
        }

        for(int i = 0;i <= m + 10; i++) F[i] = invff[i + 1];
        Get_Inv(F, G, m + 10);
        for(int i = 0;i <= m + 10; i++) B[i] = G[i] * ff[i] % mod;
    }

    ll solve(ll n, int k) {
        init(k);
        ll ans = 0, prod = n % mod;
        for(int i = k; ~i ; i--) {
            ans = (ans + prod * B[i] % mod * C(k + 1, i) % mod) % mod;
            prod = prod * n % mod;
        }
        ans = ans * quick_pow(k + 1, mod - 2, mod) % mod;
        return ans;
    }
}

void solve() {
    ll n; int k; cin >> n >> k;
    cout << BNL::solve(n + 1, k) << endl;
}\end{lstlisting}
\subsection{步移_组合数前缀和}
\begin{lstlisting}
// S(n, m) = \sum_{i=0}^mC(n, i)

int x, y;
ll s;
ll S(int n, int m) {
    while(y < m) (s = s + C(x, ++y)) %= mod;
    while(y > m) (s = s - C(x, y--)) %= mod;
    while(x < n) (s = s * 2 - C(x++, y)) %= mod;
    while(x > n) (s = (s + C(--x, y)) * inv2) %= mod;
    return s;
}

\end{lstlisting}
\subsection{康托展开}
\begin{lstlisting}
#include  <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef long long ll;
const int mod = 1e9 + 7;
const int N = 1e5 + 10;

ll fac[N];
int a[N]; // 排列，康托展开求解
int n;
ll x; // 逆康托展开求解

void Get_F() {
    fac[0] = 1;
    for(int i = 1;i < N; i++)
        fac[i] = fac[i - 1] * i % mod;
}

ll CanTor() {
    ll ans = 0;
    for(int i = 1;i <= n; i++) {
        ll smaller = 0;
        for(int j = i + 1;j <= n; j++) {
            if(a[j] < a[i])
                smaller++;
        }
        ans = (ans + fac[n - i] * smaller % mod) % mod;
    }
    return ans + 1;
}

void DeCantor() {
    vector<int> v; // 存放当前可选数
    vector<int> a; // 所求的排列组合序
    for(int i = 1;i <= n; i++) {
        v.push_back(i);
    }
    for(int i = n;i >= 1; i--) {
        int r = x % fac[i - 1];
        int t = x / fac[i - 1];
        x = r;
        sort(v.begin(), v.end());
        a.push_back(v[t]);
        v.erase(v.begin() + t);
    }
    for(int i = 0;i < a.size(); i++)
        cout << a[i] << " ";
    cout << endl;
}

// 线段树优化

const int N = 1000010;

ll fac[N];
int a[N]; // 排列，康托展开求解
int n;

struct SegmentTree {
    int ls, rs;
    int sum;
}t[N << 2];

int cnt, root;

void push_up(int u) {
    t[u].sum = (t[lc].sum + t[rc].sum) % mod;
}

void build(int &u, int l, int r) {
    if(!u) u = ++cnt;
    if(l == r) {
        t[u].sum = 1;
        return ;
    }
    build(lc, l, m);
    build(rc, m + 1, r);
    push_up(u);
}

void update(int &u, int l, int r, int k) {
    if(!u) u = ++cnt;
    if(l == r) {
        t[u].sum = 0;
        return ;
    }
    if(k <= m) update(lc, l, m, k);
    else update(rc, m + 1, r, k);
    push_up(u);
}

ll query(int u, int l, int r, int ql, int qr) {
    if(ql > qr) return 0;
    if(ql == l && qr == r) {
        return t[u].sum;
    }
    if(qr <= m) return query(lc, l, m, ql, qr) % mod;
    else if(ql > m) return query(rc, m + 1, r, ql, qr) % mod;
    else return (query(lc, l, m, ql, m) + query(rc, m + 1, r, m + 1, qr)) % mod;
}

void Get_F() {
    fac[0] = 1;
    for(int i = 1;i < N; i++)
        fac[i] = fac[i - 1] * i % mod;
}

void solve()
{
    Get_F();
    cin >> n;
    build(root, 1, n);
    ll ans = 0;
    for(int i = 1;i <= n; i++) {
        cin >> a[i];
        update(root, 1, n, a[i]);
        ans = (ans + query(root, 1, n, 1, a[i] - 1) * fac[n - i]) % mod;
    }
    cout << (ans + 1) % mod << endl;
}\end{lstlisting}
\subsection{模数非质数的组合}
\begin{lstlisting}
// 模数非质数情况下的组合问题
// one way, use CRT merge ans
// https://ac.nowcoder.com/discuss/655940?type=101&order=0&pos=2&page=1&channel=-1&source_id=discuss_tag_nctrack
// another way
// https://ac.nowcoder.com/acm/contest/view-submission?submissionId=47754622

#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int N = 1e6 + 10;

ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    ll res = exgcd(b, a % b, x, y);
    ll t = y;
    y = x - a / b * y;
    x = t;
    return res;
}

ll inv(ll a, ll b) {
    ll x = 0, y = 0;
    exgcd(a, b, x, y);
    return x = (x % b + b) % b;
}

//r[]为余数, m为模数, 其中模数互质
//M = pi(mi), Mi = M / mi, invMi = Mi % mi
//ni满足是除了mi之外的倍数, 且模mi为ri
//利用逆元性质, 即ri * Mi * invMi = ri (mod mi)
//res = (sigma(ri * Mi * invMi)) % M

ll china(ll r[], ll m[], int n) {
    ll M = 1, res = 0;
    for (int i = 1; i <= n; i++) M *= m[i];
    for (int i = 1; i <= n; i++) {
        ll Mi = M / m[i], invMi = inv(Mi, m[i]);
        res = (res + r[i] * Mi % M * invMi % M) % M;
        //res = (res + mul(mul(r[i], Mi, M), invMi, M)) % M;按位乘
    }
    return (res % M + M) % M;
}

int f[N], g[N], F[N], G[N], invF[N];

int calc(int n, int p, int k) {
    ll mod = qpow(p, k, LONG_LONG_MAX);
    F[0] = 1, G[0] = 0;
    for (int i = 1; i <= n; i++) {
        g[i] = 0, f[i] = i;
        while (f[i] % p == 0) f[i] /= p, g[i]++;
        F[i] = 1ll * F[i - 1] * f[i] % mod;
        G[i] = G[i - 1] + g[i];
    }
    invF[n] = inv(F[n], mod);
    for (int i = n; i >= 1; i--) invF[i - 1] = 1ll * invF[i] * f[i] % mod;
    int ans = 0;
    for (int i = 0; i <= n / 2; i++) {
        int t = 1ll * F[n] * invF[n - 2 * i] % mod * invF[i] % mod * invF[i] % mod *
                qpow(p, G[n] - G[n - 2 * i] - 2 * G[i], LONG_LONG_MAX) % mod;
        ans = (ans + 1ll * t) % mod;
    }
    return ans;
}

ll r[20], m[20];

int main() {
#ifdef ACM_LOCAL
    freopen("input.in", "r", stdin);
    freopen("output.out", "w", stdout);
#endif
    int n, p;
    scanf("%d%d", &n, &p);
    int num = 0;
    for (int i = 2; i * i <= p; i++)
        if (p % i == 0) {
            int k = 0;
            m[++num] = 1;
            while (p % i == 0) p /= i, k++, m[num] *= i;
            r[num] = calc(n, i, k);
        }
    if (p > 1) {
        m[++num] = p;
        r[num] = calc(n, p, 1);
    }
    printf("%lld\n", china(r, m, num));

    return 0;
}\end{lstlisting}
\subsection{k次最小置换复原}
\begin{lstlisting}

void solve() {
    int n; cin >> n;
    vector<int> a(n + 1), vis(n + 1);
    for(int i = 1;i <= n; i++) cin >> a[i];
    ll ans = 1;
    for(int i = 1;i <= n; i++) {
        if(!vis[i]) {
            int cnt = 0;
            int x = i;
            while(!vis[x]) {
                vis[x] = 1;
                cnt++;
                x = a[x];
            }
            ans = lcm(ans, cnt);
        }
    }
    cout << ans << endl;
}

\end{lstlisting}
\subsection{Striling}
\begin{lstlisting}
typedef long long ll;
const int N = 20;

// 第一类斯特林数
ll S1[N][N];
void Stirling1() {
    S1[0][0] = 1;
    for(int i = 1;i < N; i++) {
        for(int j = 1;j <= i; j++) {
            S1[i][j] = S1[i - 1][j - 1] + (i - 1) * S1[i - 1][j];
        }
    }
}

// 第二类斯特林数
ll S2[N][N];
void Stirling2() {
    S2[0][0] = 1;
    for(int i = 1;i < N; i++) {
        for(int j = 1;j <= i; j++) {
            S2[i][j] = S2[i - 1][j - 1] + j * S2[i - 1][j];
        }
    } 
}\end{lstlisting}
\subsection{第二类斯特林数_行}
\begin{lstlisting}
// {n,m}->n个不同元素划分成m个相同的集合中（不能有空集）的方案数。

// {n,m}={n-1,m-1}+k{n-1,m}

// {n,m}=\sum_{i=0}^n \frac{i^n}{i!} * {(-1)^{m-i}}{(m-i)!}

const int N = 1e6 + 10;
const ll mod = 167772161;

ll F[N], invF[N];
void init() ;

ll qpow(ll a, ll b, ll mod) ;

const ll G = 3;
const ll invG = qpow(G, mod - 2, mod);
int tr[N];

void NTT(ll *A, int len, int type) ;
void mul(ll *a, ll *b, int n) ;

ll a[N], b[N];

void solve() {
    init();
    int n; cin >> n;
    for(int i = 0;i <= n; i++) {
        a[i] = qpow(i, n, mod) * invF[i] % mod;
        if(i & 1) b[i] = mod - invF[i];
        else b[i] = invF[i];
    }
    mul(a, b, 2 * n);
    for(int i = 0;i <= n; i++) cout << a[i] << (i == n ? endl : " ");
}
\end{lstlisting}
\subsection{第二类斯特林数_列}
\begin{lstlisting}
// 把n个不同元素划分成m个相同的集合（不能有空集）的方案数。

// k!\sum_{i=0}\frac{{i,k}x^i}{i!}=(e^x-1)^k

const int N = 6e5 + 10;
const ll mod = 167772161;

ll quick_pow(ll a, ll b) ;

const ll G = 3;
const ll invG = quick_pow(G, mod - 2);

int tr[N];
bool flag;

void NTT(ll *A, int len, int type) ;
void mul(ll *a, ll *b, int len) ;
void Get_Der(ll *f, ll *g, int len) ;
void Get_Int(ll *f, ll *g, int len) ;
void Get_Inv(ll *f, ll *g, int n) ;
void Get_Ln(ll *f, ll *g, int n) ;
void Get_Exp(ll *f, ll *g, int n) ;
void Get_Pow(ll *f, ll *g, int n, ll k1, ll k2);

ll a[N], ans[N];

ll F[N], invF[N], inv[N];
void init() ;


void solve() {
    init();
    int n; ll k; cin >> n >> k; n++;
    if(k >= mod) flag = 1;
    for(int i = 1;i < n; i++) a[i] = invF[i];
    Get_Pow(a, ans, n, k % mod, k % (mod - 1));
    for(int i = 0;i < n; i++) {
        cout << ans[i] * invF[k] % mod * F[i] % mod << (i == n - 1 ? endl : " ");
    }
}
\end{lstlisting}
\subsection{第一类斯特林数_行}
\begin{lstlisting}
#include <algorithm>
#include <cstdio>
#include <cstring>

typedef long long LL;
const int N = 550050;
const int mod = 167772161;

LL pow_mod(LL a, LL b) {
  LL ans = 1;
  for (; b; b >>= 1, a = a * a % mod)
    if (b & 1) ans = ans * a % mod;
  return ans;
}

int L, rev[N];
LL w[N], inv[N], fac[N], ifac[N];

void Init(int n) {
  L = 1;
  while (L <= n) L <<= 1;
  for (int i = 1; i < L; ++i)
    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) * L / 2);
  LL wn = pow_mod(3, (mod - 1) / L);
  w[L >> 1] = 1;
  for (int i = L >> 1; i < L; ++i) w[i + 1] = w[i] * wn % mod;
  for (int i = (L >> 1) - 1; i; --i) w[i] = w[i << 1];
}

void DFT(LL *A, int len) {
  int k = __builtin_ctz(L) - __builtin_ctz(len);
  for (int i = 1; i < len; ++i) {
    int j = rev[i] >> k;
    if (j > i) std::swap(A[i], A[j]);
  }
  for (int h = 1; h < len; h <<= 1)
    for (int i = 0; i < len; i += (h << 1))
      for (int j = 0; j < h; ++j) {
        LL t = A[i + j + h] * w[j + h] % mod;
        A[i + j + h] = A[i + j] - t;
        A[i + j] += t;
      }
  for (int i = 0; i < len; ++i) A[i] %= mod;
}

void IDFT(LL *A, int len) {
  std::reverse(A + 1, A + len);
  DFT(A, len);
  int v = mod - (mod - 1) / len;
  for (int i = 0; i < len; ++i) A[i] = A[i] * v % mod;
}

void offset(const LL *f, int n, LL c, LL *g) {
  // g(x) = f(x + c)
  // g[i] = 1/i! sum_{j=i}^n j!f[j] c^(j-i)/(j-i)!
  static LL tA[N], tB[N];
  int l = 1; while (l <= n + n) l <<= 1;
  for (int i = 0; i < n; ++i) tA[n - i - 1] = f[i] * fac[i] % mod;
  LL pc = 1;
  for (int i = 0; i < n; ++i, pc = pc * c % mod) tB[i] = pc * ifac[i] % mod;
  for (int i = n; i < l; ++i) tA[i] = tB[i] = 0;
  DFT(tA, l); DFT(tB, l);
  for (int i = 0; i < l; ++i) tA[i] = tA[i] * tB[i] % mod;
  IDFT(tA, l);
  for (int i = 0; i < n; ++i)
    g[i] = tA[n - i - 1] * ifac[i] % mod;
}

void Solve(int n, LL *f) {
  if (n == 0) return void(f[0] = 1);
  static LL tA[N], tB[N];
  int m = n / 2;
  Solve(m, f);
  int l = 1; while (l <= n) l <<= 1;
  offset(f, m + 1, m, tA);
  for (int i = 0; i <= m; ++i) tB[i] = f[i];
  for (int i = m + 1; i < l; ++i) tA[i] = tB[i] = 0;
  DFT(tA, l); DFT(tB, l);
  for (int i = 0; i < l; ++i) tA[i] = tA[i] * tB[i] % mod;
  IDFT(tA, l);
  if (n & 1)
    for (int i = 0; i <= n; ++i)
      f[i] = ((i ? tA[i - 1] : 0) + (n - 1) * tA[i]) % mod;
  else
    for (int i = 0; i <= n; ++i)
      f[i] = tA[i];
}

LL f[N];

int main() {
  int n;
  scanf("%d", &n);
  Init(n * 2);
  inv[1] = 1;
  for (int i = 2; i <= n; ++i) inv[i] = -(mod / i) * inv[mod % i] % mod;
  fac[0] = ifac[0] = 1;
  for (int i = 1; i <= n; ++i) {
    fac[i] = fac[i - 1] * i % mod;
    ifac[i] = ifac[i - 1] * inv[i] % mod;
  }
  Solve(n, f);
  for (int i = 0; i <= n; ++i)
    printf("%lld ", (f[i] + mod) % mod);
  return 0;
}

\end{lstlisting}
\subsection{第一类斯特林数_列}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define mod 167772161
#define MAXN 531072
#define Gi 3

int quick_pow (int a,int b,int c)
{
    int res = 1;
    while (b){
        if (b & 1) res = 1ll * res * a % c;
        a = 1ll * a * a % c;
        b >>= 1;
    }
    return res;
}

int limit = 1,l,r[MAXN];

void NTT (int *a,int type)
{
    for (Int i = 0;i < limit;++ i) if (i < r[i]) swap (a[i],a[r[i]]);
    for (Int mid = 1;mid < limit;mid <<= 1){
        int Wn = quick_pow (Gi,(mod - 1) / (mid << 1),mod);
        if (type == -1) Wn = quick_pow (Wn,mod - 2,mod);
        for (Int R = mid << 1,j = 0;j < limit;j += R){
            for (Int k = 0,w = 1;k < mid;++ k,w = 1ll * w * Wn % mod)
            {
                int x = a[j + k],y = 1ll * w * a[j + k + mid] % mod;
                a[j + k] = (x + y) % mod,a[j + k + mid] = (x + mod - y) % mod;
            }
        }
    } 
    if (type == 1) return ;
    int Inv = quick_pow (limit,mod - 2,mod);
    for (Int i = 0;i < limit;++ i) a[i] = 1ll * a[i] * Inv % mod;
}

int c[MAXN];

void Solve (int len,int *a,int *b)
{
    if (len == 1) return b[0] = quick_pow (a[0],mod - 2,mod),void ();
    Solve ((len + 1) >> 1,a,b);
    limit = 1,l = 0;
    while (limit < (len << 1)) limit <<= 1,l ++;
    for (Int i = 0;i < limit;++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    for (Int i = 0;i < len;++ i) c[i] = a[i];
    for (Int i = len;i < limit;++ i) c[i] = 0;
    NTT (c,1);NTT (b,1);
    for (Int i = 0;i < limit;++ i) b[i] = 1ll * b[i] * (2 + mod - 1ll * c[i] * b[i] % mod) % mod;
    NTT (b,-1);
    for (Int i = len;i < limit;++ i) b[i] = 0;
}

void deravitive (int *a,int n){
    for (Int i = 1;i <= n;++ i) a[i - 1] = 1ll * a[i] * i % mod;
    a[n] = 0;
}

void inter (int *a,int n){
    for (Int i = n;i >= 1;-- i) a[i] = 1ll * a[i - 1] * quick_pow (i,mod - 2,mod) % mod;
    a[0] = 0;
}

int b[MAXN];

void Ln (int *a,int n){
    memset (b,0,sizeof (b));
    Solve (n,a,b);deravitive (a,n);
    while (limit <= n) limit <<= 1,l ++;
    for (Int i = 0;i < limit;++ i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    NTT (a,1),NTT (b,1);
    for (Int i = 0;i < limit;++ i) a[i] = 1ll * a[i] * b[i] % mod;
    NTT (a,-1);
    inter (a,n);
    for (Int i = n + 1;i < limit;++ i) a[i] = 0;
}

int F0[MAXN];

void Exp (int *a,int *B,int n){
    if (n == 1) return B[0] = 1,void ();
    Exp (a,B,(n + 1) >> 1);
    for (Int i = 0;i < limit;++ i) F0[i] = B[i];
    Ln (F0,n);
    F0[0] = (a[0] + 1 + mod - F0[0]) % mod;
    for (Int i = 1;i < n;++ i) F0[i] = (a[i] + mod - F0[i]) % mod;
    NTT (F0,1);NTT (B,1);
    for (Int i = 0;i < limit;++ i) B[i] = 1ll * F0[i] * B[i] % mod;
    NTT (B,-1);
    for (Int i = n;i < limit;++ i) B[i] = 0;
}

int read ()
{
    int x = 0;char c = getchar();int f = 1;
    while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}
    while (c >= '0' && c <= '9'){x = (int)((int)(x << 3) % mod + (int)(x << 1) % mod + c - '0') % mod;c = getchar();}
    return x * f;
}

void write (int x)
{
    if (x < 0){x = -x;putchar ('-');}
    if (x > 9) write (x / 10);
    putchar (x % 10 + '0');
}

int n,k;
int fac[MAXN],A[MAXN],B[MAXN];

signed main()
{
	n = read (),k = read ();
	for (Int i = 0;i < n;++ i) A[i] = quick_pow (i + 1,mod - 2,mod);
	Ln (A,n);
	for (Int i = 0;i < n;++ i) A[i] = 1ll * A[i] * k % mod;
	Exp (A,B,n);fac[0] = 1;
	for (Int i = 1;i <= max (n,k);++ i) fac[i] = 1ll * fac[i - 1] * i % mod;
	for (Int i = n;i >= k;-- i) B[i] = B[i - k];
	for (Int i = 0;i < k;++ i) B[i] = 0;int Inv = quick_pow (fac[k],mod - 2,mod);
	for (Int i = 0;i <= n;++ i) write (1ll * B[i] * fac[i] % mod * Inv % mod),putchar (' ');
	putchar ('\n');
    return 0;
}
\end{lstlisting}
\subsection{整数拆分多项式求逆}
\begin{lstlisting}

// NTT求法，任意模数复杂度较高
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const double PI = acos(-1);
const int N = 1e5 + 10;

struct Complex {
    double x, y;
    Complex(double a = 0, double b = 0): x(a), y(b) {}
    Complex operator + (const Complex &rhs) { return Complex(x + rhs.x, y + rhs.y); }
    Complex operator - (const Complex &rhs) { return Complex(x - rhs.x, y - rhs.y); }
    Complex operator * (const Complex &rhs) { return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); }
    Complex conj() { return Complex(x, -y); }
} w[N];

ll mod, g;
int tr[N];
ll F[N], G[N];

ll quick_pow(ll a, ll b) ;

int getLen(int n) ;

void NTT(ll *a, int len, int opt) ;

void mul(ll *a, ll *b, ll *z, int n) ;

void Get_Inv(ll *f, ll *g, int n) ;

void ChaiFen(ll *f, ll *g, int n) {
    int len = getLen(n);
    for(int i = 0;i < len; i++) {
        ll a = 1ll * i * (3 * i - 1) / 2; ll b = 1ll * i * (3 * i + 1) / 2;
        if(a > len && b > len) break;
        ll tmp;
        if(i & 1) tmp = mod - 1;
        else tmp = 1;
        if(a < len) f[a] = tmp;
        if(b < len) f[b] = tmp;
    }

    Get_Inv(f, g, n);
}

int main() {
    int n;
    cin >> n;
    ChaiFen(F, G, n);
    for(int i = 1;i <= n; i++) cout << G[i] << endl;
}
\end{lstlisting}
\subsection{整数拆分生成函数}
\begin{lstlisting}

// O(n*sqrt(n))

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int N = 1e5 + 5;
const ll mod = 1e9 + 7;
int f1[270], f2[270];

ll ans[N];

void init() {
    for (int i = 1; ; i++) {
        f1[i] = (3 * i * i - i) >> 1;
        if (f1[i] > 100000) break;
        f2[i] = (3 * i * i + i) >> 1;
        if (f2[i] > 100000) break;
    }
    ans[0] = 1;
    for (int i = 1; i <= 100000; i++) {
        for (int j = 1; ; j++) {
            if (f1[j] <= i) ans[i] += j & 1 ? ans[i-f1[j]] : -ans[i-f1[j]];
            else break;
            if (f2[j] <= i) ans[i] += j & 1 ? ans[i-f2[j]] : -ans[i-f2[j]];
            else break;
        }
        ans[i] = (ans[i] % mod + mod) % mod;
    }
}
\end{lstlisting}
\subsection{普通型母函数}
\begin{lstlisting}
// 普通型母函数：（1+x^1+x^2+...）(1+x^2+x^4)(1+x^3+x^6..)(...)(...)... 类似整数拆分

// a_n=1,1,1,1... = \frac{1}{1-x}
// a_n=1,0,1,0... = \frac{1}{1-x^2}
// a_n=1,2,3,4... = \frac{1}{(1-x)^2}
// a_n=C(m,n)     = (1+x)^m
// a_n=C(m+n,n)   = \frac{1}{(1-x)^{m+1}}

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

// 求解硬币等普通问题

const int N = 1e5 + 10;

int a[N]; // 权重为i的组合数，a[P]为答案
int b[N]; // 辅助数组
int P; // 需要被分解的数
int k; // 物品个数
int v[N]; // 每个物品的权重
int n1[N]; // 对于每种物品起始的因子（所需要的每个物品最小个数），最小为0
int n2[N]; // 对于每种物品最终的因子（所需要的每个物品最大个数），最大为INF

// 模板一(标准)

void Calc1() {
    memset(a, 0, sizeof(a));
    a[0] = 1;

    for(int i = 1;i <= k; i++) { // 枚举每个物品因子
        memset(b, 0, sizeof(b));
        for(int j = n1[i];j <= n2[i] && j * v[i] <= P; j++) { // 每个物品从最小因子到最大因子循环,如果n2是无穷的，则j<=n2[i]可以删去
            for(int m = 0;m + j * v[i] <= P; m++) { // 循环a的每个项
                b[m + j * v[i]] += a[m]; // 把结果加到对应项里，有点dp的味道
            }
        }
        memcpy(a, b, sizeof(b));
    }
}

// 模板二（数据量大的时候可以用，快速）

void Calc2() {
    memset(a, 0, sizeof(a));
    a[0] = 1;
    int last = 0;
    for(int i = 1; i <= k; i++) {
        int last2 = min(last + n2[i] * v[i], P);//计算下一次的last
        memset(b, 0, sizeof(int) * (last2 + 1));//只清空b[0..last2]
        for(int j = n1[i]; j <= n2[i] && j * v[i] <= last2; j++) //last2
            for(int m = 0; m <= last && m + j * v[i] <= last2; m++) //一个是last，一个是last2
                b[m + j * v[i]] += a[m];
        memcpy(a, b, sizeof(int) * (last2 + 1));//b赋值给a，只赋值0..last2
        last = last2;//更新last
    }
}
\end{lstlisting}
\subsection{指数型母函数}
\begin{lstlisting}

// 需要借助e^x的泰勒展开，一般求解多重排列数，即有 种物品，已知每种物品的数量为 k1,k2,...,kn 个，求从中选出m件物品的排列数。

// 对n个元素全排列，方案数为n!/(n1!n2!...nk!)，对n个中的r个元素进行全排列，这里就用到了指数型母函数，即G(x)=(1+x/1!+x^2/2!+...+x^k1/k1!)(1+x/1!+x^2/2!+...+x^k2/k2!)...(1+x/1!+x^2/2!+...+x^kn/kn!)

// 化简得G(x)=a0 + a1*x+a2*x^2/2!+...+ap*x^p/p!   (p = k1+k2+k3+...) ai为选出i个物品的排列方案数

//  若题目有规定条件，比如需要物品i出现非0的偶数次，即原式为(x^2/2!+x^4/4!+...+x^ki/ki!) 

#include <bits/stdc++.h>
using namespace std;

typedef long double ld;

double num[15]; // 每种物品的数量，第i个物品有num[i]个

double a[15], b[15];

double f[120]; // 阶乘

void fac()
{
    f[0] = 1;
    for(int i = 1;i <= 105; i++)
        f[i] = f[i - 1] * i;
}

void Calc() {
    int n, m;
    cin >> n >> m;
    for(int i = 1;i <= n; i++)
        cin >> num[i];

    memset(a, 0, sizeof(a));
    memset(b, 0, sizeof(b));

    for(int i = 0;i <= num[1]; i++) {
        a[i] = 1.0 / f[i];
    }

    for(int i = 2;i <= n; i++) {
        for(int j = 0;j <= m; j++) {
            for(int k = 0;k <= num[i] && j + k <= m; k++) {
                b[j + k] += a[j] / f[k];
            }
        }

        for(int j = 0;j <= m; j++) {
            a[j] = b[j];
            b[j] = 0;
        }
    }

    cout << a[m] * f[m] << endl;
}\end{lstlisting}
\subsection{伯努利数求和}
\begin{lstlisting}
namespace BNL {
    const int N = 1e7 + 10, M = 1e6 + 10;
    struct Complex {
        double x, y;
        Complex(double a = 0, double b = 0): x(a), y(b) {}
        Complex operator + (const Complex &rhs) { return Complex(x + rhs.x, y + rhs.y); }
        Complex operator - (const Complex &rhs) { return Complex(x - rhs.x, y - rhs.y); }
        Complex operator * (const Complex &rhs) { return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); }
        Complex conj() { return Complex(x, -y); }
    } w[N];

    int tr[N];
    ll F[N], G[N];

    ll quick_pow(ll a, ll b, ll p) {
        ll ans = 1;
        while(b) {
            if(b & 1) ans = ans * a % p;
            a = a * a % p;
            b >>= 1;
        }
        return ans % p;
    }

    void FFT(Complex *A, int len) {
        for (int i = 0; i < len; i++) if(i < tr[i]) swap(A[i], A[tr[i]]);
        for (int i = 2, lyc = len >> 1; i <= len; i <<= 1, lyc >>= 1)
            for (int j = 0; j < len; j += i) {
                Complex *l = A + j, *r = A + j + (i >> 1), *p = w;
                for (int k = 0; k < i >> 1; k++) {
                    Complex tmp = *r * *p;
                    *r = *l - tmp, *l = *l + tmp;
                    ++l, ++r, p += lyc;
                }
            }
    }

    inline void MTT(ll *x, ll *y, ll *z, int n) {
        int len = 1; while (len <= n) len <<= 1;
        for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
        for (int i = 0; i < len; i++) w[i] = w[i] = Complex(cos(2 * PI * i / len), sin(2 * PI * i / len));

        for (int i = 0; i < len; i++) (x[i] += mod) %= mod, (y[i] += mod) %= mod;
        static Complex a[N], b[N];
        static Complex dfta[N], dftb[N], dftc[N], dftd[N];

        for (int i = 0; i < len; i++) a[i] = Complex(x[i] & 32767, x[i] >> 15);
        for (int i = 0; i < len; i++) b[i] = Complex(y[i] & 32767, y[i] >> 15);
        FFT(a, len), FFT(b, len);
        for (int i = 0; i < len; i++) {
            int j = (len - i) & (len - 1);
            static Complex da, db, dc, dd;
            da = (a[i] + a[j].conj()) * Complex(0.5, 0);
            db = (a[i] - a[j].conj()) * Complex(0, -0.5);
            dc = (b[i] + b[j].conj()) * Complex(0.5, 0);
            dd = (b[i] - b[j].conj()) * Complex(0, -0.5);
            dfta[j] = da * dc;
            dftb[j] = da * dd;
            dftc[j] = db * dc;
            dftd[j] = db * dd;
        }
        for (int i = 0; i < len; i++) a[i] = dfta[i] + dftb[i] * Complex(0, 1);
        for (int i = 0; i < len; i++) b[i] = dftc[i] + dftd[i] * Complex(0, 1);
        FFT(a, len), FFT(b, len);
        for (int i = 0; i < len; i++) {
            int da = (ll)(a[i].x / len + 0.5) % mod;
            int db = (ll)(a[i].y / len + 0.5) % mod;
            int dc = (ll)(b[i].x / len + 0.5) % mod;
            int dd = (ll)(b[i].y / len + 0.5) % mod;
            z[i] = (da + ((ll)(db + dc) << 15) + ((ll)dd << 30)) % mod;
        }
    }

    int getLen(int n) {
        int len = 1; while (len < (n << 1)) len <<= 1;
        for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
        for (int i = 0; i < len; i++) w[i] = w[i] = Complex(cos(2 * PI * i / len), sin(2 * PI * i / len));
        return len;
    }

    void Get_Inv(ll *f, ll *g, int n) {
        if(n == 1) { g[0] = quick_pow(f[0], mod - 2, mod); return ; }
        Get_Inv(f, g, (n + 1) >> 1);
        int len = getLen(n);
        static ll c[N];
        for(int i = 0;i < len; i++) c[i] = i < n ? f[i] : 0;
        MTT(c, g, c, len); MTT(c, g, c, len);
        for(int i = 0;i < n; i++) g[i] = (2ll * g[i] - c[i] + mod) % mod;
        for(int i = n;i < len; i++) g[i] = 0;
        for(int i = 0;i < len; i++) c[i] = 0;
    }

    ll ff[N], invff[N], inv[N];
    ll B[N];

    ll C(ll m, ll n) {
        if(m < 0 || n < 0 || n > m)
            return 0;
        ll ans = ff[m];
        ans = ans * invff[n] % mod;
        ans = ans * invff[m - n] % mod;
        return ans;
    }

    void init(int m) {
        ff[0] = ff[1] = inv[0] = inv[1] = invff[0] = invff[1] = 1;
        for(int i = 2;i < M; i++)
        {
            ff[i] = ff[i - 1] * i % mod;
            inv[i] = mod - (mod / i) * inv[mod % i] % mod;
            invff[i] = invff[i - 1] * inv[i] % mod;
        }

        for(int i = 0;i <= m + 10; i++) F[i] = invff[i + 1];
        Get_Inv(F, G, m + 10);
        for(int i = 0;i <= m + 10; i++) B[i] = G[i] * ff[i] % mod;
    }

    ll solve(ll n, int k) {
        init(k);
        ll ans = 0, prod = n % mod;
        for(int i = k; ~i ; i--) {
            ans = (ans + prod * B[i] % mod * C(k + 1, i) % mod) % mod;
            prod = prod * n % mod;
        }
        ans = ans * quick_pow(k + 1, mod - 2, mod) % mod;
        return ans;
    }
}

void solve() {
    ll n; int k; cin >> n >> k;
    cout << BNL::solve(n + 1, k) << endl;
}\end{lstlisting}
\subsection{斐波那契大数}
\begin{lstlisting}
int a[505][505];

void solve() {
    memset(a,0,sizeof(a));
    a[1][1]  = 1;
    a[2][1] = 1;
    int s,plus = 0;
    for(int i = 3;i < 491;i++){
        for(int j = 1;j < 491;j++){
            s = a[i-2][j]+a[i-1][j]+plus;
            a[i][j] = s % 10;
            plus = s / 10;
        }
    }
    int n;
    while(scanf("%d",&n) && n != -1) {
        int k = 491;
        while(1) {
            if(a[n][k]) break;
            k--;
        }
        while(k >= 1) {
            printf("%d",a[n][k]);
            k--;
        }
    }
}\end{lstlisting}
\subsection{斐波那契循环节}
\begin{lstlisting}
// 斐波那契循环节

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pdd;

#define INF 0x7f7f7f
#define mem(a,b) memset(a , b , sizeof(a))
#define FOR(i, x, n) for(int i = x;i <= n; i++)

const ll mod = 1e9 + 7;
const int maxn = 5e6 + 10;

bool is_prime[maxn];
ll prime[maxn];
int p;

void sieve() // 素数筛
{
    p = 0; 
    mem(is_prime, true);
    is_prime[0] = is_prime[1] = false;
    for(int i = 2;i < maxn; i++)
    {
        if(is_prime[i])
        {
            prime[++p] = i;
            for(int j = i + i;j < maxn; j += i)
            {
                is_prime[j] = false;
            }
        }
    }
}

ll gcd(ll a, ll b)
{
    return b ? gcd(b, a % b) : a;
}

ll quick_pow(ll a, ll b)
{
    a %= mod;
    ll ans = 1;
    ll base = a;
    while(b)
    {
        if(b&1)
        {
            ans = ans * base % mod;
        }
        base = base * base % mod;
        b >>= 1;
    }
    return ans % mod;
}

ll num[maxn]; // 所有质数的循环节
ll f[maxn]; // 斐波那契数列

void Fib_Cyclic_node()
{
    num[1] = 3;
    for(int i = 2;i <= p; i++) // 找每个素数的循环节num[1~p]
    {
        f[1] = 1;
        f[2] = 2;
        int x = 3;
        while(true)
        {
            f[x] = f[x - 1] + f[x - 2];
            f[x] %= prime[i];
            if(f[x] == 1 && f[x - 1] == 0) // f[x] % prime[i] == f[1]
                break;
            x++;
        }
        num[i] = x;
    }

    ll n;
    cin >> n; // 如果是质数，那循环节就是num[n] ；  如果是合数，那循环节就是n的素因子的最小公倍数
    ll ans = 1;
    ll x;
    for(int i = 1;i <= p; i++)
    {
        if(n % prime[i] == 0)
        {
            x = 0;
            while(n % prime[i] == 0)
            {
                n /= prime[i];
                x++;
            }
        }
        ll k = num[i] * quick_pow(prime[i], x - 1);
        ans = ans * k / gcd(ans, k); // 最小公倍数
    }
    cout << ans << endl; // 最小循环节
}

// 广义斐波那契循环节

// fib(n) = a * fib(n - 1) + b * fib(n - 2)
// fib(1) = c   fib(2) = d
// 求f(n) mod p的循环节     
//c = a * a - 4b是模p的二次剩余时枚举p-1的因子，否则枚举(p+1)(p-1)的因子

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pdd;

#define INF 0x7f7f7f
#define mem(a,b) memset(a , b , sizeof(a))
#define FOR(i, x, n) for(int i = x;i <= n; i++)

ll fac[2][505];
ll cnt, ct;

ll pri[6] = {2, 3, 7, 109, 167, 500000003};
ll num[6] = {4, 2, 1, 2, 1, 1};

const ll mod = 1e9 + 7;
const int maxn = 5e6 + 10;

struct Matrix{
    ll m[2][2];
};

Matrix A;

Matrix I = {1, 0, 0 , 1}; // 单位矩阵

Matrix multi(Matrix a, Matrix b) // 矩阵乘法
{
    Matrix C;
    for(int i = 0;i < 2; i++)
    {
        for(int j = 0;j < 2; j++)
        {
            C.m[i][j] = 0;
            for(int k = 0;k < 2; k++)
            {
                C.m[i][j] = (C.m[i][j] + a.m[i][k] * b.m[k][j] % mod) % mod; 
            }
            C.m[i][j] %= mod;
        }
    }
    return C;
}

Matrix quick_Matrix(Matrix a, ll b) // 矩阵快速幂
{
    Matrix ans = I, base = a;
    while(b)
    {
        if(b & 1)
        {
            ans = multi(a, base);
        }
        base = multi(base, base);
        b >>= 1;
    }
    return ans;
}

ll quick_pow(ll a, ll b) ;

ll legendre(ll a, ll p) // 勒让德符号 = {1, -1, 0}
{
    ll k = quick_pow(a, (p - 1) >> 1);
    if(k == 1)
        return 1;
    else 
        return -1;
}

void DFS(int dept,ll product = 1)
{
    if(dept == cnt)
    {
        fac[1][ct++] = product;
        return;
    }
    for(int i=0; i<=num[dept]; i++)
    {
        DFS(dept+1,product);
        product *= pri[dept];
    }
}

bool Fib_node(Matrix a, ll n) // n是否为循环节
{
    Matrix ans = quick_Matrix(a, n);
    return (ans.m[0][0] == 1 && ans.m[0][1] == 0 && ans.m[1][0] == 0 && ans.m[1][1] == 1); // 是否为单位矩阵I
}

ll Fib_Cyclic_node(ll a, ll b, ll c, ll d) // 广义斐波那契循环节斐波那契循环节
{
    fac[0][0] = 1;
    fac[0][1] = 2;
    fac[0][3] = 500000003;
    fac[0][3] = 1000000006;
    ll c = a * a - 4 * b;
    A.m[0][0] = a;
    A.m[0][1] = b;
    A.m[1][0] = 1;
    A.m[1][1] = 0; 
    if(legendre(c, mod) == 1) // c是否为1e9+7的二次剩余
    {
        for(int i = 0;i < 4; i++)
        {
            if(Fib_node(A, fac[0][i]))
                return fac[0][i];
        }
    }
    else
    {
        ct = 0;
        cnt = 6;
        DFS(0, 1);
        sort(fac[1], fac[1] + ct);
        for(int i = 0;i < ct; i++)
        {
            if(Fib_node(A, fac[1][i]))
                return fac[1][i];  
        }
    }
    
}

int main()
{
    ll a, b, c, d;
    cin >> a >> b >> c >> d; 
    ll n = Fib_Cyclic_node(a, b, c, d); // 广义斐波那契循环节循环节长度
    cout << n << endl;
}

\end{lstlisting}
\subsection{矩阵快速幂求解}
\begin{lstlisting}
// 斐波那契循环节

typedef long long ll;

const ll mod = 1e9 + 7;

struct Martix {
    int n, m;
    ll a[70][70];
    Martix operator * (const Martix& rhs) const {
        Martix ans;
        memset(&ans, 0, sizeof(ans));
        ans.n = n; ans.m = rhs.m;
        for(int i = 0;i <= ans.n; i++) {
            for(int j = 0;j <= ans.m; j++) {
                for(int k = 0;k <= m; k++) {
                    ans.a[i][j] = (ans.a[i][j] + a[i][j] * rhs.a[i][j] % mod) % mod;
                }
            }
        }
        return ans;
    }
    Martix() {n = m = 0; memset(a, 0, sizeof(a)); }
    void operator *= (const Martix& rhs) {*this = *this * rhs; }
};

struct Matrix{
    ll m[2][2];
};

Matrix ans;

Matrix I = {1, 1, 1 , 0}; // 单位矩阵

Matrix multi(Matrix a, Matrix b) {
    Matrix C;
    for(int i = 0;i < 2; i++) {
        for(int j = 0;j < 2; j++) {
            C.m[i][j] = 0;
            for(int k = 0;k < 2; k++) {
                C.m[i][j] = (C.m[i][j] + a.m[i][k] * b.m[k][j] % mod) % mod;
            }
            C.m[i][j] %= mod;
        }
    }
    return C;
}

void quick_Matrix(ll n) {
    Matrix base = I;
    ans.m[0][0] = 1;
    ans.m[1][1] = 1;
    while(n) {
        if(n & 1) ans = multi(ans, base);
        base = multi(base, base);
        n >>= 1;
    }
}

int main()
{
    ll n; 
    cin >> n;
    quick_Matrix(n);
    cout << ans.m[0][1] << endl;
}
\end{lstlisting}
\subsection{拉格朗日插值求和}
\begin{lstlisting}
namespace polysum {
#define rep(i, a, n) for (int i=a;i<n;i++)
#define per(i, a, n) for (int i=n-1;i>=a;i--)
    const int D = 1010000;///可能需要用到的最高次
    ll a[D], f[D], g[D], p[D], p1[D], p2[D], b[D], h[D][2], C[D], num[D];

    ll powmod(ll a, ll b) {
        ll res = 1;
        a %= mod;
        assert(b >= 0);
        for (; b; b >>= 1) {
            if (b & 1)res = res * a % mod;
            a = a * a % mod;
        }
        return res;
    }

    ///函数用途：给出数列的（d+1）项，其中d为最高次方项
    ///求出数列的第n项，数组下标从0开始
    ll calcn(int d, ll *a, ll n) { /// a[0].. a[d]  a[n]
        if (n <= d) return a[n];
        p1[0] = p2[0] = 1;
        rep(i, 0, d + 1) {
            ll t = (n - i + mod) % mod;
            p1[i + 1] = p1[i] * t % mod;
        }
        rep(i, 0, d + 1) {
            ll t = (n - d + i + mod) % mod;
            p2[i + 1] = p2[i] * t % mod;
        }
        ll ans = 0;
        rep(i, 0, d + 1) {
            ll t = g[i] * g[d - i] % mod * p1[i] % mod * p2[d - i] % mod * a[i] % mod;
            if ((d - i) & 1) ans = (ans - t + mod) % mod;
            else ans = (ans + t) % mod;
        }
        return ans;
    }

    void init(int M) {///用到的最高次
        f[0] = f[1] = g[0] = g[1] = 1;
        rep(i, 2, M + 5) f[i] = f[i - 1] * i % mod;
        g[M + 4] = powmod(f[M + 4], mod - 2);
        per(i, 1, M + 4) g[i] = g[i + 1] * (i + 1) % mod;///费马小定理筛逆元
    }

    ///函数用途：给出数列的（m+1）项，其中m为最高次方
    ///求出数列的前（n-1）项的和（从第0项开始）
    ll polysum(ll m, ll *a, ll n) { /// a[0].. a[m] \sum_{i=0}^{n-1} a[i]
        for (int i = 0; i <= m; i++) b[i] = a[i];

        ///前n项和，其最高次幂加1
        b[m + 1] = calcn(m, b, m + 1);
        rep(i, 1, m + 2) b[i] = (b[i - 1] + b[i]) % mod;
        return calcn(m + 1, b, n - 1);
    }

    ll qpolysum(ll R, ll n, ll *a, ll m) { /// a[0].. a[m] \sum_{i=0}^{n-1} a[i]*R^i
        if (R == 1) return polysum(n, a, m);
        a[m + 1] = calcn(m, a, m + 1);
        ll r = powmod(R, mod - 2), p3 = 0, p4 = 0, c, ans;
        h[0][0] = 0;
        h[0][1] = 1;
        rep(i, 1, m + 2) {
            h[i][0] = (h[i - 1][0] + a[i - 1]) * r % mod;
            h[i][1] = h[i - 1][1] * r % mod;
        }
        rep(i, 0, m + 2) {
            ll t = g[i] * g[m + 1 - i] % mod;
            if (i & 1) p3 = ((p3 - h[i][0] * t) % mod + mod) % mod, p4 = ((p4 - h[i][1] * t) % mod + mod) % mod;
            else p3 = (p3 + h[i][0] * t) % mod, p4 = (p4 + h[i][1] * t) % mod;
        }
        c = powmod(p4, mod - 2) * (mod - p3) % mod;
        rep(i, 0, m + 2) h[i][0] = (h[i][0] + h[i][1] * c) % mod;
        rep(i, 0, m + 2) C[i] = h[i][0];
        ans = (calcn(m, C, n) * powmod(R, n) - c) % mod;
        if (ans < 0) ans += mod;
        return ans;
    }

    ll solve(ll n, int k) {
        init(k + 10);
        for (int i = 0; i <= k + 1; i++) num[i] = powmod((ll) i + 1, k);
        ll ans = polysum(k + 1, num, n) % mod;
        return ans;
    }
}

void solve() {
    ll n;
    int k;
    cin >> n >> k;
    cout << polysum::solve(n, k) << endl;
}
\end{lstlisting}
\subsection{四方定理}
\begin{lstlisting}

// 暴力穷举查找

void square(int n)
{
    int ans = 0;
    for(int i = 1;i <= n / 2; i++)
        for(int j = 0;j <= i; j++)
            for(int k = 0;k <= j; k++)
                for(int q = 0;q <= k; q++)
                    if(i * i + j * j + k * k + q * q == n)
                        ans++;
}


// 动规背包优化

const int N = 1e5 + 10;

int dp[5][N];

void square() {
    dp[0][0] = 1;
    for(int i = 1;i <= 200; i++) {
        for(int j = 1;j <= 4; j++) {
            for(int k = 1;k <= 32768; k++) {
                if(i * i <= k)
                    dp[j][k] += dp[j - 1][k - i * i];
            }
        }
    }
}\end{lstlisting}
\subsection{高斯消元}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N=210;
int a[N][N];//增广矩阵
int x[N];//解集
int freeX[N];//自由变元
// equ:方程个数 var:变量个数
int Gauss(int equ, int var){//返回自由变元个数
    /*初始化*/
    for(int i = 0;i <= var; i++){
        x[i] = 0;
        freeX[i] = 0;
    }

    /*转换为阶梯阵*/
    int col = 0;//当前处理的列
    int num = 0;//自由变元的序号
    int k;//当前处理的行
    for(k = 0;k < equ && col < var; k++, col++) {//枚举当前处理的行
        int maxr = k;//当前列绝对值最大的行
        for(int i = k + 1;i < equ; i++){//寻找当前列绝对值最大的行
            if(a[i][col] > a[maxr][col]){
                maxr = i;
                swap(a[k], a[maxr]);//与第k行交换
                break;
            }
        }
        if(a[k][col] == 0){//col列第k行以下全是0，处理当前行的下一列
            freeX[num++] = col;//记录自由变元
            k--;
            continue;
        }

        for(int i = k + 1;i < equ; i++){
            if(a[i][col] != 0){
                for(int j = col;j < var + 1; j++){//对于下面出现该列中有1的行，需要把1消掉
                    a[i][j] ^= a[k][j];
                }
            }
        }
    }

    /*求解*/
    //无解：化简的增广阵中存在(0,0,...,a)这样的行，且a!=0
    for(int i = k;i < equ; i++)
        if(a[i][col] != 0)
            return -1;

    //无穷解: 在var*(var+1)的增广阵中出现(0,0,...,0)这样的行
    if(k < var)//返回自由变元数
        return var - k;//自由变元有var-k个

    //唯一解: 在var*(var+1)的增广阵中形成严格的上三角阵
    for(int i = var - 1;i >= 0; i--){//计算解集
        x[i] = a[i][var];
        for(int j = i + 1;j < var; j++)
            x[i] ^= (a[i][j] && x[j]);
    }
    return 0;
}\end{lstlisting}
\subsection{矩阵求逆}
\begin{lstlisting}
//原始矩阵A[0, n - 1][0, n - 1]
//右边一个单位阵I, 在a[0, n - 1][n, (n << 1) - 1]
//将左边A变成单位阵时，右边的I变为A^-1

ll a[MAX][MAX];
bool Gauss(int n) {
    for (int i = 0, r; i < n; i++) {
        r = i;
        for (int j = i + 1; j < n; j++)
            if (a[j][i] > a[r][i]) r = j;
        if (r != i) swap(a[i], a[r]);
        if (!a[i][i]) return false;//无解

        ll inv = qpow(a[i][i], mod - 2);
        for (int k = 0; k < n; k++) {
            if (k == i) continue;
            ll t = a[k][i] * inv % mod;
            for (int j = i; j < (n << 1); j++)
                a[k][j] = (a[k][j] - t * a[i][j] % mod + mod) % mod;
        }
        for (int j = 0; j < (n << 1); j++) a[i][j] = a[i][j] * inv % mod;
    }
    return true;
}

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        a[i][i + n] = 1;
        for (int j = 0; j < n; j++)
            scanf("%lld", &a[i][j]);
    }
    if(Gauss(n)) {
        for(int i = 0;i < n; i++) {
            for(int j = n;j < n * 2; j++) {
                cout << a[i][j] << " ";
            }
            cout << endl;
        }
    }
    else cout << "No Solution" << endl;
}
\end{lstlisting}
\subsection{可删除线性基}
\begin{lstlisting}
// 离线删除操作，维护线性基中每个元素的最晚删除时间。

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxl = 60;

struct LinearBasis {
    ll a[maxl + 10], tim[maxl + 10]; 
    int n, size; // 每个相同异或值有2^{n-size}个
    vector<ll> v;

    LinearBasis() {
        memset(a, 0, sizeof(a));
        size = n = 0;
        v.clear();
    }

    void insert(ll x, ll t) {
        n++;
        for(int i = maxl;i >= 0; i--) {
            if(!(x >> i & 1)) continue ;
            if(a[i]) {
                if(t > tim[i]) swap(t, tim[i]), swap(x, a[i]);
                x ^= a[i];
            }
            else {
                ++size;
                a[i] = x; tim[i] = t;
                return ;
            }
        }
    }

    void erase(ll t) {
        for(int i = maxl;i >= 0; i--) {
            if(tim[i] == t) {
                a[i] = tim[i] = 0; --size;
                return ;
            }
        }
    }
};

int main() {
    LinearBasis lb;
    int n, m; cin >> n >> m;
    vector<ll> opt(n + 10), a(n + 10), del(n + 10), pre(n + 10);
    for(int i = 1;i <= m; i++) {
        cin >> opt[i] >> a[i];
        if(opt[i] == 1) pre[a[i]] = i, del[i] = m + 1;
        else del[pre[a[i]]] = i;
    }
    ll ans = 0;
    for(int i = 1;i <= m; i++) {
        if(opt[i] == 1) lb.insert(a[i], del[i]);
        else lb.erase(i);
        ans ^= 1ll << (lb.n - lb.size);
    }
    cout << ans << endl;
}\end{lstlisting}
\subsection{普通线性基}
\begin{lstlisting}
// 每个异或值都相同的个数都为2^n-r,所以不同的异或值有2^r个. 
#include <bits/stdc++.h>
using namespace  std;

typedef long long ll;
const int maxl = 60;
ll quick_pow(ll a, ll b) ;
struct LinearBasis {
    ll a[maxl + 10]; 
    int n, size; // 每个相同异或值有2^{n-size}个
    vector<ll> v;

    LinearBasis() {
        memset(a, 0, sizeof(a));
        size = n = 0;
        v.clear();
    }

    void insert(ll t) {
        n++;
        for (int i = maxl; i >= 0; --i) {
            if (!(t >> i & 1)) continue;
            if (a[i]) t ^= a[i];
            else {
                ++size;
                // Rebuild 
                for (int j = i - 1; j >= 0; j--) if (t >> j & 1) t ^= a[j];
                for (int j = i + 1; j <= maxl; ++j) if (a[j] >> i & 1) a[j] ^= t;
                //
                a[i] = t;
                return;
            }
        }
    }

    // 与Rebuild配套使用
    void basis() {
        for (int i = 0; i <= maxl; ++i) if (a[i]) v.push_back(i);
    }

    // 查询能否xor出x这个数
    bool find(ll x) {
        for(int i = maxl;i >= 0; i--) {
            if(x >> i & 1) {
                if(!a[i]) return 0;
                x ^= a[i];
            }
        }
        return 1;
    }

    // 查询异或最大值
    ll askmax() {
        ll ans = 0;
        for(int i = maxl;i >= 0; i--) ans = max(ans, ans ^ a[i]);
        return ans;
    }

    // 查询异或最小值
    ll askmin() {
        for(int i = 0;i <= maxl; i++) if(a[i]) return a[i];
        return 0;
    }

    // 查询异或第k大
    ll askmaxk(ll x) {
        
    }

    // 查询异或第k小
    ll askmink(ll x) {
        if(v.size() != n) x--;
        if(!x) return 0;
        if(x >= (1ll << v.size())) return -1;
        ll ans = 0;
        for(int i = 0;i < v.size(); i++) {
            if(x >> i & 1) ans ^= a[v[i]];
        }
        return ans;
    }

    ll rank(ll x) {
        ll ret = 0;
        for (int i = 0; i < v.size(); ++i) if (x >> v[i] & 1) ret += 1LL << i;
        return ret;
    }
};


void solve() {
    int n, x, q;
    scanf("%d", &n);
    LinearBasis lb;
    for (int i = 0; i < n; ++i) scanf("%d", &x), lb.insert(x);
    lb.basis();
    scanf("%d", &q);
    ll num = quick_pow(2, n - lb.size);
    printf("%lld\n", (lb.rank(q) * num + 1));
}\end{lstlisting}
\subsection{区间修改区间线性基}
\begin{lstlisting}
#include<bits/stdc++.h>
#define maxn 200005
using namespace std;
struct Base{
	int a[31],cnt;
	void clear(){memset(a,0,sizeof a),cnt=0;}
	void ins(int x){
		if(cnt==30) return;
		for(int i=29;i>=0&&x;i--) if(x>>i&1){
			if(a[i]) x^=a[i];
			else {a[i]=x,cnt++;return;}
		}
	}
	void merge(const Base &B){
		for(int i=29;i>=0;i--) if(B.a[i]) ins(B.a[i]);
	}
}t[maxn<<2];
int n,m,a[maxn],b[maxn];
int arr[maxn];
void upd(int i,int v){for(;i<=n;i+=i&-i) arr[i]^=v;}
int qxor(int i){int s=0;for(;i;i-=i&-i) s^=arr[i];return s;}
void upd(int i){t[i]=t[i<<1],t[i].merge(t[i<<1|1]);}
void build(int i,int l,int r){
	if(l==r) return t[i].ins(b[l]);
	int mid=(l+r)>>1;
	build(i<<1,l,mid),build(i<<1|1,mid+1,r);
	upd(i);
}
void mdf(int i,int l,int r,int x){
	if(l==r) {t[i].clear(),t[i].ins(b[x]);return;}
	int mid=(l+r)>>1;
	x<=mid?mdf(i<<1,l,mid,x):mdf(i<<1|1,mid+1,r,x);
	upd(i);
}
void qry(int i,int l,int r,int x,int y){
	if(x<=l&&r<=y) return t[0].merge(t[i]);
	int mid=(l+r)>>1;
	if(x<=mid) qry(i<<1,l,mid,x,y);
	if(y>mid) qry(i<<1|1,mid+1,r,x,y);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),b[i]=a[i]^a[i-1],upd(i,b[i]);
	build(1,1,n);
	for(int op,l,r,x;m--;){
		scanf("%d%d%d",&op,&l,&r);
		if(op==1){
			scanf("%d",&x);
			upd(l,x),upd(r+1,x),b[l]^=x,b[r+1]^=x;
			mdf(1,1,n,l); if(r<n) mdf(1,1,n,r+1);
		}
		else{
			t[0].clear(),t[0].ins(qxor(l)); if(l<r) qry(1,1,n,l+1,r);
			printf("%d\n",1<<t[0].cnt);
		}
	}
}
\end{lstlisting}
\subsection{无修改区间线性基}
\begin{lstlisting}
// 扫描r，维护线性基中每个元素的最大左端点l。与删除操作类似。
// 这个可以强制在线，把每个r的线性基存下来即可。
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 10;
struct node {
    int l, r, id;
    bool operator < (const node &p) const {
        return r < p.r;
    }
}q[N];

const int maxl = 60;

struct LinearBasis {
    ll a[maxl + 10], pos[maxl + 10];
    int n, size; // 每个相同异或值有2^{n-size}个
    vector<ll> v;

    LinearBasis() {
        memset(a, 0, sizeof(a));
        size = n = 0;
        v.clear();
    }

    void insert(ll t, ll id) {
        n++;
        for(int i = maxl;i >= 0; i--) {
            if(!(t >> i & 1)) continue ;
            if(a[i]) {
                if(id > pos[i]) swap(id, pos[i]), swap(t, a[i]);
                t ^= a[i];
            }
            else {
                a[i] = t;
                pos[i] = id;
                return ;
            }
        }
    }

    int askmax(ll x) {
        ll ans = 0;
        for(int i = maxl;i >= 0; i--) {
//            if(pos[i] >= x && !(ans >> i & 1)) ans ^= a[i];
            if(pos[i] >= x) ans = max(ans, ans ^ a[i]);
        }
        return ans;
    }
};

// 给你n个数，每次查询 [公式] 这个区间，问着个区间的最大异或值。

void solve() {
    LinearBasis lb;
    int n; cin >> n;
    VI a(n + 1);
    for(int i = 1;i <= n; i++) cin >> a[i];
    int m; cin >> m;
    VI ans(m + 1);
    for(int i = 1;i <= m; i++) cin >> q[i].l >> q[i].r, q[i].id = i;
    sort(q + 1, q + m + 1);
    for(int i = 1, j = 1;i <= n; i++) {
        lb.insert(a[i], i);
        for(; j <= m && q[j].r <= i; j++) ans[q[j].id] = lb.askmax(q[j].l);
    }
    for(int i = 1;i <= m; i++) cout << ans[i] << endl;
}
\end{lstlisting}
\subsection{FFT}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const double PI = acos(-1);
const int N = 4e5 + 10;

struct Complex {
    double a, b;
    Complex(double a = 0, double b = 0): a(a), b(b) {}
    Complex operator * (const Complex &rhs) { return Complex(a * rhs.a - b * rhs.b, a * rhs.b + b * rhs.a); }
    Complex operator + (const Complex &rhs) { return Complex(a + rhs.a, b + rhs.b); }
    Complex operator - (const Complex &rhs) { return Complex(a - rhs.a, b - rhs.b); }
};

int tr[N];

void FFT(Complex *A, int len, int type) {
    for (int i = 0; i < len; i++) if (i < tr[i]) swap(A[i], A[tr[i]]);
    for (int i = 2; i <= len; i <<= 1) {//区间长度
        int mid = i / 2;
        Complex Wn(cos(2 * PI / i), type * sin(2 * PI / i));//单位根
        for (int k = 0; k < len; k += i) {//每个子问题的起始点
            Complex w(1, 0);//omega
            for (int l = k; l < k + mid; l++) {
                Complex t = w * A[l + mid];
                A[l + mid] = A[l] - t;
                A[l] = A[l] + t;
                w = w * Wn;
            }
        }
    }
}

void mul(ll *x, int n, ll *y, int m) {
    static Complex a[N], b[N];
    for(int i = 0;i <= n; i++) a[i].a = x[i];
    for(int i = 0;i <= m; i++) b[i].a = y[i];
    int len = 1; while (len <= (n + m)) len <<= 1;
    for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
    FFT(a, len, 1), FFT(b, len, 1);
    for (int i = 0; i < len; i++) a[i] = a[i] * b[i];
    FFT(a, len, -1);
    for (int i = 0; i < len; i++) x[i] = (ll)(a[i].a / len + 0.5);
}

ll a[N], b[N];

void solve() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 0; i <= n; i++) scanf("%lld", &a[i]);
    for (int i = 0; i <= m; i++) scanf("%lld", &b[i]);

    mul(a, n, b, m);
    for (int i = 0; i <= n + m; i++)
        printf("%lld ", a[i]);
}\end{lstlisting}
\subsection{FWT}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 998244353;

const int N = 1e5 + 10;
int a[N], b[N];

inline void FWT_OR(int *f, int n, int opt) {
    for (int o = 2, k = 1; o <= n; o <<= 1, k <<= 1)
        for (int i = 0; i < n; i += o)
            for (int j = 0; j < k; j++)
                f[i + j + k] = (f[i + j + k] + 1ll * f[i + j] * opt % mod + mod) % mod;
}

inline void FWT_AND(int *f, int n, int opt) {
    for (int o = 2, k = 1; o <= n; o <<= 1, k <<= 1)
        for (int i = 0; i < n; i += o)
            for (int j = 0; j < k; j++)
                f[i + j] = (f[i + j] + 1ll * f[i + j + k] * opt % mod + mod) % mod;
}

inline void FWT_XOR(int *f, int n, int opt) {
    for (int o = 2, k = 1; o <= n; o <<= 1, k <<= 1)
        for (int i = 0; i < n; i += o)
            for (int j = 0; j < k; j++) {
                ll a0 = f[i + j], a1 = f[i + j + k];
                f[i + j] = (a0 + a1) % mod * opt % mod;
                f[i + j + k] = (a0 - a1 + mod) % mod * opt % mod;
            }
}

inline void mul_OR(int *a, int *b, int n) {
    FWT_OR(a, n, 1); FWT_OR(b, n, 1);
    for(int i = 0;i < n; i++) a[i] = a[i] * b[i] % mod;
    FWT_OR(a, n, -1);
}

inline void mul_AND(int *a, int *b, int n) {
    FWT_AND(a, n, 1); FWT_AND(b, n, 1);
    for(int i = 0;i < n; i++) a[i] = a[i] * b[i] % mod;
    FWT_AND(a, n, -1);
}

ll quick_pow(ll a, ll b) ;

inline void mul_XOR(int *a, int *b, int n) {
    ll inv2 = quick_pow(mod, mod - 2);
    FWT_XOR(a, n, 1); FWT_XOR(b, n, 1);
    for(int i = 0;i < n; i++) a[i] = a[i] * b[i] % mod;
    FWT_XOR(a, n, inv2);
}

int main() {
    int n;
    cin >> n;
    n = 1 << n;
    for(int i = 0;i < n; i++) cin >> a[i];
    for(int i = 0;i < n; i++) cin >> b[i];
    
    mul_OR(a, b, n);
    mul_AND(a, b, n);
    mul_XOR(a, b, n);


}\end{lstlisting}
\subsection{NTT}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;

//mod比最终答案要大
//如果中间乘法计算会爆ll, 换成按位乘
//精度高, 比3次FFT要快(复数运算=>整数运算)
//4倍空间

ll qpow(ll a, ll b, ll mod) ;

const ll mod = 998244353;
const ll G = 3;
const ll invG = qpow(G, mod - 2, mod);
int tr[N];

void NTT(ll *A, int len, int type) {
    for (int i = 0; i < len; i++) if (i < tr[i]) swap(A[i], A[tr[i]]);
    for (int i = 2; i <= len; i <<= 1) {
        int mid = i / 2;
        ll Wn = qpow(type == 1 ? G : invG, (mod - 1) / i, mod);
        for (int k = 0; k < len; k += i) {
            ll w = 1;
            for (int l = k; l < k + mid; l++) {
                ll t = w * A[l + mid] % mod;
                A[l + mid] = (A[l] - t + mod) % mod;
                A[l] = (A[l] + t) % mod;
                w = w * Wn % mod;
            }
        }
    }
    if (type == -1) {
        ll invn = qpow(len, mod - 2, mod);
        for (int i = 0; i < len; i++)
            A[i] = A[i] * invn % mod;
    }
}

void mul(ll *a, ll *b, int n) {
    int len = 1; while (len <= n) len <<= 1;
    for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
    NTT(a, len, 1), NTT(b, len, 1);
    for (int i = 0; i < len; i++) a[i] = a[i] * b[i] % mod;
    NTT(a, len, -1);
}

int n, m;
ll a[N], b[N];

int main() {

    scanf("%d%d", &n, &m);
    for (int i = 0; i <= n; i++) scanf("%lld", &a[i]);
    for (int i = 0; i <= m; i++) scanf("%lld", &b[i]);

    mul(a, b, n + m);
    for (int i = 0; i <= n + m; i++)
        printf("%lld ", a[i]);

    return 0;
}\end{lstlisting}
\subsection{cdq分治FFT}
\begin{lstlisting}
// hdu 7054
// 求解(1+x^{a1})*(1+x^{a2})*...*(1+x^{an})
// \sum_{i=1}^n a_i <= 1e6.

// 可以f[i][j]，前i个数的和为j的方案数，可以用生成函数转换，并用多项式求解，同时分治FFT优化。

const int N = 1e5 + 10;
int tr[N];
int getLen(int n) ;

void FFT(Complex *A, int len) ;

inline void MTT(ll *x, ll *y, ll *z, int len) ;

struct Poly {
    ll *p;
    int len;
    void init(int len) {
        p = a + cnt;
        this -> len = len;
        for(int i = 0;i <= len; i++) p[i] = read();
        cnt += len + 1;
    }

    void mul(const Poly b) {
        static ll x[N], y[N];
        int LEN = getLen(len + b.len);
        for(int i = 0;i <= len; i++) x[i] = p[i];
        for(int i = 0;i <= b.len; i++) y[i] = b.p[i];
        for(int i = len + 1;i <= LEN; i++) x[i] = 0;
        for(int i = b.len + 1;i <= LEN; i++) y[i] = 0;
        MTT(x, y, p, LEN);
        this -> len += b.len;
        // 不知道为啥要两倍，可能会有不为0的情况，管他呢
        for(int i = len + 1;i <= 2 * LEN; i++) p[i] = 0;
        for(int i = 0;i <= LEN; i++) x[i] = y[i] = 0;
    }
};

Poly cdq(int l, int r) {
    Poly res;
    if(l == r) res.init(len); // 长度
    else {
        int mid = (l + r) / 2;
        res = cdq(l, mid);
        res.mul(cdq(mid + 1, r));
    }
    return res;
}

void solve() {
    mem(a, 0);
    int n = read();
    cnt = 0;
    ll ans = 1;
    Poly res = cdq(1, n);
    for(int i = 0;i < n; i++) cout << res.p[i] << " ";
}\end{lstlisting}
\subsection{求逆分治FFT}
\begin{lstlisting}
// f[i] = \sum_{j=1}^i f[i-j] * g[j]
// g相同，可以用多项式求逆
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const double PI = acos(-1);
const int N = 1e5 + 10;

struct Complex {
    double x, y;
    Complex(double a = 0, double b = 0): x(a), y(b) {}
    Complex operator + (const Complex &rhs) { return Complex(x + rhs.x, y + rhs.y); }
    Complex operator - (const Complex &rhs) { return Complex(x - rhs.x, y - rhs.y); }
    Complex operator * (const Complex &rhs) { return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); }
    Complex conj() { return Complex(x, -y); }
} w[N];

ll mod;
int tr[N];
ll F[N], G[N];

ll quick_pow(ll a, ll b) ;

int getLen(int n) ;

void FFT(Complex *A, int len) ;

inline void MTT(ll *x, ll *y, ll *z, int len) ;

void Get_Inv(ll *f, ll *g, int n) ;

void fenzhiFFT(ll *f, ll *g, int n) {
    static ll a[N];
    for(int i = 1;i < n; i++) a[i] = (mod - f[i]) % mod;
    a[0] = 1;
    Get_Inv(a, g, n);

    for(int i = 0;i < n; i++) {
        a[i] = 0;
    }
}

int main() {
    int n;
    cin >> n;
    for(int i = 1;i < n; i++) cin >> G[i];
    fenzhiFFT(G, F, n);
    
    for(int i = 0;i < n; i++) cout << F[i] << " ";
}\end{lstlisting}
\subsection{多项式求逆}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const double PI = acos(-1);
const int N = 1e5 + 10;

struct Complex {
    double x, y;
    Complex(double a = 0, double b = 0): x(a), y(b) {}
    Complex operator + (const Complex &rhs) { return Complex(x + rhs.x, y + rhs.y); }
    Complex operator - (const Complex &rhs) { return Complex(x - rhs.x, y - rhs.y); }
    Complex operator * (const Complex &rhs) { return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); }
    Complex conj() { return Complex(x, -y); }
} w[N];

ll mod;
int tr[N];
ll F[N], G[N];

ll quick_pow(ll a, ll b) ;

int getLen(int n) {
    int len = 1; while (len < (n << 1)) len <<= 1;
    for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
    for (int i = 0; i < len; i++) w[i] = w[i] = Complex(cos(2 * PI * i / len), sin(2 * PI * i / len));
    return len;
}

void FFT(Complex *A, int len) ;

inline void MTT(ll *x, ll *y, ll *z, int len) ;

void Get_Inv(ll *f, ll *g, int n) {
    if(n == 1) { g[0] = quick_pow(f[0], mod - 2); return ; }
    Get_Inv(f, g, (n + 1) >> 1);

    int len = getLen(n);
    static ll c[N];
    for(int i = 0;i < len; i++) c[i] = i < n ? f[i] : 0;
    MTT(c, g, c, len); MTT(c, g, c, len);
    for(int i = 0;i < n; i++) g[i] = (2ll * g[i] - c[i] + mod) % mod;
    for(int i = n;i < len; i++) g[i] = 0;
    for(int i = 0;i < len; i++) c[i] = 0;
}

int main() {
    int n;
    cin >> n;
    for(int i = 0;i < n; i++) cin >> F[i];
    Get_Inv(F, G, n);
    for(int i = 0;i < n; i++) cout << G[i] << " ";
}
\end{lstlisting}
\subsection{多项式快速幂}
\begin{lstlisting}
// f(x)^k，k较小时，可取，每次FFT之后长度*2
#define maxfft 1048576+5

struct cp {
    double a, b;
    cp operator+(const cp &o) const { return (cp) {a + o.a, b + o.b}; }
    cp operator-(const cp &o) const { return (cp) {a - o.a, b - o.b}; }
    cp operator*(const cp &o) const { return (cp) {a * o.a - b * o.b, b * o.a + a * o.b}; }
    cp operator*(const double &o) const { return (cp) {a * o, b * o}; }
    cp operator!() const { return (cp) {a, -b}; }
} w[maxfft];

int pos[maxfft];

void fft_init(int len) {
    int j = 0;
    while ((1 << j) < len)j++;
    j--;
    for (int i = 0; i < len; i++)
        pos[i] = pos[i >> 1] >> 1 | ((i & 1) << j);
}

void fft(cp *x, int len, int sta) {
    for (int i = 0; i < len; i++)
        if (i < pos[i])swap(x[i], x[pos[i]]);
    w[0] = (cp) {1, 0};
    for (unsigned i = 2; i <= len; i <<= 1) {
        cp g = (cp) {cos(2 * PI / i), sin(2 * PI / i) * sta};
        for (int j = i >> 1; j >= 0; j -= 2)w[j] = w[j >> 1];
        for (int j = 1; j < i >> 1; j += 2)w[j] = w[j - 1] * g;
        for (int j = 0; j < len; j += i) {
            cp *a = x + j, *b = a + (i >> 1);
            for (int l = 0; l < i >> 1; l++) {
                cp o = b[l] * w[l];
                b[l] = a[l] - o;
                a[l] = a[l] + o;
            }
        }
    }
    if (sta == -1)for (int i = 0; i < len; i++)x[i].a /= len, x[i].b /= len;
}

cp x[maxfft], y[maxfft], z[maxfft];

void FFT(int *a, int *b, int n, int m, int *c) {
    int len = 1;
    while (len < (n + m) >> 1)len <<= 1;
    fft_init(len);
    for (int i = n / 2; i < len; i++)x[i].a = x[i].b = 0;
    for (int i = m / 2; i < len; i++)y[i].a = y[i].b = 0;
    for (int i = 0; i < n; i++)(i & 1 ? x[i >> 1].b : x[i >> 1].a) = a[i];
    for (int i = 0; i < m; i++)(i & 1 ? y[i >> 1].b : y[i >> 1].a) = b[i];
    fft(x, len, 1), fft(y, len, 1);
    for (int i = 0; i < len / 2; i++) {
        int j = len - 1 & len - i;
        z[i] = x[i] * y[i] - (x[i] - !x[j]) * (y[i] - !y[j]) * (w[i] + (cp) {1, 0}) * 0.25;
    }
    for (int i = len / 2; i < len; i++) {
        int j = len - 1 & len - i;
        z[i] = x[i] * y[i] - (x[i] - !x[j]) * (y[i] - !y[j]) * ((cp) {1, 0} - w[i ^ len >> 1]) * 0.25;
    }
    fft(z, len, -1);
    for (int i = 0; i < n + m; i++)
        if (i & 1)c[i] = (int) (z[i >> 1].b + 0.5) ? 1 : 0;
        else c[i] = (int) (z[i >> 1].a + 0.5) ? 1 : 0;
}

int n, k, f[maxfft], g[maxfft];

void Pow(int *f, int len, int k, int *g) {
    g[0] = 1;
    while (k) {
        if (k & 1)FFT(g, f, len, len, g);
        FFT(f, f, len, len, f);
        k >>= 1;
        len <<= 1;
    }
}\end{lstlisting}
\subsection{多项式除法、取模}
\begin{lstlisting}

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const double PI = acos(-1);
const int N = 3e5 + 10;
ll mod;

struct Complex {
    double x, y;
    Complex(double a = 0, double b = 0): x(a), y(b) {}
    Complex operator + (const Complex &rhs) { return Complex(x + rhs.x, y + rhs.y); }
    Complex operator - (const Complex &rhs) { return Complex(x - rhs.x, y - rhs.y); }
    Complex operator * (const Complex &rhs) { return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); }
    Complex conj() { return Complex(x, -y); }
} w[N];

int tr[N];
ll F[N], G[N], D[N], R[N];

ll quick_pow(ll a, ll b) ;

int getLen(int n) ;

void FFT(Complex *A, int len) ;

inline void MTT(ll *x, ll *y, ll *z, int len) ;

void Get_Inv(ll *f, ll *g, int n) ;

void rever(ll *f, int n) { for(int i = 0, j = n - 1;i < j; i++, j--) swap(f[i], f[j]); }

void Get_Div(ll *f, ll *g, ll *d, ll *r, int n, int m) {
    static ll a[N], b[N], invb[N];
    for(int i = 0;i < n; i++) a[i] = f[i];
    for(int i = 0;i < m; i++) b[i] = g[i];
    rever(a, n); rever(b, m);
    //for(int i = 0;i < n - m + 1; i++) b[i] = i < m ? b[i] : 0;
    Get_Inv(b, invb, n - m + 1);

    int len = getLen(n);
    MTT(a, invb, a, len);
    rever(a, n - m + 1);
    for(int i = 0;i < len; i++) d[i] = i < n - m + 1 ? a[i] : 0;
    MTT(g, d, b, len);
    for(int i = 0;i < m; i++) { r[i] = (f[i] - b[i] + mod) % mod; }

    for(int i = m;i < len; i++) r[i] = 0;
    for(int i = 0;i < len; i++) a[i] = b[i] = invb[i] = 0;
}

int main() {
    int n, m;
    cin >> n >> m;
    for(int i = 0;i < n; i++) { cin >> F[i]; }
    for(int i = 0;i < m; i++) { cin >> G[i]; }
    Get_Div(F, G, D, R, n, m);

    for(int i = 0;i < n - m + 1; i++) cout << D[i] << " ";
    cout << endl;
    for(int i = 0;i < m - 1; i++) cout << R[i] << " ";
    cout << endl;
}
\end{lstlisting}
\subsection{多项式ln_Exp_Pow}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const double PI = acos(-1);

const int N = 1e6 + 10;

ll quick_pow(ll a, ll b) {
    ll ans = 1;
    while(b) {
        if(b & 1) ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans % mod;
}

const ll G = 3;
const ll invG = quick_pow(G, mod - 2);

int tr[N];
bool flag;

void NTT(ll *A, int len, int type) {
    for (int i = 0; i < len; i++) if (i < tr[i]) swap(A[i], A[tr[i]]);
    for (int i = 2; i <= len; i <<= 1) {
        int mid = i / 2;
        ll Wn = quick_pow(type == 1 ? G : invG, (mod - 1) / i);
        for (int k = 0; k < len; k += i) {
            ll w = 1;
            for (int l = k; l < k + mid; l++) {
                ll t = w * A[l + mid] % mod;
                A[l + mid] = (A[l] - t + mod) % mod;
                A[l] = (A[l] + t) % mod;
                w = w * Wn % mod;
            }
        }
    }
    if (type == -1) {
        ll invn = quick_pow(len, mod - 2);
        for (int i = 0; i < len; i++)
            A[i] = A[i] * invn % mod;
    }
}

void mul(ll *a, ll *b, int len) {
    for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
    NTT(a, len, 1), NTT(b, len, 1);
    for (int i = 0; i < len; i++) a[i] = a[i] * b[i] % mod;
    NTT(a, len, -1); NTT(b, len, -1);
}

int getLen(int n) {
    int len = 1; while (len <= (n << 1)) len <<= 1;
    return len;
}

void Get_Der(ll *f, ll *g, int len) { for(int i = 1;i < len; i++) g[i - 1] = f[i] * i % mod; g[len - 1] = 0; }

void Get_Int(ll *f, ll *g, int len) { for(int i = 1;i < len; i++) g[i] = f[i - 1] * quick_pow(i, mod - 2) % mod; g[0] = 0; }

void Get_Inv(ll *f, ll *g, int n) {
    if(n == 1) { g[0] = quick_pow(f[0], mod - 2); return ; }
    Get_Inv(f, g, (n + 1) >> 1);

    int len = getLen(n);
    static ll c[N];
    for(int i = 0;i < len; i++) c[i] = i < n ? f[i] : 0;
    mul(c, g, len);
    mul(c, g, len);
    for(int i = 0;i < n; i++) g[i] = (2ll * g[i] - c[i] + mod) % mod;
    for(int i = n;i < len; i++) g[i] = 0;
    for(int i = 0;i < len; i++) c[i] = 0;
}

void Get_Ln(ll *f, ll *g, int n) {
    static ll a[N], b[N];
    Get_Der(f, a, n);
    Get_Inv(f, b, n);
    int len = getLen(n);
    mul(a, b, len);
    Get_Int(a, g, len);
    for(int i = n;i < len; i++) g[i] = 0;
    for(int i = 0;i < len; i++) a[i] = b[i] = 0;
}

void Get_Exp(ll *f, ll *g, int n) {
    if(n == 1) return (void)(g[0] = 1);
    Get_Exp(f, g, (n + 1) >> 1);

    static ll a[N];
    Get_Ln(g, a, n);
    a[0] = (f[0] + 1 - a[0] + mod) % mod;
    for(int i = 1;i < n; i++) a[i] = (f[i] - a[i] + mod) % mod;
    int len = getLen(n);
    mul(g, a, len);
    for(int i = n;i < len; i++) g[i] = 0;
    for(int i = 0;i < len; i++) a[i] = 0;
}

void Get_Pow(ll *f, ll *g, int n, ll k1, ll k2) {
    static ll a[N], b[N], c[N];
    ll deg = 0; for(int i = 0;i < n && f[i] == 0; i++) ++ deg;
    if(deg * k1 > n || (flag && deg)) return ;
    ll f0 = f[deg], f0k = quick_pow(f0, k2), inv0 = quick_pow(f0, mod - 2);
    for(int i = deg;i < n; i++) a[i - deg] = f[i] * inv0 % mod;
    Get_Ln(a, b, n);
    for(int i = 0;i < n - deg * k1; i++) b[i] = b[i] * k1 % mod;
    Get_Exp(b, c, n);
    deg *= k1;
    for(int i = deg;i < n; i++) g[i] = (c[i - deg] * f0k % mod + mod) % mod;
    for(int i = 0;i < deg; i++) g[i] = 0;
    int len = getLen(n);
    for(int i = n;i < len; i++) g[i] = 0;
    for(int i = 0;i < len; i++) a[i] = b[i] = c[i] = 0;
}


ll a[N], ans[N];

void solve() {
    int n; string s; cin >> n >> s;
    ll k1 = 0, k2 = 0;
    for(int i = 0; i < s.length(); i++) {
        k1 = (k1 * 10 + s[i] - '0');
        flag |= (k1 >= mod);
        k1 %= mod;
        k2 = (k2 * 10 + s[i] - '0') % (mod - 1);
    }
    for(int i = 0; i < n; i++) cin >> a[i];
    Get_Pow(a, ans, n, k1, k2); // k1是底 % mod，k2是指数 % mod-1
    for(int i = 0;i < n; i++) cout << ans[i] << (i == n - 1 ? endl : " ");
}\end{lstlisting}
\subsection{任意模数MTT_拆系数法}
\begin{lstlisting}
//将多项式拆成(a1 * mod + a2) * (b1 * mod + b2)的形式
//=>a1 * b1 * mod ^ 2 + (a2 * b1 + a1 * b2) * mod + a2 * b2
//在利用DFT合并、IDFT合并，最终只需要4次DFT即可
//精度10^14
//4倍空间

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const double PI = acos(-1);
const int N = 1e5 + 10;

struct Complex {
    double x, y;
    Complex(double a = 0, double b = 0): x(a), y(b) {}
    Complex operator + (const Complex &rhs) { return Complex(x + rhs.x, y + rhs.y); }
    Complex operator - (const Complex &rhs) { return Complex(x - rhs.x, y - rhs.y); }
    Complex operator * (const Complex &rhs) { return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); }
    Complex conj() { return Complex(x, -y); }
} w[N];

int tr[N];
ll a[N], b[N], ans[N];

int getLen(int n) {
    int len = 1; while (len <= n) len <<= 1;
    for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
    for (int i = 0; i < len; i++) w[i] = w[i] = Complex(cos(2 * PI * i / len), sin(2 * PI * i / len));
    return len;
}

void FFT(Complex *A, int len) {
    for (int i = 0; i < len; i++) if(i < tr[i]) swap(A[i], A[tr[i]]);
    for (int i = 2, lyc = len >> 1; i <= len; i <<= 1, lyc >>= 1)
        for (int j = 0; j < len; j += i) {
            Complex *l = A + j, *r = A + j + (i >> 1), *p = w;
            for (int k = 0; k < i >> 1; k++) {
                Complex tmp = *r * *p;
                *r = *l - tmp, *l = *l + tmp;
                ++l, ++r, p += lyc;
            }
        }
}

inline void MTT(ll *x, ll *y, ll *z, int len) {
    for (int i = 0; i < len; i++) (x[i] += mod) %= mod, (y[i] += mod) %= mod;
    static Complex a[N], b[N];
    static Complex dfta[N], dftb[N], dftc[N], dftd[N];

    for (int i = 0; i < len; i++) a[i] = Complex(x[i] & 32767, x[i] >> 15);
    for (int i = 0; i < len; i++) b[i] = Complex(y[i] & 32767, y[i] >> 15);
    FFT(a, len), FFT(b, len);
    for (int i = 0; i < len; i++) {
        int j = (len - i) & (len - 1);
        static Complex da, db, dc, dd;
        da = (a[i] + a[j].conj()) * Complex(0.5, 0);
        db = (a[i] - a[j].conj()) * Complex(0, -0.5);
        dc = (b[i] + b[j].conj()) * Complex(0.5, 0);
        dd = (b[i] - b[j].conj()) * Complex(0, -0.5);
        dfta[j] = da * dc;
        dftb[j] = da * dd;
        dftc[j] = db * dc;
        dftd[j] = db * dd;
    }
    for (int i = 0; i < len; i++) a[i] = dfta[i] + dftb[i] * Complex(0, 1);
    for (int i = 0; i < len; i++) b[i] = dftc[i] + dftd[i] * Complex(0, 1);
    FFT(a, len), FFT(b, len);
    for (int i = 0; i < len; i++) {
        ll da = (ll)(a[i].x / len + 0.5) % mod;
        ll db = (ll)(a[i].y / len + 0.5) % mod;
        ll dc = (ll)(b[i].x / len + 0.5) % mod;
        ll dd = (ll)(b[i].y / len + 0.5) % mod;
        z[i] = (da + ((ll)(db + dc) << 15) + ((ll)dd << 30)) % mod;
    }
}

int main() {

    int n, m;
    scanf("%d%d%lld", &n, &m, &mod);
    for (int i = 0; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 0; i <= m; i++) scanf("%d", &b[i]);

    MTT(a, b, ans, n + m);
    for (int i = 0; i <= n + m; i++)
        printf("%s%d", i == 0 ? "" : " ", (ans[i] + mod) % mod);

    return 0;
}\end{lstlisting}
\subsection{任意模数NTT_三模数法}
\begin{lstlisting}
//要求选取的三个模数mod1 * mod2 * mod3 >= p^2*n
//优点是精度高，可达10^26
//缺点是常数大(9次NTT)，并且还使用了龟速乘
//4倍空间

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX = 4e5 + 10;

ll qmul(ll a, ll b, ll mod) {
    ll res = 0;
    while (b) {
        if (b & 1)
            res = (res + a) % mod;
        a = (a << 1) % mod;
        b >>= 1;
    }
    return res;
}

ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    while (b) {
        if (b & 1) res = qmul(res, a, mod);
        a = qmul(a, a, mod);
        b >>= 1;
    }
    return res;
}

const ll mod1 = 998244353, mod2 = 1004535809, mod3 = 469762049, mod4 = mod1 * mod2;
const ll G = 3;
ll a[3][MAX], b[3][MAX], ans[MAX], p;
int tr[MAX];

void NTT(ll *A, int len, int type, ll mod) {
    for (int i = 0; i < len; i++) if (i < tr[i]) swap(A[i], A[tr[i]]);
    for (int i = 2; i <= len; i <<= 1) {
        int mid = i / 2;
        ll Wn = qpow(type == 1 ? G : qpow(G, mod - 2, mod), (mod - 1) / i, mod);
        for (int k = 0; k < len; k += i) {
            ll w = 1;
            for (int l = k; l < k + mid; l++) {
                ll t = w * A[l + mid] % mod;
                A[l + mid] = (A[l] - t + mod) % mod;
                A[l] = (A[l] + t) % mod;
                w = w * Wn % mod;
            }
        }
    }
    if (type != 1) {
        ll invn = qpow(len, mod - 2, mod);
        for (int i = 0; i < len; i++) A[i] = A[i] * invn % mod;
    }
}

void mul(int i, int len, ll mod) {
    NTT(a[i], len, 1, mod), NTT(b[i], len, 1, mod);
    for (int j = 0; j < len; j++) a[i][j] = a[i][j] * b[i][j] % mod;
    NTT(a[i], len, -1, mod);
}

void CRT(int len) {
    ll inv1 = qpow(mod2, mod1 - 2, mod1);
    ll inv2 = qpow(mod1, mod2 - 2, mod2);
    ll inv3 = qpow(mod4 % mod3, mod3 - 2, mod3);
    for (int i = 0; i < len; i++) {
        ll t = 0;
        t = (t + qmul(a[0][i] * mod2 % mod4, inv1, mod4)) % mod4;
        t = (t + qmul(a[1][i] * mod1 % mod4, inv2, mod4)) % mod4;
        a[1][i] = t;
        t = (a[2][i] - a[1][i] % mod3 + mod3) % mod3 * inv3 % mod3;
        ans[i] = (mod4 % p * t % p + a[1][i] % p) % p;
    }
}

void doNTT(int n) {
    int len = 1; while (len <= n) len <<= 1;
    for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
    mul(0, len, mod1), mul(1, len, mod2), mul(2, len, mod3);
    CRT(len);
}

int main() {

    int n, m;
    scanf("%d%d%lld", &n, &m, &p);
    for (int i = 0; i <= n; i++) {
        ll x; scanf("%lld", &x);
        a[0][i] = a[1][i] = a[2][i] = x % p;
    }
    for (int i = 0; i <= m; i++) {
        ll x; scanf("%lld", &x);
        b[0][i] = b[1][i] = b[2][i] = x % p;
    }
    doNTT(n + m);
    for (int i = 0; i <= n + m; i++) printf("%lld ", ans[i]);

    return 0;
}\end{lstlisting}
\subsection{多项式优化常系数齐次线性递推}
\begin{lstlisting}

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const double PI = acos(-1);
const int N = 3e5 + 10;

struct Complex {
    double x, y;
    Complex(double a = 0, double b = 0): x(a), y(b) {}
    Complex operator + (const Complex &rhs) { return Complex(x + rhs.x, y + rhs.y); }
    Complex operator - (const Complex &rhs) { return Complex(x - rhs.x, y - rhs.y); }
    Complex operator * (const Complex &rhs) { return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); }
    Complex conj() { return Complex(x, -y); }
} w[N];

ll mod;
int n, k, len, tr[N];
ll a[N], h[N], ans[N], s[N], invG[N], G[N];

ll quick_pow(ll a, ll b) ;

int getLen(int n) ;

void rever(ll *f, int n) ;

void FFT(Complex *A, int len) ;

inline void MTT(ll *x, ll *y, ll *z, int len) ;

void Get_Inv(ll *f, ll *g, int n) ;


void Mod(ll *f,ll *g) {
    static ll tmp[N];
    rever(f, k + k - 1);
    for(int i = 0;i < k; i++) tmp[i] = f[i];
    MTT(tmp, invG, tmp, len);
    for(int i = k - 1; i < len; i++) tmp[i] = 0;
    rever(f, k + k - 1); rever(tmp, k - 1);
    MTT(tmp, G, tmp, len);
    for(int i = 0;i < k; i++) g[i] = (f[i] + mod - tmp[i]) % mod;
    for(int i = k;i < len; i++) g[i] = 0;
    for(int i = 0;i < len; i++) tmp[i] = 0;
}
void fpow(int b) {
	s[1] = 1; ans[0] = 1;
	while(b) {
		if(b & 1) { MTT(ans, s, ans, len); Mod(ans, ans); }
		MTT(s, s, s, len); Mod(s, s);
		b >>= 1;
	}
}

ll DITI(ll *a, ll *h, ll *ans, int n, int k) {
    G[k] = 1; for(int i = 1;i <= k; i++) G[k - i] = (mod - a[i]) % mod;
    rever(G, k + 1);
    len = getLen(k + 1);
    Get_Inv(G, invG, k + 1);
    for(int i = k + 1;i < len; i++) invG[i] = 0;
    rever(G, k + 1);
    fpow(n);
    ll Ans = 0;
    for(int i = 0;i < k; i++) Ans = (Ans + 1ll * h[i] * ans[i] % mod) % mod;
    return Ans;
}

int main() {
    int n, k;
    cin >> n >> k;
    for(int i = 1;i <= k; i++){ cin >> a[i]; a[i] = a[i] < 0 ? a[i] + mod : a[i]; }
    for(int i = 0;i < k; i++) { cin >> h[i]; h[i] = h[i] < 0 ? h[i] + mod : h[i]; }

    ll Ans = DITI(a, h, ans, n, k);
    cout << Ans << endl;
}\end{lstlisting}
\subsection{FFT加速带有通配符字符串匹配}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

// p[x] = \sum_{i=0}^{m-1} A[i]^3 * B[x-m+i+1] + \sum_{i=0}^{m-1} A[i] * B[x-m+i+1]^3 - 2 * \sum_{i=0}^{m-1} A[i]^2 * B[x-m+i+1]^2

const int N = 1e6 + 1e5;

ll qpow(ll a, ll b, ll mod) {
    ll ans = 1;
    while(b) {
        if(b & 1) ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans % mod;
}

const ll G = 3;
const ll invG = qpow(G, mod - 2, mod);
int tr[N];

void NTT(ll *A, int len, int type) {
    for (int i = 0; i < len; i++) if (i < tr[i]) swap(A[i], A[tr[i]]);
    for (int i = 2; i <= len; i <<= 1) {
        int mid = i / 2;
        ll Wn = qpow(type == 1 ? G : invG, (mod - 1) / i, mod);
        for (int k = 0; k < len; k += i) {
            ll w = 1;
            for (int l = k; l < k + mid; l++) {
                ll t = w * A[l + mid] % mod;
                A[l + mid] = (A[l] - t + mod) % mod;
                A[l] = (A[l] + t) % mod;
                w = w * Wn % mod;
            }
        }
    }
    if (type == -1) {
        ll invn = qpow(len, mod - 2, mod);
        for (int i = 0; i < len; i++)
            A[i] = A[i] * invn % mod;
    }
}

void mul(ll *a, ll *b, int n) {
    int len = 1; while (len <= n) len <<= 1;
    for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
    NTT(a, len, 1), NTT(b, len, 1);
    for (int i = 0; i < len; i++) a[i] = a[i] * b[i] % mod;
    NTT(a, len, -1);
}

ll a1[N], a2[N], a3[N], b1[N], b2[N], b3[N];

void solve() {
    int m, n; cin >> m >> n;
    string s, t; cin >> t >> s;
    for(int i = 0;i < m; i++) {
        if(t[i] == '*') continue ;
        int temp = t[i] - 'a' + 1;
        a1[i] = temp;
        a2[i] = temp * temp;
        a3[i] = temp * temp * temp;
    }
    for(int i = 0;i < n; i++) {
        if(s[i] == '*') continue;
        int temp = s[i] - 'a' + 1;
        b1[i] = temp;
        b2[i] = temp * temp;
        b3[i] = temp * temp * temp;
    }
    reverse(a1, a1 + m);
    reverse(a2, a2 + m);
    reverse(a3, a3 + m);
    mul(a1, b3, n + m);
    mul(a2, b2, n + m);
    mul(a3, b1, n + m);
    vector<int> ans;
    for(int x = m - 1;x < n; x++) {
        ll res = a1[x] + a3[x] - a2[x] * 2;
        if(!res) ans.push_back(x - m + 2);
    }
    cout << ans.size() << endl;
    for(int i = 0;i < ans.size(); i++) cout << ans[i] << (i == ans.size() - 1 ? endl : " ");
}\end{lstlisting}
\subsection{FFT加速朴素字符串匹配}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int N = 4e5 + 10;

// P[x] = \sum_{i=0}^{m-1} A[i] + \sum_{i=0}^{m-1} B[x - m + i + 1] - 2 * \sum_{i=0}^{m-1}A[i] * B[x - m + i + 1]

// reverse(a)

// 当串中的字符集较少时，可以针对每个字符进行FFT，计算每个字符对整个串的贡献

ll qpow(ll a, ll b, ll mod) ;

const ll mod = 998244353;
const ll G = 3;
const ll invG = qpow(G, mod - 2, mod);
int tr[N];

void NTT(ll *A, int len, int type) {
    for (int i = 0; i < len; i++) if (i < tr[i]) swap(A[i], A[tr[i]]);
    for (int i = 2; i <= len; i <<= 1) {
        int mid = i / 2;
        ll Wn = qpow(type == 1 ? G : invG, (mod - 1) / i, mod);
        for (int k = 0; k < len; k += i) {
            ll w = 1;
            for (int l = k; l < k + mid; l++) {
                ll t = w * A[l + mid] % mod;
                A[l + mid] = (A[l] - t + mod) % mod;
                A[l] = (A[l] + t) % mod;
                w = w * Wn % mod;
            }
        }
    }
    if (type == -1) {
        ll invn = qpow(len, mod - 2, mod);
        for (int i = 0; i < len; i++)
            A[i] = A[i] * invn % mod;
    }
}

void mul(ll *a, ll *b, int n) {
    int len = 1; while (len <= n) len <<= 1;
    for (int i = 0; i < len; i++) tr[i] = (tr[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
    NTT(a, len, 1), NTT(b, len, 1);
    for (int i = 0; i < len; i++) a[i] = a[i] * b[i] % mod;
    NTT(a, len, -1);
}

ll a[N], b[N];

void solve() {
    string s, t; cin >> s >> t;
    int n = s.length(), m = t.length();
    for(int i = 0;i < n; i++) a[i] = s[i] - 'a' + 1;
    for(int i = 0;i < m; i++) b[i] = t[i] - 'a' + 1;
    reverse(b, b + m);
    mul(a, b, n + m - 2);
    double P = 0;
    for(int i = 0;i < m; i++) {
        P += (t[i] - 'a' + 1) * (t[i] - 'a' + 1);
    }
    vector<int> f(n + 1);
    for(int i = 1;i < n; i++) {
        f[i] = f[i - 1] + (s[i] - 'a' + 1) * (s[i] - 'a' + 1);
    }
    for(int x = m - 1;x < n; x++) {
        double res;
        if(x == m - 1) res = P + f[x] - a[x] * 2;
        else res = P + f[x] - f[x - m] - a[x] * 2;
        if(!res) cout << x - m + 2 << endl;
    }
}\end{lstlisting}
\subsection{x不连续、暴力插值}
\begin{lstlisting}

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const double PI = acos(-1);
const int N = 3e5 + 10;

ll mod;
ll X[N], Y[N];

ll quick_pow(ll a, ll b) ;

ll Lagrange(ll *x, ll *y, int n, int k) {
    ll ans = 0;
    for(int i = 0;i < n; i++) {
        ll s1 = 1, s2 = 1;
        for(int j = 0;j < n; j++) {
            if(i == j) continue;
            s1 = s1 * (k - x[j] + mod) % mod;
            s2 = s2 * (x[i] - x[j] + mod) % mod; 
        }
        ans = (ans + 1ll * y[i] * s1 % mod * quick_pow(s2, mod - 2) % mod) % mod;
    }
    return ans;
}

int main() {
    int n, k;
    cin >> n >> k;
    for(int i = 0;i < n; i++) cin >> X[i] >> Y[i];
    cout << Lagrange(X, Y, n, k) << endl;
}
\end{lstlisting}
\subsection{x连续、前缀优化}
\begin{lstlisting}

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;

ll mod;
ll F[N];
ll pre[N], suf[N];
ll fac[N], invf[N];


ll quick_pow(ll a, ll b) ;

void init() {
    fac[0] = 1;
    for(int i = 1;i < N; i++) fac[i] = fac[i - 1] * i % mod;
    invf[N - 1] = quick_pow(fac[N - 1], mod - 2);
    for(int i = N - 1;i >= 1; i--) invf[i - 1] = invf[i] * i % mod;
}

ll Lagrange(ll *f, int k, int n) {
    if(k <= n) return f[k]; 
    pre[0] = suf[n] = 1;
    for(int i = 1;i <= n; i++) pre[i] = pre[i - 1] * (k - i + 1) % mod;
    for(int i = n;i >= 1; i--) suf[i - 1] = suf[i] * (k - i) % mod;
    ll ans = 0;
    for(int i = 0;i <= n; i++) {
        int opt = (n - i) & 1 ? -1 : 1;
        ans = (ans + 1ll * opt * pre[i] % mod * suf[i] % mod * invf[i] % mod * invf[n - i] % mod * f[i] % mod + mod) % mod;
    }
    return f[k] = ans;
}

int main() {
    init();
    int n, k;
    cin >> n >> k;
    for(int i = 0;i <= n; i++) cin >> F[i];
    cout << Lagrange(F, k, n) << endl;

}\end{lstlisting}
\subsection{多项式ln_exp_pow处理边界为1}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const double PI = acos(-1);
const int N = 1e5 + 10;

struct Complex {
    double x, y;
    Complex(double a = 0, double b = 0): x(a), y(b) {}
    Complex operator + (const Complex &rhs) { return Complex(x + rhs.x, y + rhs.y); }
    Complex operator - (const Complex &rhs) { return Complex(x - rhs.x, y - rhs.y); }
    Complex operator * (const Complex &rhs) { return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); }
    Complex conj() { return Complex(x, -y); }
} w[N];

ll mod, inv2;
int tr[N];
ll F[N], G[N];

ll quick_pow(ll a, ll b) ;

int getLen(int n) ;

void FFT(Complex *A, int len) ;

inline void MTT(ll *x, ll *y, ll *z, int len) ;

void Get_Inv(ll *f, ll *g, int n) ;

void Get_Der(ll *f, ll *g, int len) { for(int i = 1;i < len; i++) g[i - 1] = f[i] * i % mod; g[len - 1] = 0; }

void Get_Int(ll *f, ll *g, int len) { for(int i = 1;i < len; i++) g[i] = f[i - 1] * quick_pow(i, mod - 2) % mod; g[0] = 0; }

void Get_Ln(ll *f, ll *g, int n) ;

void Get_Exp(ll *f, ll *g, int n) ;

void Get_Pow(ll *f, ll *g, int n, ll k) ;

void Get_Sqrt(ll *f, ll *g, int n) {
    static ll a[N];
    Get_Ln(f, a, n);
    for(int i = 0;i < n; i++) a[i] = a[i] * inv2 % mod;
    Get_Exp(a, g, n);
    int len = getLen(n);
    for(int i = n;i < len; i++) g[i] = 0;
    for(int i = 0;i < len; i++) a[i] = 0;
}

\end{lstlisting}
\subsection{二次剩余处理边界不为1}
\begin{lstlisting}

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const double PI = acos(-1);
const int N = 1e5 + 10;


struct Complex {
    double x, y;
    Complex(double a = 0, double b = 0): x(a), y(b) {}
    Complex operator + (const Complex &rhs) { return Complex(x + rhs.x, y + rhs.y); }
    Complex operator - (const Complex &rhs) { return Complex(x - rhs.x, y - rhs.y); }
    Complex operator * (const Complex &rhs) { return Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); }
    Complex conj() { return Complex(x, -y); }
} w[N];

ll mod, inv2;
int tr[N];
ll F[N], G[N];

ll quick_pow(ll a, ll b) ;

typedef struct{
    ll x, y; // 把求出来的w作为虚部，则为a + bw
}num;

num num_mul(num a, num b, ll w, ll p) {// 复数乘法
    num ans = {0, 0};
    ans.x = (a.x * b.x % p + a.y * b.y % p * w % p + p) % p;
    ans.y = (a.x * b.y % p + a.y * b.x % p + p) % p;
    return ans;
} 

ll num_pow(num a, ll b, ll w, ll p) { // 复数快速幂
    num ans = {1, 0};
    while(b) {
        if(b & 1)
            ans = num_mul(ans, a, w, p);
        a = num_mul(a, a, w, p);
        b >>= 1;
    }
    return ans.x % p;
}

ll legendre(ll a, ll p) { // 勒让德符号 = {1, -1, 0}
    return quick_pow(a, (p - 1) >> 1);
}

ll Cipolla(ll n, ll p) {// 输入a和p，是否存在x使得x^2 = a (mod p)，存在二次剩余返回x，存在二次非剩余返回-1     注意：p是奇质数
    n %= p;
    if(n == 0)
        return 0;
    if(p == 2)
        return 1;
    ll a, w; 
    
    while(true) {// 找出a，求出w，随机成功的概率是50%，所以数学期望是2
        a = rand() % p;
        w = ((a * a - n) % p + p) % p;
        if(legendre(w, p) + 1 == p) // 找到w，非二次剩余条件
            break;
    }
    num x = {a, 1};   
    return num_pow(x, (p + 1) >> 1, w, p) % p; // 计算x,一个解是x，另一个解是p-x，这里的w其实要开方，但是由拉格朗日定理可知虚部为0，所以最终答案就是对x的实部用快速幂求解
}

int getLen(int n) ;

void FFT(Complex *A, int len) ;

inline void MTT(ll *x, ll *y, ll *z, int len) ;

void Get_Inv(ll *f, ll *g, int n) ;

void Get_Sqrt(ll *f, ll *g, int n) {
    if(n == 1) { ll t = Cipolla(f[0], mod); g[0] = min(mod - t, t); return ; }
    Get_Sqrt(f, g, (n + 1) >> 1);

    int len = getLen(n);
    static ll c[N], invg[N];
    for(int i = 0;i < len; i++) c[i] = i < n ? f[i] : 0;
    Get_Inv(g, invg, n);
    MTT(c, invg, c, len);
    for(int i = 0;i < n; i++) g[i] = inv2 * (c[i] + g[i]) % mod;
    for(int i = n;i < len; i++) g[i] = 0;
    for(int i = 0;i < len; i++) c[i] = invg[i] = 0;
}

int main() {
    inv2 = quick_pow(2, mod - 2);
    int n;
    cin >> n;
    for(int i = 0;i < n; i++) cin >> F[i];
    Get_Sqrt(F, G, n);
    for(int i = 0;i < n; i++) cout << G[i] << " ";
}\end{lstlisting}
\subsection{二维几何}
\begin{lstlisting}
#include <iostream>
#include <cmath>

using namespace std;

const double eps = 1e-6;
const double pi = acos(-1);

#define zero(x) (((x) > 0 ? (x) : -(x)) < eps) 

int sgn(double d) {
    if(fabs(d) < eps) 
        return 0;
    if(d > 0) 
        return 1;
    else 
        return -1;
}

int dcmp(double x, double y) {
    if(fabs(x - y) < eps) 
        return 0;
    if(x > y) 
        return 1;
    else 
        return -1;
}

struct Point{ // 点
    double x, y; 
    Point(double x = 0, double y = 0) : x(x), y(y) {} 
};

struct line{ 
    Point a, b;
};

typedef Point Vector; // 向量

// 运算(向量之间)

Vector operator + (Vector A, Vector B) { // AB
    return Vector(A.x + B.x, A.y + B.y);
}

Vector operator - (Point A, Point B) { // BA
    return Vector(A.x - B.x, A.y - B.y);
}

Vector operator * (Vector A, double p) { // A * p
    return Vector(A.x * p, A.y * p);
}

Vector operator / (Vector A, double p) { // A / p
    return  Vector(A.x / p, A.y / p);
}

bool operator < (const Point& a, const Point& b) { // 将点升序排列
    if(a.x == b.x) 
        return a.y < b.y;
    return a.x < b.x;
}

bool operator == (const Point& a, const Point& b) { // 判断是否为同一点
    if(dcmp(a.x, b.x) == 0 && dcmp(a.y, b.y) == 0)
        return true;
    else 
        return false;
}

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
// 向量

double Dot(Vector A, Vector B) { // 内积
    return A.x * B.x + A.y * B.y;
}

double Cross(Vector A, Vector B) { // 外积
    return A.x * B.y - A.y * B.x;
}

double Length(Vector A) { // 向量取模
    return sqrt(Dot(A, A));
}

double Angle(Vector A, Vector B) { // 向量夹角
    return acos(Dot(A, B) / Length(A) / Length(B));
}

double Area(Point A, Point B, Point C) { // 计算两向量构成的平行四边形有向面积
    return Cross(B - A, C - A);
}

Vector Rotate(Vector A, double rad) { // 计算向量逆时针旋转后的向量
    return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad)); 
}

Vector Normal(Vector A) { // 计算向量逆时针转90度后的单位法向量
    double L = Length(A);
    return Vector(-A.y / L, A.x / L);
}

bool ToLeftTest(Point a, Point b, Point c) { // 判断bc是不是向ab的逆时针方向转向
    return Cross(b - a, c - b) > 0;
}

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
// 直线与线段

double Pow(double x) {
    return x * x;
}

double distance (Point p1, Point p2) {// 两点距离
    return sqrt(Pow(p1.x - p2.x) + Pow(p1.y - p2.y));
}

int dots_inline(Point p1, Point p2, Point p3) { // 判断三点共线
    return Cross(p2 - p1, p3 - p1);
}

int dot_online_in(Point p, line l) { // 判断点在线段上（包含端点）
    return zero(Cross(l.b - p, l.a - p) && ((l.a.x - p.x) * (l.b.x - p.x) < eps) && ((l.a.y - p.y) * (l.b.y - p.y) < eps));
}

int dot_online_ex(Point p, line l) { // 判断点在线段上（不包含端点）
    return dot_online_in(p, l) && (!zero(p.x - l.a.x) || !zero(p.y - l.a.y)) && (!zero(p.x - l.b.x) || !zero(p.y - l.b.y));
}

int same_side(Point p1, Point p2, line l) { // 判断两点在线段同侧，点在线段上返回0
    return Cross(l.a - l.b, p1 - l.b) * Cross(l.a - l.b, p2 - l.b) > eps;
}

int opposite_side(Point p1, Point p2, line l) { // 判断两点在线段异侧，点在线段上返回0
    return Cross(l.a - l.b, p1 - l.b) * Cross(l.a - l.b, p2 - l.b) < -eps;
}

int parallel(line u, line v) { // 判断两直线平行
    return zero((u.a.x - u.b.x) * (v.a.y - v.b.y) - (u.a.y - u.b.y) * (v.a.x - v.b.x));
}

int  perpendicular(line u, line v) { // 判断两直线垂直
    return zero((u.a.x - u.b.x) * (v.a.x - v.b.x) + (u.a.y - u.b.y) * (v.a.y - v.b.y));
}

int intersect_in(line u, line v) {// 判断两线段相交，包括端点和部分重合
    if(!dots_inline(u.a, u.b, v.a) || !dots_inline(u.a, u.b, v.b)) {
        return !same_side(u.a, u.b, v) && !same_side(v.a, v.b, u);
    }
    return dot_online_in(u.a, v) || dot_online_in(u.b, v) || dot_online_in(v.a, u) || dot_online_in(v.b, u);
}

int intersect_ex(line u, line v) {// 判断两线段相交，不包括端点和部分重合
    return opposite_side(u.a, u.b, v) && opposite_side(v.a, v.b, u);
}  

// 计算两直线交点，注意事先判断直线是否相交
// 计算两线段交点，注意事先判断线段相交和平行
Point intersection(line u, line v) {
    Point ret = u.a;
    double t = ((u.a.x - v.a.x) * (v.a.y - v.b.y) - (u.a.y - v.a.y) * (v.a.x - v.b.x)) / ((u.a.x - u.b.x) * (v.a.y - v.b.y) - (u.a.y - u.b.y) * (v.a.x - v.b.x));
    ret.x += (u.b.x - u.a.x) * t;
    ret.y += (u.b.y - u.a.y) * t;
    return ret;
}

Point ptoline(Point p, line l) { // 点到直线最近点
    Point t = p;
    t.x += l.a.y - l.b.y;
    t.y += l.b.x - l.a.x;
    line u = {p, t};
    return intersection(u, l);
}

double disptoline(Point p, line l) { // 点到直线距离
    return fabs(Cross(p - l.b, l.a - l.b) / distance(l.a, l.b));
}

Point ptoseg(Point p, line l) { // 点到线段最近点
    Point t = p;
    t.x += l.a.y - l.b.y;
    t.y += l.b.x - l.a.x;
    if(Cross(l.a - p, t - p) * Cross(l.b - p, t - p) > eps) 
        return distance(p, l.a) < distance(p, l.b) ? l.a : l.b;
    line u = {p, t};
    return intersection(u, l);
}

double disptoseg(Point p, line l) { // 点到线段距离
    Point t = p;
    t.x += l.a.y - l.b.y;
    t.y += l.b.x - l.a.x;
    if(Cross(l.a - p, t - p) * Cross(l.b - p, t - p) > eps) {
        double dis1 = distance(p, l.a);
        double dis2 = distance(p, l.b);
        return dis1 < dis2 ? dis1 : dis2;
    }
    return fabs(Cross(p - l.b, l.a - l.b) / distance(l.a, l.b));
}

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
// 面积

double area_triangle(Point p1, Point p2, Point p3) { // 三角形面积（输入三顶点）
    return fabs(Cross(p1 - p3, p2 - p3)) / 2;
}

double area_triangle(double a, double b, double c) { // 三角形面积（输入三边长）
    double s = (a + b + c) / 2;
    return sqrt(s * (s - a) * (s - b) * (s - c));
}

double area_polygon(int n, Point *p) { // 计算多边形面积，顶点按顺时针或逆时针输入
    double s1 = 0, s2 = 0;
    for(int i = 0;i < n; i++) {
        s1 += p[(i + 1) % n].y * p[i].x;
        s2 += p[(i + 1) % n].y * p[(i + 2) % n].x;
    }
    return fabs(s1 - s2) / 2;
}

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
// 球面

//计算圆心角 lat 表示纬度,-90<=w<=90,lng 表示经度 
//返回两点所在大圆劣弧对应圆心角,0<=angle<=pi 

double angle(double lng1, double lat1, double lng2, double lat2) {
    double dlng = fabs(lng1 - lng2) * pi / 180;
    while(dlng >= pi + pi) {
        dlng -= pi + pi;
    }
    if(dlng > pi) 
    dlng = pi + pi - dlng;
    lat1 *= pi / 180;
    lat2 *= pi / 180;
    return acos(cos(lat1) * cos(lat2) * cos(dlng) + sin(lat1) * sin(lat2));
}

// 计算两点距离

double line_dist(double r, double lng1, double lat1, double lng2, double lat2) {
    double dlng = fabs(lng1 - lng2) * pi / 180;
    while(dlng >= pi + pi) {
        dlng -= pi + pi;
    }
    if(dlng > pi) 
    dlng = pi + pi - dlng;
    lat1 *= pi / 180;
    lat2 *= pi / 180;
    return r * sqrt(2 - 2 * (cos(lat1) * cos(lat2) * cos(dlng) + sin(lat1) * sin(lat2)));
}

// 计算球面距离

inline double sphere_dist(double r, double lng1, double lat1, double lng2, double lat2) {
    return r * angle(lng1, lat1, lng2, lat2);
}

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
// 三角形

// 外心

Point circumcenter(Point a, Point b, Point c) {
    line u, v;
    u.a.x = (a.x + b.x) / 2;
    u.a.y = (a.y + b.y) / 2;
    u.b.x = u.a.x - a.y + b.y;
    u.b.y = u.a.y + a.x - b.x;
    v.a.x = (a.x + c.x) / 2;
    v.a.y = (a.y + c.y) / 2;
    v.b.x = v.a.x - a.y + c.y;
    v.b.y = v.a.y + a.x - c.y;
    return intersection(u, v);
}

// 内心

Point incenter(Point a, Point b, Point c) {
    line u, v;
    double m, n;
    u.a = a;
    m = atan2(b.y - a.y, b.x - a.x);
    n = atan2(c.y - a.y, c.x - a.x);
    u.b.x = u.a.x + cos((m + n) / 2);
    u.b.y = u.a.y + sin((m + n) / 2);
    v.a = b;
    m=atan2(a.y - b.y, a.x - b.x); 
    n=atan2(c.y - b.y, c.x - b.x); 
    v.b.x=v.a.x + cos((m + n) / 2); 
    v.b.y=v.a.y + sin((m + n) / 2);
    return intersection(u, v); 
}

// 垂心

Point perpencenter(Point a, Point b, Point c) {
    line u, v;
    u.a = c; 
    u.b.x = u.a.x - a.y + b.y; 
    u.b.y = u.a.y + a.x - b.x; 
    v.a = b; 
    v.b.x = v.a.x - a.y + c.y; 
    v.b.y = v.a.y + a.x - c.x; 
return intersection(u, v); 
}

// 重心
//到三角形三顶点距离的平方和最小的点 
//三角形内到三边距离之积最大的点 

Point barycenter(Point a, Point b, Point c) {
    line u,v; 
    u.a.x = (a.x + b.x) / 2; 
    u.a.y = (a.y + b.y) / 2; 
    u.b = c; 
    v.a.x = (a.x + c.x) / 2; 
    v.a.y = (a.y + c.y) / 2; 
    v.b = b; 
return intersection(u, v); 
}

//费马点 
//到三角形三顶点距离之和最小的点 
Point fermentpoint(Point a, Point b, Point c) { 
    Point u,v; 
    double step = fabs(a.x) + fabs(a.y) + fabs(b.x) + fabs(b.y) + fabs(c.x) + fabs(c.y); 
    int i, j, k; 
    u.x = (a.x + b.x + c.x) / 3; 
    u.y = (a.y + b.y + c.y) / 3; 
    while(step > 1e-10) 
    for(k = 0;k < 10; step /= 2, k++) 
        for (i = -1;i <= 1; i++) 
            for (j = -1;j <= 1; j++){ 
            v.x = u.x + step * i; 
            v.y = u.y + step * j; 
            if(distance(u,a) + distance(u,b) + distance(u,c) > distance(v,a) + distance(v,b) + distance(v,c)) 
                u = v; 
            } 
    return u; 
} \end{lstlisting}
\subsection{三维几何}
\begin{lstlisting}
#include <math.h>
#define eps 1e-8
#define zero(x) (((x)>0?(x):-(x))<eps)
struct point3{double x,y,z;};
struct line3{point3 a,b;};
struct plane3{point3 a,b,c;};
//计算 cross product U x V 
point3 Cross(point3 u,point3 v){
    point3 ret;
    ret.x=u.y*v.z-v.y*u.z;
    ret.y=u.z*v.x-u.x*v.z;
    ret.z=u.x*v.y-u.y*v.x;
    return ret;
}
//计算 dot product U . V 
double Dot(point3 u,point3 v){
    return u.x*v.x+u.y*v.y+u.z*v.z;
}
//矢量差 U - V 
point3 subt(point3 u,point3 v){
    point3 ret;
    ret.x=u.x-v.x;
    ret.y=u.y-v.y;
    ret.z=u.z-v.z;
    return ret;
}
//取平面法向量 
point3 pvec(plane3 s){
    return Cross(subt(s.a,s.b),subt(s.b,s.c));
}
point3 pvec(point3 s1,point3 s2,point3 s3){
    return Cross(subt(s1,s2),subt(s2,s3));
}
//两点距离,单参数取向量大小 
double distance(point3 p1,point3 p2){
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)+(p1.z-p2.z)*(p1.z-p2.z));
}
//向量大小 
double vlen(point3 p){
    return sqrt(p.x*p.x+p.y*p.y+p.z*p.z);
}
//判三点共线 
int dots_inline(point3 p1,point3 p2,point3 p3){
    return vlen(Cross(subt(p1,p2),subt(p2,p3)))<eps;
}
//判四点共面 
int dots_onplane(point3 a,point3 b,point3 c,point3 d){
    return zero(Dot(pvec(a,b,c),subt(d,a)));
}
//判点是否在线段上,包括端点和共线 
int dot_online_in(point3 p,line3 l){
    return zero(vlen(Cross(subt(p,l.a),subt(p,l.b))))&&(l.a.x-p.x)*(l.b.x-p.x)<eps&&
           (l.a.y-p.y)*(l.b.y-p.y)<eps&&(l.a.z-p.z)*(l.b.z-p.z)<eps;
}
int dot_online_in(point3 p,point3 l1,point3 l2){
    return zero(vlen(Cross(subt(p,l1),subt(p,l2))))&&(l1.x-p.x)*(l2.x-p.x)<eps&&
           (l1.y-p.y)*(l2.y-p.y)<eps&&(l1.z-p.z)*(l2.z-p.z)<eps;
}
//判点是否在线段上,不包括端点 
int dot_online_ex(point3 p,line3 l){
    return dot_online_in(p,l)&&(!zero(p.x-l.a.x)||!zero(p.y-l.a.y)||!zero(p.z-l.a.z))&&
            (!zero(p.x-l.b.x)||!zero(p.y-l.b.y)||!zero(p.z-l.b.z));
}
int dot_online_ex(point3 p,point3 l1,point3 l2){
    return dot_online_in(p,l1,l2)&&(!zero(p.x-l1.x)||!zero(p.y-l1.y)||!zero(p.z-l1.z))&&
           (!zero(p.x-l2.x)||!zero(p.y-l2.y)||!zero(p.z-l2.z));
}
//判点是否在空间三角形上,包括边界,三点共线无意义 
int dot_inplane_in(point3 p,plane3 s){
    return zero(vlen(Cross(subt(s.a,s.b),subt(s.a,s.c)))-vlen(Cross(subt(p,s.a),subt(p,s.b)))-
                vlen(Cross(subt(p,s.b),subt(p,s.c)))-vlen(Cross(subt(p,s.c),subt(p,s.a))));
}
int dot_inplane_in(point3 p,point3 s1,point3 s2,point3 s3){
    return zero(vlen(Cross(subt(s1,s2),subt(s1,s3)))-vlen(Cross(subt(p,s1),subt(p,s2)))-
                vlen(Cross(subt(p,s2),subt(p,s3)))-vlen(Cross(subt(p,s3),subt(p,s1))));
}
//判点是否在空间三角形上,不包括边界,三点共线无意义 
int dot_inplane_ex(point3 p,plane3 s){
    return dot_inplane_in(p,s)&&vlen(Cross(subt(p,s.a),subt(p,s.b)))>eps&&
           vlen(Cross(subt(p,s.b),subt(p,s.c)))>eps&&vlen(Cross(subt(p,s.c),subt(p,s.a)))>eps;
}
int dot_inplane_ex(point3 p,point3 s1,point3 s2,point3 s3){
    return dot_inplane_in(p,s1,s2,s3)&&vlen(Cross(subt(p,s1),subt(p,s2)))>eps&&
           vlen(Cross(subt(p,s2),subt(p,s3)))>eps&&vlen(Cross(subt(p,s3),subt(p,s1)))>eps;
}
//判两点在线段同侧,点在线段上返回 0,不共面无意义 
int same_side(point3 p1,point3 p2,line3 l){
    return Dot(Cross(subt(l.a,l.b),subt(p1,l.b)),Cross(subt(l.a,l.b),subt(p2,l.b)))>eps;
}
int same_side(point3 p1,point3 p2,point3 l1,point3 l2){
    return Dot(Cross(subt(l1,l2),subt(p1,l2)),Cross(subt(l1,l2),subt(p2,l2)))>eps;
}
//判两点在线段异侧,点在线段上返回 0,不共面无意义 
int opposite_side(point3 p1,point3 p2,line3 l){
    return Dot(Cross(subt(l.a,l.b),subt(p1,l.b)),Cross(subt(l.a,l.b),subt(p2,l.b)))<-eps;
}
int opposite_side(point3 p1,point3 p2,point3 l1,point3 l2){
    return Dot(Cross(subt(l1,l2),subt(p1,l2)),Cross(subt(l1,l2),subt(p2,l2)))<-eps;
}
//判两点在平面同侧,点在平面上返回 0 
int same_side(point3 p1,point3 p2,plane3 s){
    return Dot(pvec(s),subt(p1,s.a))*Dot(pvec(s),subt(p2,s.a))>eps;
}
int same_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3){
    return Dot(pvec(s1,s2,s3),subt(p1,s1))*Dot(pvec(s1,s2,s3),subt(p2,s1))>eps;
}
//判两点在平面异侧,点在平面上返回 0 
int opposite_side(point3 p1,point3 p2,plane3 s){
    return Dot(pvec(s),subt(p1,s.a))*Dot(pvec(s),subt(p2,s.a))<-eps;
}
int opposite_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3){
    return Dot(pvec(s1,s2,s3),subt(p1,s1))*Dot(pvec(s1,s2,s3),subt(p2,s1))<-eps;
}
//判两直线平行 
int parallel(line3 u,line3 v){
    return vlen(Cross(subt(u.a,u.b),subt(v.a,v.b)))<eps;
}
int parallel(point3 u1,point3 u2,point3 v1,point3 v2){
    return vlen(Cross(subt(u1,u2),subt(v1,v2)))<eps;
}
//判两平面平行 
int parallel(plane3 u,plane3 v){
    return vlen(Cross(pvec(u),pvec(v)))<eps;
}
int parallel(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3){
    return vlen(Cross(pvec(u1,u2,u3),pvec(v1,v2,v3)))<eps;
}
//判直线与平面平行 
int parallel(line3 l,plane3 s){
    return zero(Dot(subt(l.a,l.b),pvec(s)));
}
int parallel(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3){
    return zero(Dot(subt(l1,l2),pvec(s1,s2,s3)));
}
//判两直线垂直 
int perpendicular(line3 u,line3 v){
    return zero(Dot(subt(u.a,u.b),subt(v.a,v.b)));
}
int perpendicular(point3 u1,point3 u2,point3 v1,point3 v2){
    return zero(Dot(subt(u1,u2),subt(v1,v2)));
}
//判两平面垂直 
int perpendicular(plane3 u,plane3 v){
    return zero(Dot(pvec(u),pvec(v)));
}
int perpendicular(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3){
    return zero(Dot(pvec(u1,u2,u3),pvec(v1,v2,v3)));
}
//判直线与平面平行 
int perpendicular(line3 l,plane3 s){
    return vlen(Cross(subt(l.a,l.b),pvec(s)))<eps;
}
int perpendicular(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3){
    return vlen(Cross(subt(l1,l2),pvec(s1,s2,s3)))<eps;
}
//判两线段相交,包括端点和部分重合 
int intersect_in(line3 u,line3 v){
    if (!dots_onplane(u.a,u.b,v.a,v.b))
        return 0;
    if (!dots_inline(u.a,u.b,v.a)||!dots_inline(u.a,u.b,v.b))
        return !same_side(u.a,u.b,v)&&!same_side(v.a,v.b,u);
    return dot_online_in(u.a,v)||dot_online_in(u.b,v)||dot_online_in(v.a,u)||dot_online_in(v.b,u);
}
int intersect_in(point3 u1,point3 u2,point3 v1,point3 v2){
    if (!dots_onplane(u1,u2,v1,v2))
        return 0;
    if (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2))
        return !same_side(u1,u2,v1,v2)&&!same_side(v1,v2,u1,u2);
    return
            dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2);
}
//判两线段相交,不包括端点和部分重合 
int intersect_ex(line3 u,line3 v){
    return dots_onplane(u.a,u.b,v.a,v.b)&&opposite_side(u.a,u.b,v)&&opposite_side(v.a,v.b,u);
}
int intersect_ex(point3 u1,point3 u2,point3 v1,point3 v2){
    return  dots_onplane(u1,u2,v1,v2)&&opposite_side(u1,u2,v1,v2)&&opposite_side(v1,v2,u1,u2);
  }
//判线段与空间三角形相交,包括交于边界和(部分)包含 
int intersect_in(line3 l,plane3 s){
    return !same_side(l.a,l.b,s)&&!same_side(s.a,s.b,l.a,l.b,s.c)&&
           !same_side(s.b,s.c,l.a,l.b,s.a)&&!same_side(s.c,s.a,l.a,l.b,s.b);
}
int intersect_in(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3){
    return !same_side(l1,l2,s1,s2,s3)&&!same_side(s1,s2,l1,l2,s3)&&
           !same_side(s2,s3,l1,l2,s1)&&!same_side(s3,s1,l1,l2,s2);
}
//判线段与空间三角形相交,不包括交于边界和(部分)包含 
int intersect_ex(line3 l,plane3 s){
    return opposite_side(l.a,l.b,s)&&opposite_side(s.a,s.b,l.a,l.b,s.c)&&
           opposite_side(s.b,s.c,l.a,l.b,s.a)&&opposite_side(s.c,s.a,l.a,l.b,s.b);
}
int intersect_ex(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3){
    return opposite_side(l1,l2,s1,s2,s3)&&opposite_side(s1,s2,l1,l2,s3)&&
           opposite_side(s2,s3,l1,l2,s1)&&opposite_side(s3,s1,l1,l2,s2);
}
//计算两直线交点,注意事先判断直线是否共面和平行! 
//线段交点请另外判线段相交(同时还是要判断是否平行!) 
point3 intersection(line3 u,line3 v){
    point3 ret=u.a;
    double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x))
             /((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x));
    ret.x+=(u.b.x-u.a.x)*t;
    ret.y+=(u.b.y-u.a.y)*t;
    ret.z+=(u.b.z-u.a.z)*t;
    return ret;
}
point3 intersection(point3 u1,point3 u2,point3 v1,point3 v2){
    point3 ret=u1;
    double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))
             /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));
    ret.x+=(u2.x-u1.x)*t;
    ret.y+=(u2.y-u1.y)*t;
    ret.z+=(u2.z-u1.z)*t;
    return ret;
}
//计算直线与平面交点,注意事先判断是否平行,并保证三点不共线! 
//线段和空间三角形交点请另外判断 
point3 intersection(line3 l,plane3 s){
    point3 ret=pvec(s);
    double t=(ret.x*(s.a.x-l.a.x)+ret.y*(s.a.y-l.a.y)+ret.z*(s.a.z-l.a.z))/
             (ret.x*(l.b.x-l.a.x)+ret.y*(l.b.y-l.a.y)+ret.z*(l.b.z-l.a.z));
    ret.x=l.a.x+(l.b.x-l.a.x)*t;
    ret.y=l.a.y+(l.b.y-l.a.y)*t;
    ret.z=l.a.z+(l.b.z-l.a.z)*t;
    return ret;
}
point3 intersection(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3){
    point3 ret=pvec(s1,s2,s3);
    double t=(ret.x*(s1.x-l1.x)+ret.y*(s1.y-l1.y)+ret.z*(s1.z-l1.z))/
             (ret.x*(l2.x-l1.x)+ret.y*(l2.y-l1.y)+ret.z*(l2.z-l1.z));
    ret.x=l1.x+(l2.x-l1.x)*t;
    ret.y=l1.y+(l2.y-l1.y)*t;
    ret.z=l1.z+(l2.z-l1.z)*t;
    return ret;
}
//计算两平面交线,注意事先判断是否平行,并保证三点不共线! 
line3 intersection(plane3 u,plane3 v){
    line3 ret;
    ret.a=parallel(v.a,v.b,u.a,u.b,u.c)?intersection(v.b,v.c,u.a,u.b,u.c):intersection(v.a,v.b,u.a,u.b,u.
            c);
    ret.b=parallel(v.c,v.a,u.a,u.b,u.c)?intersection(v.b,v.c,u.a,u.b,u.c):intersection(v.c,v.a,u.a,u.b,u.
            c);
    return ret;
}
line3 intersection(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3){
    line3 ret;
    ret.a=parallel(v1,v2,u1,u2,u3)?intersection(v2,v3,u1,u2,u3):intersection(v1,v2,u1,u2,u3);
    ret.b=parallel(v3,v1,u1,u2,u3)?intersection(v2,v3,u1,u2,u3):intersection(v3,v1,u1,u2,u3);
    return ret;
}
//点到直线距离 
double ptoline(point3 p,line3 l){
    return vlen(Cross(subt(p,l.a),subt(l.b,l.a)))/distance(l.a,l.b);
}
double ptoline(point3 p,point3 l1,point3 l2){
    return vlen(Cross(subt(p,l1),subt(l2,l1)))/distance(l1,l2);
}
//点到平面距离 
double ptoplane(point3 p,plane3 s){
    return fabs(Dot(pvec(s),subt(p,s.a)))/vlen(pvec(s));
}
double ptoplane(point3 p,point3 s1,point3 s2,point3 s3){
    return fabs(Dot(pvec(s1,s2,s3),subt(p,s1)))/vlen(pvec(s1,s2,s3));
}
//直线到直线距离 
double linetoline(line3 u,line3 v){
    point3 n=Cross(subt(u.a,u.b),subt(v.a,v.b));
    return fabs(Dot(subt(u.a,v.a),n))/vlen(n);
}
double linetoline(point3 u1,point3 u2,point3 v1,point3 v2){
    point3 n=Cross(subt(u1,u2),subt(v1,v2));
    return fabs(Dot(subt(u1,v1),n))/vlen(n);
}
//两直线夹角 cos 值 
double angle_cos(line3 u,line3 v){
    return Dot(subt(u.a,u.b),subt(v.a,v.b))/vlen(subt(u.a,u.b))/vlen(subt(v.a,v.b));
}
double angle_cos(point3 u1,point3 u2,point3 v1,point3 v2){
    return Dot(subt(u1,u2),subt(v1,v2))/vlen(subt(u1,u2))/vlen(subt(v1,v2));
}
//两平面夹角 cos 值 
double angle_cos(plane3 u,plane3 v){
    return Dot(pvec(u),pvec(v))/vlen(pvec(u))/vlen(pvec(v));
}
double angle_cos(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3){
    return Dot(pvec(u1,u2,u3),pvec(v1,v2,v3))/vlen(pvec(u1,u2,u3))/vlen(pvec(v1,v2,v3));
}
//直线平面夹角 sin 值 
double angle_sin(line3 l,plane3 s){
    return Dot(subt(l.a,l.b),pvec(s))/vlen(subt(l.a,l.b))/vlen(pvec(s));
}
double angle_sin(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3){
    return Dot(subt(l1,l2),pvec(s1,s2,s3))/vlen(subt(l1,l2))/vlen(pvec(s1,s2,s3));
} 

// 球体相交
double vol_ints(double x1, double y1, double z1, double r1, double x2, double y2, double z2, double r2) {
    double sum = 4.00 / 3.00 * PI * r1 * r1 * r1 + 4.00 / 3.00 * PI * r2 * r2 * r2;
    double ans = 0;
    double dis = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2)); //球心距离
    if (dis >= r1 + r2) //没有交到的地方
    {
        ans = 0;
    } else if (dis + r1 <= r2)//重合
    {
        ans = (4.00 / 3.00) * PI * r1 * r1 * r1;
    } else if (dis + r2 <= r1) {
        ans = (4.00 / 3.00) * PI * r2 * r2 * r2;
    } else  //相交
    {
        double cal = (r1 * r1 + dis * dis - r2 * r2) / (2.00 * dis * r1);
        double h = r1 * (1 - cal);
        ans += (1.00 / 3.00) * PI * (3.00 * r1 - h) * h * h;
        cal = (r2 * r2 + dis * dis - r1 * r1) / (2.00 * dis * r2);
        h = r2 * (1.00 - cal);
        ans += (1.00 / 3.00) * PI * (3.00 * r2 - h) * h * h;
    }
    return ans;
}\end{lstlisting}
\clearpage\section{图论}
\subsection{结论}
\begin{lstlisting}
最大匹配数：最大匹配的匹配边的数目

最小点覆盖数：选取最少的点，使任意一条边至少有一个端点被选择

最大独立数：选取最多的点，使任意所选两点均不相连

最小路径覆盖数：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。

定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理）

定理2：最大匹配数 = 最大独立数

定理3：最小路径覆盖数 = 顶点数 - 最大匹配数\end{lstlisting}
\subsection{二分图判定}
\begin{lstlisting}
//不存在奇环即为二分图

const int N = 1e5 + 10;
bool flag;
int n;
vector <int> v[N], col(N);
void dfs(int x, int y){
  col[x] = y;
  for (int i = 0; i < v[x].size(); i++) {
     if (!col[v[x][i]]) dfs(v[x][i],3 - y);
     if (col[v[x][i]] == col[x]) flag = true;      //产生了冲突
  }
}

void check() {
    memset(col, 0, sizeof col);
    for(int i = 1;i <= n; i++) {
        if(!col[i]) dfs(i, 1); // dfs染色
    }
    if(flag) cout << "no";
    else cout << "yes";
}
\end{lstlisting}
\subsection{hungry}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e3 + 10;
struct Edge {
    int v, next;
}e[maxn << 1];
int head[maxn << 1], cnt;
bool vis[maxn << 1];
int match[maxn << 1];

inline void add(int u, int v) {
    e[++cnt].v = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

bool hungry(int u) {
    for(int i = head[u]; i != -1; i = e[i].next) {
        int v = e[i].v;
        if(!vis[v]) {
            vis[v] = true;
            if(match[v] == -1 || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

void solve() {
    int k, m, n;
    while(scanf("%d",&k) && k) {
        mem(match, -1);
        cnt = 0;
        mem(head, -1);
        scanf("%d%d",&m,&n);
        for(int i = 1;i <= k; i++) {
            int u, v;
            scanf("%d%d",&u,&v);
            add(u, v);
        }
        int ans = 0;
        for(int i = 1;i <= m; i++) {
            mem(vis, false);
            if(dfs(i)) ans++;
        }
        printf("%d\n",ans);
    }
}\end{lstlisting}
\subsection{KM}
\begin{lstlisting}
//https://ac.nowcoder.com/acm/contest/view-submission?submissionId=44654655

struct KM {
#define type int
    //#define inf 0x3f3f3f3f
    static const int N = 505;
    static const int INF = 0x3f3f3f3f;
    int n, mx[N], my[N], prv[N];
    type slk[N], lx[N], ly[N], w[N][N];
    bool vx[N], vy[N];

    void init(int siz) {
        n = siz;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                w[i][j] = -505;
            }
        }
    }

    void add_edge(int x, int y, type val) { w[x][y] = val; }

    void match(int y) { while (y) swap(y, mx[my[y] = prv[y]]); }

    void bfs(int x) {
        int i, y;
        type d;
        for (i = 1; i <= n; i++) {
            vx[i] = vy[i] = 0;
            slk[i] = INF;
        }
        queue<int> q;
        q.push(x);
        vx[x] = 1;
        while (1) {
            while (!q.empty()) {
                x = q.front();
                q.pop();
                for (y = 1; y <= n; y++) {
                    d = lx[x] + ly[y] - w[x][y];
                    if (!vy[y] && d <= slk[y]) {
                        prv[y] = x;
                        if (!d) {
                            if (!my[y]) return match(y);
                            q.push(my[y]);
                            vx[my[y]] = 1;
                            vy[y] = 1;
                        } else slk[y] = d;
                    }
                }
            }
            d = INF + 1;
            for (i = 1; i <= n; i++) {
                if (!vy[i] && slk[i] < d) {
                    d = slk[i];
                    y = i;
                }
            }
            for (i = 1; i <= n; i++) {
                if (vx[i]) lx[i] -= d;
                if (vy[i]) ly[i] += d;
                else slk[i] -= d;
            }
            if (!my[y]) return match(y);
            q.push(my[y]);
            vx[my[y]] = 1;
            vy[y] = 1;
        }
    }

    type max_match() {
        int i;
        type res;
        for (i = 1; i <= n; i++) {
            mx[i] = my[i] = ly[i] = 0;
            lx[i] = *max_element(w[i] + 1, w[i] + n + 1);
        }
        for (i = 1; i <= n; i++) bfs(i);
        res = 0;
        for (i = 1; i <= n; i++) res += lx[i] + ly[i];
        return res;
    }

#undef type
};\end{lstlisting}
\subsection{GaleShapley}
\begin{lstlisting}
#include<iostream>
using namespace std;

const int N=4;

void GaleShapley(const int (&man)[MAX][MAX], const int (&woman)[MAX][MAX], int (&match)[MAX]) {
	int wm[MAX][MAX];    // wm[i][j]: rank from girl i to boy j
	int choose[MAX];    // choose[i]: current boyfriend of girl i
	int manIndex[MAX]; //    manIndex[i]: how many girls that have rejected boy i
	int i, j;
	int w, m;
	for (i = 0; i < N; i++) {
		match[i] = -1;
		choose[i] = -1;
		manIndex[i] = 0;
		for (j = 0; j < N; j++)
			wm[i][woman[i][j]] = j;
	}

	bool bSingle = false;
	while (!bSingle) {
		bSingle = true;
		for (i = 0; i < N; i++) {
			if (match[i] != -1) // boy i already have a girlfriend
				continue;
			bSingle = false;
			j = manIndex[i]++; // the jth girl that boy i like most
			w = man[i][j];
			m = choose[w];    // current girl w's boyfriend
			if (m == -1 || wm[w][i] < wm[w][m]) { // if girl w prefer boy i
				match[i] = w;
				choose[w] = i;
				if (m != -1)
					match[m] = -1;
			}
		}
	}
}


void Print(const int(&match)[MAX], int N) {
	for (int i = 0; i < N; i++)
		cout << i << " " << match[i] << endl;
}


int main(){
    int man[N][N]={
        {2,3,1,0},
        {2,1,3,0},
        {0,2,3,1},
        {1,3,2,0},
    };
    int woman[N][N]={
        {0,3,2,1},
        {0,1,2,3},
        {0,2,3,1},
        {1,0,3,2},
    };

    int match[N];
    GaleShapley(man,woman,match);
    Print(match,N);

    return 0;
}\end{lstlisting}
\subsection{Bellman_Ford}
\begin{lstlisting}
struct Edge {
    int u, v, w;
}e[1005];
 
int dis[1005], n, m, s;
bool flag; // 判断负环
 
void Init() {
    cin >> n >> m >> s;
    for(int i = 1;i <= n; i++) dis[i] = INF;
    dis[s] = 0;
    for(int i = 1;i <= m; i++) {
        cin >> e[i].u >> e[i].v >> e[i].w;
        if(e[i].u == s)
            dis[e[i].v] = e[i].w;
    }
}
 
void Bellman_Ford() {
    for(int i = 1;i < n; i++) {
        for(int j = 1;j <= m; i++) {
            if(dis[e[j].v] > dis[e[j].u] + e[j].w)
                dis[e[j].v] = dis[e[j].u] + e[j].w;
        }
    }
    flag = true;
    for(int i = 1;i <= m; i++) {
        if(dis[e[i].v] > dis[e[i].u] + e[i].w) {
            flag = false;
            break;
        }
    }
}\end{lstlisting}
\subsection{Dijkatra}
\begin{lstlisting}
const int maxn = 2e5 + 10;

struct Edge {
    int v, next;
    ll w;
}e[maxn];
int head[maxn], cnt;

inline void add(int u, int v, ll w) ;

struct node {
    int now;
    ll d;
    bool operator < (const node &rhs) const {
        return d > rhs.d;
    }
};

ll dis[maxn];
bool vis[maxn];
priority_queue<node> q;

void dij(int s) {
    dis[s] = 0;
    q.push({s, 0});
    while(!q.empty()) {
        node p = q.top();
        q.pop();
        int u = p.now;
        if(vis[u]) continue;
        vis[u] = 1;
        for(int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if(dis[v] > dis[u] + e[i].w) {
                dis[v] = dis[u] + e[i].w;
                q.push({v, dis[v]});
            }
        }
    }
}\end{lstlisting}
\subsection{Floyd}
\begin{lstlisting}
//三重循环，暴力遍历
#define INF 336860180
int n, m, d[405][405];
void Floyd() {
    memset(d, 20, sizeof d);
    for(int i = 1;i <= m; i++) {
        int u, v, h; cin >> u >> v >> h;
        d[u][v] = h;
    }
    for(int k = 1;k <= n; k++) {
        for(int i = 1;i <= n; i++) {
            for(int j = 1;j <= n; j++) {
                d[i][j] = min(d[i][k] + d[k][j], d[i][j]);
            }
        }
    }
}\end{lstlisting}
\subsection{SPFA}
\begin{lstlisting}
#define INF 0x3f
#define maxn 5000005
int n, m, s;

struct Edge {
    int v, w, next;
}e[maxn];
int head[maxn], cnt, dis[maxn];
bool vis[maxn]; 

inline void add(int u,int v,int w) ;

queue<int> q;

void SPFA() {
    for(int i = 1;i <= n; i++) {
        dis[i] = INF;
        vis[i] = false;
    }
    q.push(s); dis[s] = 0; vis[s] = true;
    while(!q.empty()) {
        int u = q.front(); q.pop();
        vis[u] = false;
        for(int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if(dis[v] > dis[u] + e[i].w) {
                dis[v] = dis[u] + e[i].w;
                if(!vis[v]) {
                    vis[v] = true;
                    q.push(v);
                }
            }
        }
    }
}\end{lstlisting}
\subsection{Kruskal}
\begin{lstlisting}
//Kruskal算法求最小生成树（稀疏图）

// 一个无向图，求最小生成树各边的和

struct Kruskal {
    static const int N = 1e6 + 10;
    int n, m, ans;
    struct Edge {
        int u, v, w;
        bool operator < (const Edge& rhs) const {
            return w < rhs.w;
        }
    }e[N << 1];
    int f[N];

    void init() {
        for(int i = 1;i <= n; i++) f[i] = i;
        m = 0;
    }

    void add(int u, int v, int w) {
        e[++m] = {u, v, w};
    }

    int find(int x) {
        return f[x] == x ? x : f[x] = find(f[x]);
    }

    void kruskal() {
        int cnt = 0;
        sort(e + 1, e + m + 1);
        for(int i = 1;i <= m; i++) {
            int u = find(e[i].u);
            int v = find(e[i].v);
            if(u == v) continue;
            f[v] = u; ans += e[i].w;
            if(++cnt == n - 1) break;
        }
    }
}krl;\end{lstlisting}
\subsection{prim}
\begin{lstlisting}
//prim算法求最小生成树（稠密图）

struct Prim {
    static const int N = 1e6 + 10;
    int n, m;
    double ans;
    struct Edge {
        int v, next;
        double w;
    }e[N << 1];
    int head[N << 1], cnt;
   struct node {
       int now;
       double d;
       bool operator < (const node& rhs) const {
           return d > rhs.d;
       }
   };

   void init() {
       memset(head, -1, sizeof head);
       cnt = ans = 0;
   }

   inline void add(int u, int v, double w) {
       e[cnt].v = v;
       e[cnt].w = w;
       e[cnt].next = head[u];
       head[u] = cnt++;
   }

   void prim() {
       vector<int> vis(n + 1);
       priority_queue<node> q; q.push({1, 0});
       int res = 0;
       while(!q.empty() && res <= n) {
           node p = q.top(); q.pop();
           int u = p.now;
           double dis = p.d;
           if(vis[u]) continue;
           vis[u] = 1, res++, ans += dis;
           for(int i = head[u]; ~i; i = e[i].next) {
               int v = e[i].v;
               if(!vis[v]) q.push({v, e[i].w});
           }
       }
   }
}pr;\end{lstlisting}
\subsection{拓扑排序}
\begin{lstlisting}
const int N = 1e5 + 10;

int deg[N], toppar[N];
struct Edge {
    int u, v, next;
}e[N];

int head[N], cnt, tot;
int n, m;

inline void add(int u, int v) {
    e[++cnt].v = v;
    e[cnt].next = head[u];
    head[u] = cnt;
    deg[v]++;
}

void topsort() {
    queue<int> q;
    for(int i = 1;i <= n; i++) {
        if(deg[i] == 0) q.push(i);
    }
    while(!q.empty()) {
        int x = q.front(); q.pop();
        toppar[++tot] = x;
        for(int i = head[x]; i ; i = e[i].next) {
            int v = e[i].v;
            if(--deg[v] == 0) q.push(v);
        }
    }
}

int main() {
    cin >> n >> m;
    for(int i = 1;i <= m; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v);
    }
    topsort();
    for(int i = 1;i <= tot; i++) cout << toppar[i] << endl;
}\end{lstlisting}
\subsection{链式前向星建图}
\begin{lstlisting}
const int N = 1e5 + 10;

struct Edge {
    int v, w, next;
}e[N];

int head[N], cnt;

inline void add(int u, int v, int w) {
    e[cnt].v = v;
    e[cnt].w = w;
    e[cnt].next = head[u];
    head[u] = cnt;
}

//在二分匹配的时候进行删边操作优化时间复杂度
//在250 * 50的图上能优化100ms左右
inline int del(int x)
{
    if (x == 0)
        return 0;
    int k = del(e[x].next);
    e[x].next = k;
    if ("表达式说明要删")
        return k;
    else
        return x;
}
// for (int i = 1; i < t; i++)
// {
//     del(head[i]);
// }
\end{lstlisting}
\subsection{同余最短路}
\begin{lstlisting}
/*
洛谷P3403: 给定x[0], x[1], x[2], ..., x[n - 1], 对于k <= h, 求有多少个k满足a[0]x[0] + a[1]x[1] + ... + a[n - 1]x[n - 1] = k
洛谷P2662: 最大的不能被x[0], x[1], ..., x[n - 1]表示的数(从小到大), 显然如果gcd(x[i]) = x[0], 无解, 否则跑同余最短路求出max(dis) - x[0]即为答案
解决形如上述类型的题目
 */

/*
一是体现在建图
二是体现在最短路
*/

typedef long long ll;

const int N = 2e6 + 10;
#define INF 0x3f3f3f3f
struct Edge {
    int v, next;
    ll w;
}e[N];
int head[N], cnt;

void add(int u, int v, int w) {
    e[++cnt].v = v;
    e[cnt].w = w;
    e[cnt].next = head[u];
    head[u] = cnt;
}

struct node {
    int now;
    ll d;
    bool operator < (const node& rhs) const {
        return d > rhs.d;
    }
};

priority_queue<node> q;
ll dis[N];

void Dij(int s, int n) {
    vector<bool> vis(n);
    for(int i = 0;i < n; i++) dis[i] = (INF);
    dis[s] = 1;
    q.push({s, 1});
    while(!q.empty()) {
        node p = q.top(); q.pop();
        int u = p.now;
        if(vis[u]) continue;
        vis[u] = 1;
        for(int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if(dis[v] > dis[u] + e[i].w) {
                dis[v] = dis[u] + e[i].w;
                q.push({v, dis[v]});
            }
        }
    }
}

ll solve(ll *x, int n, ll h) {
    sort(x, x + n);
    if(x[0] == 1) return h;
    for(int i = 0;i < x[0]; i++) {
        for(int j = 1;j < n; j++) {
            add(i, (i + x[j]) % x[0], x[j]);
        }
    }
    Dij(1, x[0]);
    ll ans = 0;
    for(int i = 0;i < x[0]; i++) {
        if(h >= dis[i]) ans += (h - dis[i]) / x[0] + 1;
    }
    return ans;
}

int main() {
    ll h, n; scanf("%lld", &h);
    for (int i = 0; i < n; i++) scanf("%lld", &x[i]);
    printf("%lld\n", solve(x, n, h));
}

/*----------------------------------------------------*/


const int N = 1e6 + 10;
struct edge {
    int v; ll w;
};

struct node {
    int now; ll d;
    bool operator < (const node& rhs) const {
        return d > rhs.d;
    }
};

vector<edge> g[5];
ll dis[5][N], w;

void Dij() {
    for(int i = 1;i <= 4; i++) {
        for(int j = 0;j < w; j++) {
            dis[i][j] = 1e18;
        }
    }
    dis[2][0] = 0;
    priority_queue<node> q;
    q.push({2, 0});
    while(!q.empty()) {
        node p = q.top(); q.pop();
        int u = p.now;
        if(dis[u][p.d % w] < p.d) continue;
        for(auto e : g[u]) {
            int v = e.v;
            ll len = e.w + p.d;
            if(dis[v][len % w] > len) {
                dis[v][len % w] = len;
                q.push({v, len});
            }
        }
    }
}

void solve() {
    int _; cin >> _;
    while(_--) {
        ll d12, d23, d34, d41, K;
        cin >> K >> d12 >> d23 >> d34 >> d41;
        g[1].emplace_back(edge{2, d12});g[2].emplace_back(edge{1, d12});
        g[2].emplace_back(edge{3, d23});g[3].emplace_back(edge{2, d23});
        g[3].emplace_back(edge{4, d34});g[4].emplace_back(edge{3, d34});
        g[4].emplace_back(edge{1, d41});g[1].emplace_back(edge{4, d41});
        w = 2 * min(d12, d23);
        Dij();
        ll ans = 1e19;
        for(int i = 0;i < w; i++) {
            if(dis[2][i] >= K) ans = min(dis[2][i], ans);
            else ans = min(ans, dis[2][i] + (K - dis[2][i] + w - 1) / w * w);
        }
        cout << ans << endl;
        for(int i = 1;i <= 4; i++) g[i].clear();
    }
}\end{lstlisting}
\subsection{三元环计数}
\begin{lstlisting}
const int N = 1e5 + 10;
int d[N], vis[N];
vector<int> g[N];

int main() {
    int n, m; cin >> n >> m;
    vector<pair<int, int>> a(m + 1);
    for(int i = 1;i <= m; i++) {
        cin >> a[i].first >> a[i].second;
        d[a[i].first]++;
        d[a[i].second]++;
    }
    for(int i = 1;i <= m; i++) {
        int u = a[i].first, v = a[i].second;
        if(d[u] < d[v] || (d[u] == d[u] && u > v)) swap(u, v);
        g[u].push_back(v);    
    }
    int ans = 0;
    for(int u = 1;u <= n; u++) {
        for(auto v : g[u]) vis[v] = u;
        for(auto v : g[u]) {
            for(auto z : g[v]) {
                if(vis[z] == u) ans++;
            }
        }
    }
    cout << ans << endl;
    
}
\end{lstlisting}
\subsection{欧拉图}
\begin{lstlisting}

const int N = 1e4 + 10;
struct Edge {
    int to, next;
    int index;
    int dir;
    bool flag;
} edge[N << 1];

int head[10], tot;

void init() {
    memset(head,−1, sizeof(head));
    tot = 0;
}

void addedge(int u, int v, int index) {
    edge[tot].to = v;
    edge[tot].next = head[u];
    edge[tot].index = index;
    edge[tot].dir = 0;
    edge[tot].flag = false;
    head[u] = tot++;
    edge[tot].to = u;
    edge[tot].next = head[v];
    edge[tot].index = index;
    edge[tot].dir = 1;
    edge[tot].flag = false;
    head[v] = tot++;
}

int du[10];
vector<int> ans;

void dfs(int u) {
    for (int i = head[u]; i != −1;
    i = edge[i].next)
    if (!edge[i].flag) {
        edge[i].flag = true;
        edge[i ^ 1].flag = true;
        dfs(edge[i].to);
        ans.push_back(i);
    }
}

int main() {
    int n;
    while (scanf("%d", &n) == 1) {
        init();
        int u, v;
        memset(du, 0, sizeof(du));
        for (int i = 1; i <= n; i++) {
            scanf("%d%d", &u, &v);
            addedge(u, v, i);
            du[u]++;
            du[v]++;
        }
        int s = −1;
        int cnt = 0;
        for (int i = 0; i <= 6; i++) {
            if (du[i] & 1) {
                cnt++;
                s = i;
            }
            if (du[i] > 0 && s == −1)
            s = i;
        }
        bool ff = true;
        if (cnt != 0 && cnt != 2) {
            printf("No␣solution\n");
            continue;
        }
        ans.clear()
        dfs(s);
        if (ans.size() != n) {
            printf("No␣solution\n");
            continue;
        }
        for (int i = 0; i < ans.size(); i++) {
            printf("%d", edge[ans[i]].index);
            if (edge[ans[i]].dir == 0)printf("−\n");
            else printf("+\n");
        }
    }
    return 0;
}
\end{lstlisting}
\subsection{DFS判连通块}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e5 + 10;

int n, m;
vector<int> vec[maxn];
int vis[maxn]; // 标记数组

void DFS(int u)
{
    vis[u] = 1;
    for(int i = 0;i < vec[u].size(); i++) {
        int v = vec[u][i];
        if(vis[v] == 0)
            DFS(v);
    }
}

void solve() {
    cin >> n >> m;
    int u, v;
    for(int i = 1;i <= m; i++) {
        cin >> u >> v;
        vec[u].push_back(v);
        vec[v].push_back(u);
    }
    int ans = 0;
    for(int i = 1;i <= n; i++) {
        if(vis[i] == 0) {
            DFS(i);
            ans++;
        }
    }
    cout << ans << endl;
}\end{lstlisting}
\subsection{并查集判连通块}
\begin{lstlisting}
const int maxn = 5e5 + 10;

int n, m, k;
int pre[maxn], cnt[maxn];

int find(int x) {
    if(pre[x] == x)
        return x;
    int y = find(pre[x]);
    pre[x] = y;
    return y;
}

void merge(int u, int v) {
    int x = find(u);
    int y = find(v);
    if(x != y) pre[x] = y;
}

void init(int n) {
    for(int i = 1;i <= n; i++) {
        pre[i] = i;
        cnt[i] = 0;
    }
}

void solve() {
    cin >> n >> m;
    init(n);
    int u, v;
    for(int i = 1;i <= m; i++) {
        cin >> u >> v;
        merge(u, v);
    }
    
    int ans = 0;
    // first
    for(int i = 1;i <= n; i++) {
        cnt[find(i)]++;
    }
    for(int i = 1;i <= n; i++) {
        if(cnt[i])
            ans++;
    }
    
    //second
    for(int i = 1;i <= n; i++) {
        int s = find(i);
        if(cnt[s] == 0) {
            cnt[s]++;
            ans++;
        }
    }
    
    //third
    for(int i = 1;i <= n; i++) {
        if(pre[i] == i)
            ans++;
    }
    cout << ans << endl;
}\end{lstlisting}
\subsection{Tarjan}
\begin{lstlisting}

#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 10;

struct Edge{
    int u, v, next;
}e[N * 2];

int head[N], cnt;

int dfn[N], low[N]; // 第一次访问到的节点的编号和最早访问的节点的编号（时间戳）
bool vis[N]; // 标记节点是否访问过并且还在栈中
int Time = 1;
stack<int> s;

void add(int u, int v) {
    e[++cnt].v = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void DFS(int u) {
    s.push(u);
    dfn[u] = low[u] = Time++;
    vis[u] = 1;

    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].v;
        if(!dfn[v]) {
            DFS(v);
            low[u] = min(low[u], low[v]); // 更新时间戳
        }
        else if(vis[v]) {
            low[u] = min(low[u], low[v]); // 更新时间戳
        }

    }

    if(dfn[u] == low[u]) { // 找到了一个强连通分量
        int x;
        do {
            x = s.top();
            cout << x << " ";
            vis[x] = 0;
            s.pop();
        }while(x != u);
        cout << endl;
    }
}

void Tarjan() {
    int n, m;
    cin >> n >> m;

    for(int i = 1;i <= m; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v);
    }
    
    for(int i = 1;i <= n; i++) {
        if(!dfn[i])
            DFS(i);
    }
}

\end{lstlisting}
\subsection{割点和桥}
\begin{lstlisting}
const int N = 2e5 + 10;

struct Edge{
    int u, v, next;
}e[N * 2];

int head[N], cnt;

int dfn[N], low[N]; // 第一次访问到的节点的编号和最早访问的节点的编号（时间戳）
bool vis[N]; // 标记节点是否访问过并且还在栈中
int fa[N]; // 父亲节点
int Time = 1;
set<int> s1;
set<pair<int, int> > s2;

void add(int u, int v) {
    e[++cnt].v = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void DFS(int u) {
    dfn[u] = low[u] = Time++;
    int child = 0;

    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].v;

        if(!dfn[v]) {
            child++;
            fa[v] = u;
            DFS(v);
            if(fa[u] == -1 && child >= 2) // u是根节点，并且有两个儿子----是割点
                s1.insert(u);
            else if(fa[u] != -1 && low[v] >= dfn[u]) // u不是根节点，并且有儿子，并且low[v]>=low[u]----是割点
                s1.insert(u);
            else if(low[v] > dfn[u])
                s2.insert({u, v});
            low[u] = min(low[u], low[v]);
        }
        else if(v != fa[u]) // 这一步说明可以不经过父亲而回到祖先，可以尝试更新(条件可以不写，不影响)
            low[u] = min(low[u], dfn[v]);
    }
}

void Tarjan() {
    int n, m;
    cin >> n >> m;
    memset(fa, -1, sizeof(fa));

    for(int i = 1;i <= m; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    
    for(int i = 1;i <= n; i++) {
        if(!dfn[i])
            DFS(i);
    }

    cout << s1.size() << endl;
    for(auto x : s1) cout << x << endl;

    cout << s2.size() << endl;
    for(auto x : s2) cout << x.first << "---" << x.second << endl;
}

\end{lstlisting}
\subsection{差分约束}
\begin{lstlisting}
  
/*
差分约束是解决这样一类问题
给出n个形如x[j] − x[i] <= k的式子，求x[n] − x[1]的最大/最小值
最大值—>把所有式子整理为x[j] − x[i] <= k，从i向j连一条边权为k的边，跑最短路
最小值—>把所有式子整理为x[j] − x[i] >= k，从i向j连一条边权为k的边，跑最长路
注意初始化 有时候需要超级源点0
*/

bool spfa(int u) {//dfs跑差分约束最短路
    vis[u] = 1;
    for (int i = head[u], v; i; i = e[i].nxt)
        if (dis[u] + e[i].w < dis[v = e[i].to]) {
            if (vis[v]) return false;
            else {
                dis[v] = dis[u] + e[i].w;
                if (!spfa(v)) return false;
            }
        }
    vis[u] = 0;
    return true;
}\end{lstlisting}
\subsection{AHU算法}
\begin{lstlisting}
﻿//用来判断两棵树是否同构
// AHU :判断两棵树是否是同构
//同构:在更换节点的标号之后两棵树能完全相同

const int N = 1e5 + 5;
const int maxn = N << 1;

int n;
struct Edge {
    int v, nxt;
} e[maxn << 1];
int head[maxn], sz[maxn], f[maxn], maxv[maxn], tag[maxn], tot, Max;
vector<int> center[2], L[maxn], subtree_tags[maxn];
void addedge(int u, int v) {
    e[tot].v = v;
    e[tot].nxt = head[u];
    head[u] = tot++;
    e[tot].v = u;
    e[tot].nxt = head[v];
    head[v] = tot++;
}

void dfs_size(int u, int fa) {
    sz[u] = 1;
    maxv[u] = 0;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fa) continue;
        dfs_size(v, u);
        sz[u] += sz[v];
        maxv[u] = max(maxv[u], sz[v]);
    }
}

void dfs_center(int rt, int u, int fa, int id) {
    maxv[u] = max(maxv[u], sz[rt] - sz[u]);
    if (Max > maxv[u]) {
        center[id].clear();
        Max = maxv[u];
    }
    if (Max == maxv[u]) center[id].push_back(u);
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fa) continue;
        dfs_center(rt, v, u, id);
    }
}

int dfs_height(int u, int fa, int depth) {
    L[depth].push_back(u);
    f[u] = fa;
    int h = 0;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fa) continue;
        h = max(h, dfs_height(v, u, depth + 1));
    }
    return h + 1;
}

void init(int n) {
    for (int i = 1; i <= 2 * n; i++) head[i] = 0;
    tot = 1;
    center[0].clear();
    center[1].clear();

    int u, v;
    for (int i = 1; i <= n - 1; i++) {//在这里输入第一棵树的边
        scanf("%d %d", &u, &v);
        addedge(u, v);
    }
    dfs_size(1, -1);
    Max = n;
    dfs_center(1, 1, -1, 0);

    for (int i = 1; i <= n - 1; i++) {//在这里输入第二棵树的边
        scanf("%d %d", &u, &v);
        addedge(u + n, v + n);
    }
    dfs_size(1 + n, -1);
    Max = n;
    dfs_center(1 + n, 1 + n, -1, 1);
}

bool cmp(int u, int v) { return subtree_tags[u] < subtree_tags[v]; }

bool rootedTreeIsomorphism(int rt1, int rt2) {
    for (int i = 0; i <= 2 * n + 1; i++) L[i].clear(), subtree_tags[i].clear();
    int h1 = dfs_height(rt1, -1, 0);
    int h2 = dfs_height(rt2, -1, 0);
    if (h1 != h2) return false;
    int h = h1 - 1;
    for (int j = 0; j < (int)L[h].size(); j++) tag[L[h][j]] = 0;
    for (int i = h - 1; i >= 0; i--) {
        for (int j = 0; j < (int)L[i + 1].size(); j++) {
            int v = L[i + 1][j];
            subtree_tags[f[v]].push_back(tag[v]);
        }

        sort(L[i].begin(), L[i].end(), cmp);

        for (int j = 0, cnt = 0; j < (int)L[i].size(); j++) {
            if (j && subtree_tags[L[i][j]] != subtree_tags[L[i][j - 1]]) ++cnt;
            tag[L[i][j]] = cnt;
        }
    }
    return subtree_tags[rt1] == subtree_tags[rt2];
}

bool treeIsomorphism() {
    if (center[0].size() == center[1].size()) {
        if (rootedTreeIsomorphism(center[0][0], center[1][0])) return true;
        if (center[0].size() > 1)
            return rootedTreeIsomorphism(center[0][0], center[1][1]);
    }
    return false;
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        init(n);
        puts(treeIsomorphism() ? "YES" : "NO");
    }
    return 0;
}\end{lstlisting}
\subsection{Astar}
\begin{lstlisting}
﻿#include "bits/stdc++.h"
using namespace std;
//A*
//用来计算点A到点B的第k短的路径

const int MAXN = 55;
const int MAXM = MAXN * MAXN;

int dis[MAXN];
int n, m, k, a, b, cnt;
bool hav = false;

namespace G1{//反图
    int to[MAXM], val[MAXM], head[MAXN], nxt[MAXM], cnt;
    bool vis[MAXN];

    void AddEdge(int u, int v, int w) {
        cnt++;
        to[cnt] = v;
        val[cnt] = w;
        nxt[cnt] = head[u];
        head[u] = cnt;
    }

    void Spfa(int s, int t) {//SPFA+SLF跑最短路
        memset(dis, 0x7f, sizeof(dis)); dis[s] = 0;
        deque<int> q; q.push_back(s); vis[s] = true;
        while (!q.empty()) {
            int u = q.front(); q.pop_front(); vis[u] = false;
            for (int i = head[u]; i; i = nxt[i]) {
                int v = to[i];
                if (dis[v] > dis[u] + val[i]) {
                    dis[v] = dis[u] + val[i];
                    if (!vis[v]) {
                        vis[v] = true;
                        if (!q.empty() && dis[v] < dis[q.front()]) {
                            q.push_front(v);
                        } else {
                            q.push_back(v);
                        }
                    }
                }
            }
        }
    }
}

namespace G2{//原图
    int to[MAXM], val[MAXM], nxt[MAXM], head[MAXN], cnt;

    void AddEdge(int u, int v, int w) {
        cnt++;
        to[cnt] = v;
        val[cnt] = w;
        nxt[cnt] = head[u];
        head[u] = cnt;
    }

    struct Data{//当前位置，走过的距离，s->now->t总距离，走的步骤
        int now, pas, val;
        vector<int> route;
        /*
        bool operator < (const Data &b) const {return val > b.val;}
        */
        bool operator < (const Data &b) const {//重载
            if (val != b.val) return val > b.val;
            int sz = min(route.size(), b.route.size());
            for (int i = 0; i < sz; i++) {
                if (route[i] != b.route[i]) return route[i] > b.route[i];
            }
            return route.size() > b.route.size();
        }
    };

    void Astar(int s, int t) {//A*
        priority_queue<Data> q;
        Data st;
        st.now = s; st.pas = 0; st.val = dis[s]; st.route = vector<int>{s};
        q.push(st);
        vector<int> vec;
        while (!q.empty()) {
            Data u = q.top(); q.pop();
            if (u.now == t) {//更新路径数
                :: cnt++;
                if (:: cnt == k) {//最终答案
                    cout << u.route[0];
                    for (int i = 1, sz = u.route.size(); i < sz; i++)
                        cout << '-' << u.route[i];
                    hav = true;
                    return;
                }
            }
            for (int i = head[u.now]; i; i = nxt[i]) {//广搜
                int v = to[i];
                vec = u.route;
                bool visit = false;
                for (int j = 0, sz = vec.size(); j < sz; j++) {//记录是否重复经过
                    if (vec[j] == v) {
                        visit = true;
                        break;
                    }
                }
                if (visit) continue;
                Data nx = u;
                nx.now = v;
                nx.pas = u.pas + val[i];
                nx.val = dis[v] + nx.pas;
                nx.route.push_back(v);
                q.push(nx);
            }
        }
    }
}

int main() {
    cin >> n >> m >> k >> a >> b;
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        G1 :: AddEdge(v, u, w);
        G2 :: AddEdge(u, v, w);
    }
    G1 :: Spfa(b, a);
    G2 :: Astar(a, b);
    if (!hav) cout << "No" << endl;
    return 0;
}\end{lstlisting}
\subsection{Dinic}
\begin{lstlisting}

struct Dinic {
    static const int N = 1e3 + 10, M = 2e5 + 10, INF = 0x3f3f3f;
    int n, m, s, t;
    int maxflow;
    int deep[N], cur[N];

    struct Edge {
        int v, next;
        int cap;
    }e[M << 1];
    int head[M << 1], cnt;

    void init() {
        memset(head, -1, sizeof head);
        cnt = maxflow = 0;
    }

    void add(int u, int v, int cap) {
        e[cnt].v = v;
        e[cnt].cap = cap;
        e[cnt].next = head[u];
        head[u] = cnt++;
        
        e[cnt].v = u;
        e[cnt].cap = 0;
        e[cnt].next = head[v];
        head[v] = cnt++;
    }

    bool bfs() {
        for(int i = 0;i <= t; i++) {
            deep[i] = -1, cur[i] = head[i];
        }
        queue<int> q;   
        q.push(s); deep[s] = 0;
        while(!q.empty()) {
            int u = q.front(); q.pop();
                for(int i = head[u]; ~i; i = e[i].next) {
                int v = e[i].v;
                if(deep[v] == -1 && e[i].cap) {
                    deep[v] = deep[u] + 1;
                    q.push(v);
                }
            }
        }
        if(deep[t] >= 0) return true;
        else return false;
    }

    int dfs(int u, int mx) {
        int a;
        if(u == t) return mx;
        for(int i = cur[u]; ~i; i = e[i].next) {
            cur[u] = i;
            int v = e[i].v;
            if(e[i].cap && deep[v] == deep[u] + 1 && (a = dfs(v, min(mx, e[i].cap)))) {
                e[i].cap -= a;
                e[i ^ 1].cap += a;
                return a;
            }
        }
        return 0;
    }

    void dinic() {
        while(bfs()) {
            while(1) {
                int res = dfs(s, INF);
                if(!res) break;
                maxflow += res;
            }
        }
    }
}mf;
\end{lstlisting}
\subsection{ISAP}
\begin{lstlisting}
struct ISAP {
    const static int N = ...;//node size
    struct Edge {
        int from, to, cap, flow;
        bool operator < (const Edge &rhs) const {
            return from < rhs.from || (from == rhs.from && to < rhs.to);
        }
    };
    int n, m, s, t;
    vector<Edge> edges;
    vector<int> g[N];
    bool vis[N];
    int dep[N], cur[N], p[N], num[N];

    void addEdge(int from, int to, int cap) {
        edges.push_back(Edge{from, to, cap, 0});
        edges.push_back(Edge{to, from, 0, 0});
        m = edges.size();
        g[from].push_back(m - 2);
        g[to].push_back(m - 1);
    }

    bool bfs() {
        memset(vis, 0, sizeof(vis));
        queue<int> q; q.push(t); vis[t] = 1, dep[t] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (auto &v: g[u]) {
                Edge &e = edges[v ^ 1];
                if (!vis[e.from] && e.cap > e.flow) {
                    dep[e.from] = dep[u] + (vis[e.from] = 1);
                    q.push(e.from);
                }
            }
        }
        return vis[s];
    }

    void init(int siz) {
        n = siz;
        for (int i = 0; i < siz; i++) g[i].clear();
        edges.clear();
    }

    int augment() {
        int u = t, a = INF;
        while (u != s) {
            Edge &e = edges[p[u]];
            a = min(a, e.cap - e.flow);
            u = edges[p[u]].from;
        }
        u = t;
        while (u != s) {
            edges[p[u]].flow += a;
            edges[p[u] ^ 1].flow -= a;
            u = edges[p[u]].from;
        }
        return a;
    }

    int maxFlow(int S, int T) {
        s = S, t = T;
        int flow = 0; bfs();
        memset(num, 0, sizeof(num));
        for (int i = 0; i < n; i++) num[dep[i]]++;
        int u = S;
        memset(cur, 0, sizeof(cur));
        while (dep[S] < n) {
            if (u == T) {
                flow += augment();
                u = S;
            }
            int ok = 0;
            for (int i = cur[u]; i < g[u].size(); i++) {
                Edge &e = edges[g[u][i]];
                if (e.cap > e.flow && dep[u] == dep[e.to] + 1) {
                    ok = 1;
                    p[e.to] = g[u][i];
                    cur[u] = i;
                    u = e.to;
                    break;
                }
            }
            if (!ok) {
                int mn = n - 1;
                for (int i = 0; i < g[u].size(); i++) {
                    Edge &e = edges[g[u][i]];
                    if (e.cap > e.flow) mn = min(mn, dep[e.to]);
                }
                if (--num[dep[u]] == 0) break;
                num[dep[u] = mn + 1]++;
                cur[u] = 0;
                if (u != S) u = edges[p[u]].from;
            }
        }
        return flow;
    }

} flow;\end{lstlisting}
\subsection{MCMF}
\begin{lstlisting}
const int maxn = 1005;      //点数

struct Edge {
    int from, to, cap, flow, cost;

    Edge(int u, int v, int c, int f, int cc)
            : from(u), to(v), cap(c), flow(f), cost(cc) {}
};

struct MCMF {
    int n, m;
    vector<Edge> edges;
    vector<int> G[maxn];
    int inq[maxn];  //是否在队列中
    int d[maxn];    //bellmanford
    int p[maxn];    //上一条弧
    int a[maxn];    //可改进量
    void init(int n) {
        this->n = n;
        for (int i = 0; i <= n; ++i) G[i].clear();
        edges.clear();
    }

    void add(int from, int to, int cap, int cost) {
        edges.emplace_back(Edge(from, to, cap, 0, cost));
        edges.emplace_back(Edge(to, from, 0, 0, -cost));
        m = int(edges.size());
        G[from].emplace_back(m - 2);
        G[to].emplace_back(m - 1);
    }

    bool spfa(int s, int t, int &flow, int &cost) {
        for (int i = 1; i <= n; ++i) d[i] = INF;
        memset(inq, 0, sizeof(inq));
        d[s] = 0;
        inq[s] = 1;
        p[s] = 0;
        queue<int> q;
        a[s] = INF;
        q.push(s);
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            inq[u] = 0;
            for (int i = 0; i < int(G[u].size()); ++i) {
                Edge &e = edges[G[u][i]];
                if (e.cap > e.flow && d[e.to] > d[u] + e.cost) {
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if (!inq[e.to]) {
                        q.push(e.to);
                        inq[e.to] = 1;
                    }
                }
            }
        }
        if (d[t] == INF) return false;
        flow += a[t];
        cost += d[t] * a[t];
        for (int u = t; u != s; u = edges[p[u]].from) {
            edges[p[u]].flow += a[t];
            edges[p[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int MincostMaxflow(int s, int t, int &cost) {
        int flow = 0;
        cost = 0;
        while (spfa(s, t, flow, cost));
        return flow;
    }
} mcmf;\end{lstlisting}
\clearpage\section{其他}
\subsection{普通莫队}
\begin{lstlisting}
// O(n*sqrt(n))
const int N = 1e5 + 10;

int a[N], cnt[N], ans[N];
int belong[N];

struct Q {
    int l, r, id;
}q[N];

int Size, bnum;

bool cmp(Q a, Q b) {
    return (belong[a.l] ^ belong[b.l]) ? belong[a.l] < belong[b.l] : belong[a.l] & 1 ? a.r < b.r : a.r > b.r; 
}

int now = 0;

inline void add(int pos) {
    if(!cnt[a[pos]]) now++;
    ++cnt[a[pos]];
}

inline void del(int pos) {
    --cnt[a[pos]];
    if(!cnt[a[pos]]) --now;
}

int main() {
    int n, m;
    cin >> n >> m;
    Size = sqrt(n);
    bnum = ceil((double)n / Size);
    for(int i = 1;i <= bnum; i++) {
        for(int j = (i - 1) * Size + 1;j <= i * Size; j++) {
            belong[j] = i;
        }
    }
    for(int i = 1;i <= n; i++) cin >> a[i];
    for(int i = 1;i <= m; i++) {
        cin >> q[i].l >> q[i].r;
        q[i].id = i;
    }
    sort(q + 1, q + m + 1, cmp);
    int l = 1, r = 0;
    for(int i = 1;i <= m; i++) {
        int ql = q[i].l, qr = q[i].r;
        while(r < qr) add(++r);
        while(r > qr) del(r--);
        while(l < ql) del(l++);
        while(l > ql) add(--l);
        ans[q[i].id] = now;
    }
    for(int i = 1;i <= m; i++) cout << ans[i] << endl;  
}

\end{lstlisting}
\subsection{带修莫队}
\begin{lstlisting}
//带修莫队模板题
//查询[ql, qr]间不同颜色数量，带修改

// O(n^{5/3})

int n, m;
int c[N], cnt[N];
int belong[N], size, totq, totm;
int ans[N], res;

struct Query {
    int l, r, t, id;
    bool operator < (const Query &rhs) const {
        return belong[l] ^ belong[rhs.l] ? belong[l] < belong[rhs.l] :
               (belong[r] ^ belong[rhs.r] ? belong[r] < belong[rhs.r] : t < rhs.t);
    }
} q[N];

struct Modify {
    int pos, val;
} modify[N];

void add(int x) {
    if (!cnt[c[x]]) res++;
    cnt[c[x]]++;
}

void del(int x) {
    cnt[c[x]]--;
    if (!cnt[c[x]]) res--;
}

void upd(int x, int ql, int qr) {
    int pos = modify[x].pos;
    if (ql <= pos && pos <= qr) {
        cnt[c[pos]]--; if (!cnt[c[pos]]) res--;
        if (!cnt[modify[x].val]) res++; cnt[modify[x].val]++;
    }
    swap(modify[x].val, c[pos]);//��θĵ����´λ�Ļ�ȥ
}

int main() {
#ifdef ACM_LOCAL
    freopen("input.in", "r", stdin);
    freopen("output.out", "w", stdout);
#endif
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
    for (int i = 1; i <= m; i++) {
        char op[10]; scanf("%s", op);
        if (op[0] == 'Q') {
            int ql, qr; scanf("%d%d", &ql, &qr); totq++;
            q[totq] = Query{ql, qr, totm, totq};
        }
        else {
            int pos, val; scanf("%d%d", &pos, &val); totm++;
            modify[totm] = Modify{pos, val};
        }
    }

    //size = N ^ (2 / 3), (N * totm) ^ (1 / 3)
    size = ceil(pow(n, (long double)2.0 / 3)); int num = ceil((long double)n / size);
    for (int i = 1, j = 1; i <= num; i++)
        while (j <= i * size && j <= n)
            belong[j++] = i;

    sort(q + 1, q + 1 + totq);

    int l = 1, r = 0, t = 0;
    for (int i = 1; i <= totq; i++) {
        int ql = q[i].l, qr = q[i].r, qt = q[i].t;
        while (l < ql) del(l++);
        while (l > ql) add(--l);
        while (r < qr) add(++r);
        while (r > qr) del(r--);
        while (t < qt) upd(++t, ql, qr);
        while (t > qt) upd(t--, ql, qr);
        ans[q[i].id] = res;
    }

    for (int i = 1; i <= totq; i++) printf("%d\n", ans[i]);

    return 0;
}
\end{lstlisting}
\subsection{回滚莫队}
\begin{lstlisting}
//问题可以莫队（询问可以离线，不带修改）
//区间伸长的时候很好维护信息
//区间缩短的时候不太好维护信息（如最大值，删除以后不知道次大值是多少)
// O(nsqrt(n))

struct Hash {
    int b[N], tot;
    void init() { tot = 0; }
    void insert(int x) { b[++tot] = x; }
    void build() {
        sort(b + 1, b + 1 + tot);
        tot = unique(b + 1, b + 1 + tot) - (b + 1);
    }
    int pos(int x) { return lower_bound(b + 1, b + 1 + tot, x) - b; }
} ha;

int n, m;
int c[N], pos[N], cnt[N], cntt[N];
int belong[N], sizz;
ll ans[N], res;

struct Query {
    int l, r, id;
    bool operator < (const Query &rhs) const {
        return belong[l] ^ belong[rhs.l] ? belong[l] < belong[rhs.l] : r < rhs.r;
    }
} q[N];

ll bruteForce(int ql, int qr) {
    ll result = 0;
    for (int i = ql; i <= qr; i++) {
        cntt[pos[i]]++;
        result = max(result, 1ll * c[i] * cntt[pos[i]]);
    }
    for (int i = ql; i <= qr; i++) cntt[pos[i]]--;
    return result;
}

void add(int x) {
    cnt[pos[x]]++;
    res = max(res, 1ll * c[x] * cnt[pos[x]]);
}

void del(int x) {
    cnt[pos[x]]--;
}

int main() {


    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &c[i]), ha.insert(c[i]);
    ha.build();
    for (int i = 1; i <= n; i++) pos[i] = ha.pos(c[i]);

    sizz = sqrt(n); int num = ceil((long double)n / sizz);
    for (int i = 1, j = 1; i <= num; i++)
        while (j <= i * sizz && j <= n)
            belong[j++] = i;

    for (int i = 1; i <= m; i++) scanf("%d%d", &q[i].l, &q[i].r), q[i].id = i;
    sort(q + 1, q + 1 + m);

    for (int i = 1, j = 1; i <= num; i++) {
        memset(cnt, 0, sizeof(cnt));
        int right = min(i * sizz, n);
        res = 0;
        for (int l = right + 1, r = right; j <= m && belong[q[j].l] == i; j++, l = right + 1) {
            int ql = q[j].l, qr = q[j].r;
            if (qr - ql + 1 <= sizz) {
                ans[q[j].id] = bruteForce(ql, qr);
                continue;
            }
            while (r < qr) add(++r);
            ll tmp = res;
            while (l > ql) add(--l);
            ans[q[j].id] = res;
            res = tmp;
            while (l < right + 1) del(l++);
        }
    }

    for (int i = 1; i <= m; i++) printf("%lld\n", ans[i]);

    return 0;
}
\end{lstlisting}
\subsection{树上莫队}
\begin{lstlisting}
const int N = 1e5 + 10;

struct Hash {
    int b[N], tot;
    void init() { tot = 0; }
    void insert(int x) { b[++tot] = x; }
    void build() {
        sort(b + 1, b + 1 + tot);
        tot = unique(b + 1, b + 1 + tot) - (b + 1);
    }
    int pos(int x) { return lower_bound(b + 1, b + 1 + tot, x) - b; }
} ha;

int n, m;
int c[N], cnt[N];
vector<int> g[N];
int st[N], ed[N], dfnt, nodeOf[N << 1], tag[N];
int belong[N], sizz;
int ans[N], res;

struct Query {
    int l, r, id, k;
    bool operator < (const Query &rhs) const {
        return belong[l] ^ belong[rhs.l] ? belong[l] < belong[rhs.l] : r < rhs.r;
    }
} q[N];

int son[N], siz[N], top[N], fa[N], dep[N];
void dfs(int u, int par) {
    dep[u] = dep[fa[u] = par] + (siz[u] = 1);
    int max_son = -1; nodeOf[st[u] = ++dfnt] = u;
    for (auto &v: g[u])
        if (v != par) {
            dfs(v, u);
            siz[u] += siz[v];
            if (max_son < siz[v])
                son[u] = v, max_son = siz[v];
        }
    nodeOf[ed[u] = ++dfnt] = u;
}
void dfs2(int u, int topf) {
    top[u] = topf;
    if (!son[u]) return;
    dfs2(son[u], topf);
    for (auto &v: g[u])
        if (v != fa[u] && v != son[u]) dfs2(v, v);
}
int lca(int x, int y) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        x = fa[top[x]];
    }
    return dep[x] < dep[y] ? x : y;
}

void upd(int x) {
    x = nodeOf[x];
    if (tag[x]) {
        cnt[c[x]]--;
        if (!cnt[c[x]]) res--;
    }
    else {
        if (!cnt[c[x]]) res++;
        cnt[c[x]]++;
    }
    tag[x] ^= 1;
}

int main() {
#ifdef ACM_LOCAL
    freopen("input.in", "r", stdin);
    freopen("output.out", "w", stdout);
#endif
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &c[i]), ha.insert(c[i]);
    ha.build();
    for (int i = 1; i <= n; i++) c[i] = ha.pos(c[i]);

    for (int i = 1; i < n; i++) {
        int u, v; scanf("%d%d", &u, &v);
        g[u].push_back(v); g[v].push_back(u);
    }
    int rt = 1; dfs(rt, 0); dfs2(rt, rt);

    sizz = sqrt(dfnt); int num = ceil((long double)dfnt / sizz);
    for (int i = 1, j = 1; i <= num; i++)
        while (j <= i * sizz && j <= dfnt)
            belong[j++] = i;
    for (int i = 1; i <= m; i++) {
        int u, v; scanf("%d%d", &u, &v);
        int tlca = lca(u, v);
        if (st[u] > st[v]) swap(u, v);
        if (u == tlca) q[i] = Query{st[u], st[v], i, 0};
        else q[i] = Query{ed[u], st[v], i, tlca};

    }
    sort(q + 1, q + 1 + m);

    int l = 1, r = 0;
    for (int i = 1; i <= m; i++) {
        int ql = q[i].l, qr = q[i].r;
        while (l < ql) upd(l++);
        while (l > ql) upd(--l);
        while (r < qr) upd(++r);
        while (r > qr) upd(r--);
        ans[q[i].id] = res + (q[i].k ? (cnt[c[q[i].k]] == 0) : 0);
    }

    for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);

    return 0;
}
\end{lstlisting}
\subsection{快读}
\begin{lstlisting}
namespace FastIO {
    char gc(void) {
        const int S = 1 << 17;
        static char buf[S], *s = buf, *t = buf;
        if (s == t) t = buf + fread(s = buf, 1, S, stdin);
        if (s == t) return EOF;
        return *s++;
    }

    int read(void) {
        int a = 0, b = 1, c = gc();
        for (; !isdigit(c); c = gc()) b ^= (c == '-');
        for (; isdigit(c); c = gc()) a = a * 10 + c - '0';
        return b ? a : -a;
    }
}
using namespace FastIO;\end{lstlisting}
\subsection{模拟退火}
\begin{lstlisting}
const double DOWN = 0.996;
const double START_T = 5000;
double ansx, ansy, ansz, anse;

void initAns() {
    //初始化一个答案点(可以选任意点)
}

double getEnergy(double x, double y, double z) {
    //具体分析题目
}

void SA() {
    double T = START_T;
    while (T > 1e-15) {
        double newx = ansx + (rand() * 2 - RAND_MAX) * T;
        double newy = ansy + (rand() * 2 - RAND_MAX) * T;
        double newz = ansz + (rand() * 2 - RAND_MAX) * T;
        double newe = getEnergy(newx, newy, newz);
        double delta = newe - anse;
        if (delta < 0) ansx = newx, ansy = newy, ansz = newz, anse = newe;
        else if (exp(-delta / T) * RAND_MAX > rand())
            ansx = newx, ansy = newy, ansz = newz;
        T *= DOWN;
    }
}

void solve() {
    initAns();
    while ((double) clock() / CLOCKS_PER_SEC < 2.0) SA();
}

\end{lstlisting}
\subsection{Cantor}
\begin{lstlisting}
  
//主要应用为将N维的排列状态压缩成数字id
//然后需要知道具体状态时用逆Cantor得到

int N;
int a[MAX], c[MAX];

void upd(int p, int k) { for (; p <= N; p += lowbit(p)) c[p] += k; }
int query(int p) {
    int res = 0;
    for (; p; p -= lowbit(p)) res += c[p];
    return res;
}

int cantor() {
    //ans = 1 + \sum_{i = 1} ^ {N} fac[N - i] * (\sum_{j = i + 1} ^ {N} x[i] > x[j])
    int res = 0, fac = 1;
    for (int i = N; i >= 1; i--) {
        upd(a[i], 1);
        res = (res + 1ll * fac * query(a[i] - 1) % mod) % mod;
        fac = 1ll * fac * (N - i + 1) % mod;
    }
    return res + 1;
}

//逆Cantor
#define lc  u<<1
#define rc  u<<1|1
#define mid (l+r)/2
int sum[MAX << 4];
void push_up(int u) { sum[u] = sum[lc] + sum[rc]; }
void build(int u, int l, int r) {
    if (l == r) {
        sum[u] = 1;
        return;
    }
    build(lc, l, mid); build(rc, mid + 1, r);
    push_up(u);
}
int query(int u, int l, int r, int k) {//查找第k大并且删除该数
    sum[u]--;
    if (l == r) return l;
    if (k <= sum[lc]) return query(lc, l, mid, k);
    else return query(rc, mid + 1, r, k - sum[lc]);
}

vector<int> inCantor(int x, int n) {
    x--;
    vector<int> res;
    ll fac = 1;
    build(1, 1, n);
    for (int i = 1; i <= n; i++) fac = fac * i;
    for (int i = 1; i <= n; i++) {
        fac = fac / (n - i + 1);
        int k = x / fac + 1;//比当前这位大的有x / fac位
        res.push_back(query(1, 1, n, k));//找到没被选的第k大
        x %= fac;
    }
    return res;
}\end{lstlisting}
\subsection{BigInteger}
\begin{lstlisting}
struct BigInteger {
    typedef unsigned long long LL;

    static const int BASE = 100000000;
    static const int WIDTH = 8;
    vector<int> s;

    BigInteger& clean() { while (!s.back() && s.size()>1)s.pop_back(); return *this; }
    BigInteger(LL num = 0) { *this = num; }
    BigInteger(string s) { *this = s; }
    BigInteger& operator = (long long num) {
        s.clear();
        do {
            s.push_back(num % BASE);
            num /= BASE;
        } while (num > 0);
        return *this;
    }
    BigInteger& operator = (const string& str) {
        s.clear();
        int x, len = (str.length() - 1) / WIDTH + 1;
        for (int i = 0; i < len; i++) {
            int end = str.length() - i*WIDTH;
            int start = max(0, end - WIDTH);
            sscanf(str.substr(start, end - start).c_str(), "%d", &x);
            s.push_back(x);
        }
        return (*this).clean();
    }

    BigInteger operator + (const BigInteger& b) const {
        BigInteger c; c.s.clear();
        for (int i = 0, g = 0; ; i++) {
            if (g == 0 && i >= s.size() && i >= b.s.size()) break;
            int x = g;
            if (i < s.size()) x += s[i];
            if (i < b.s.size()) x += b.s[i];
            c.s.push_back(x % BASE);
            g = x / BASE;
        }
        return c;
    }
    BigInteger operator - (const BigInteger& b) const {
        assert(b <= *this); // 减数不能大于被减数
        BigInteger c; c.s.clear();
        for (int i = 0, g = 0; ; i++) {
            if (g == 0 && i >= s.size() && i >= b.s.size()) break;
            int x = s[i] + g;
            if (i < b.s.size()) x -= b.s[i];
            if (x < 0) { g = -1; x += BASE; }
            else g = 0;
            c.s.push_back(x);
        }
        return c.clean();
    }
    BigInteger operator * (const BigInteger& b) const {
        int i, j; LL g;
        vector<LL> v(s.size() + b.s.size(), 0);
        BigInteger c; c.s.clear();
        for (i = 0; i<s.size(); i++) for (j = 0; j<b.s.size(); j++) v[i + j] += LL(s[i])*b.s[j];
        for (i = 0, g = 0; ; i++) {
            if (g == 0 && i >= v.size()) break;
            LL x = v[i] + g;
            c.s.push_back(x % BASE);
            g = x / BASE;
        }
        return c.clean();
    }
    BigInteger operator / (const BigInteger& b) const {
        assert(b > 0);  // 除数必须大于0
        BigInteger c = *this;       // 商:主要是让c.s和(*this).s的vector一样大
        BigInteger m;               // 余数:初始化为0
        for (int i = s.size() - 1; i >= 0; i--) {
            m = m*BASE + s[i];
            c.s[i] = bsearch(b, m);
            m -= b*c.s[i];
        }
        return c.clean();
    }
    BigInteger operator % (const BigInteger& b) const { //方法与除法相同
        BigInteger c = *this;
        BigInteger m;
        for (int i = s.size() - 1; i >= 0; i--) {
            m = m*BASE + s[i];
            c.s[i] = bsearch(b, m);
            m -= b*c.s[i];
        }
        return m;
    }
    // 二分法找出满足bx<=m的最大的x
    int bsearch(const BigInteger& b, const BigInteger& m) const {
        int L = 0, R = BASE - 1, x;
        while (1) {
            x = (L + R) >> 1;
            if (b*x <= m) { if (b*(x + 1)>m) return x; else L = x; }
            else R = x;
        }
    }
    BigInteger& operator += (const BigInteger& b) { *this = *this + b; return *this; }
    BigInteger& operator -= (const BigInteger& b) { *this = *this - b; return *this; }
    BigInteger& operator *= (const BigInteger& b) { *this = *this * b; return *this; }
    BigInteger& operator /= (const BigInteger& b) { *this = *this / b; return *this; }
    BigInteger& operator %= (const BigInteger& b) { *this = *this % b; return *this; }

    bool operator < (const BigInteger& b) const {
        if (s.size() != b.s.size()) return s.size() < b.s.size();
        for (int i = s.size() - 1; i >= 0; i--)
            if (s[i] != b.s[i]) return s[i] < b.s[i];
        return false;
    }
    bool operator >(const BigInteger& b) const { return b < *this; }
    bool operator<=(const BigInteger& b) const { return !(b < *this); }
    bool operator>=(const BigInteger& b) const { return !(*this < b); }
    bool operator!=(const BigInteger& b) const { return b < *this || *this < b; }
    bool operator==(const BigInteger& b) const { return !(b < *this) && !(b > *this); }
};

ostream& operator << (ostream& out, const BigInteger& x) {
    out << x.s.back();
    for (int i = x.s.size() - 2; i >= 0; i--) {
        char buf[20];
        sprintf(buf, "%08d", x.s[i]);
        for (int j = 0; j < strlen(buf); j++) out << buf[j];
    }
    return out;
}

istream& operator >> (istream& in, BigInteger& x) {
    string s;
    if (!(in >> s)) return in;
    x = s;
    return in;
}

int main()
{
    int t;
    scanf("%d", &t);
    while (t--)
    {
        BigInteger a, b;
        cin >> a >> b;
        cout << a + b << endl;
    }
}
\end{lstlisting}
\subsection{牛顿迭代法手动开根}
\begin{lstlisting}
import java.math.*;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        BigInteger n, x;
        String s;

        //定义"two"为BigInteger类，值为2
        BigInteger two = new BigInteger("2");

        n = in.nextBigInteger();

        //toString()方法返回该对象的字符串表示,保存在s中
        s = n.toString();

        //x为BigInteger类，值为 截取字符串开头到s.length()/2 + 1位置的子串 并转化成BigInteger类
        x = new BigInteger(s.substring(0, s.length()/2 + 1));

        //当x * x > n时,
        //x = (x + (n/x)) / 2
        while(x.multiply(x).compareTo(n) > 0)
            x = x.add(n.divide(x)).divide(two);
    }
}

\end{lstlisting}

\end{document}
